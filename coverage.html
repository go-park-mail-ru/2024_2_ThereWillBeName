
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>attractions: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">2024_2_ThereWillBeName/cmd/attractions/main.go (0.0%)</option>
				
				<option value="file1">2024_2_ThereWillBeName/cmd/gateway/main.go (0.0%)</option>
				
				<option value="file2">2024_2_ThereWillBeName/cmd/survey/main.go (0.0%)</option>
				
				<option value="file3">2024_2_ThereWillBeName/cmd/trips/main.go (0.0%)</option>
				
				<option value="file4">2024_2_ThereWillBeName/cmd/users/main.go (0.0%)</option>
				
				<option value="file5">2024_2_ThereWillBeName/docs/docs.go (0.0%)</option>
				
				<option value="file6">2024_2_ThereWillBeName/internal/models/place.go (0.0%)</option>
				
				<option value="file7">2024_2_ThereWillBeName/internal/models/review.go (0.0%)</option>
				
				<option value="file8">2024_2_ThereWillBeName/internal/models/trip.go (100.0%)</option>
				
				<option value="file9">2024_2_ThereWillBeName/internal/models/user.go (0.0%)</option>
				
				<option value="file10">2024_2_ThereWillBeName/internal/pkg/attractions/delivery/grpc/gen/attractions.pb.go (3.9%)</option>
				
				<option value="file11">2024_2_ThereWillBeName/internal/pkg/attractions/delivery/grpc/gen/attractions_grpc.pb.go (0.0%)</option>
				
				<option value="file12">2024_2_ThereWillBeName/internal/pkg/attractions/delivery/grpc/grpc_server.go (0.0%)</option>
				
				<option value="file13">2024_2_ThereWillBeName/internal/pkg/attractions/delivery/http/handler.go (0.0%)</option>
				
				<option value="file14">2024_2_ThereWillBeName/internal/pkg/attractions/repo/place_repository.go (0.0%)</option>
				
				<option value="file15">2024_2_ThereWillBeName/internal/pkg/attractions/usecase/usecase.go (90.9%)</option>
				
				<option value="file16">2024_2_ThereWillBeName/internal/pkg/categories/delivery/grpc/gen/categories.pb.go (12.1%)</option>
				
				<option value="file17">2024_2_ThereWillBeName/internal/pkg/categories/delivery/grpc/gen/categories_grpc.pb.go (0.0%)</option>
				
				<option value="file18">2024_2_ThereWillBeName/internal/pkg/categories/delivery/grpc/grpc_server.go (0.0%)</option>
				
				<option value="file19">2024_2_ThereWillBeName/internal/pkg/categories/delivery/http/handler.go (0.0%)</option>
				
				<option value="file20">2024_2_ThereWillBeName/internal/pkg/categories/repo/categories_repo.go (100.0%)</option>
				
				<option value="file21">2024_2_ThereWillBeName/internal/pkg/categories/usecase/categories_usecase.go (100.0%)</option>
				
				<option value="file22">2024_2_ThereWillBeName/internal/pkg/cities/delivery/grpc/gen/cities.pb.go (0.0%)</option>
				
				<option value="file23">2024_2_ThereWillBeName/internal/pkg/cities/delivery/grpc/gen/cities_grpc.pb.go (0.0%)</option>
				
				<option value="file24">2024_2_ThereWillBeName/internal/pkg/cities/delivery/grpc/grpc_server.go (0.0%)</option>
				
				<option value="file25">2024_2_ThereWillBeName/internal/pkg/cities/delivery/http/handler.go (0.0%)</option>
				
				<option value="file26">2024_2_ThereWillBeName/internal/pkg/cities/repo/cities_repository.go (0.0%)</option>
				
				<option value="file27">2024_2_ThereWillBeName/internal/pkg/cities/usecase/cities_usecase.go (0.0%)</option>
				
				<option value="file28">2024_2_ThereWillBeName/internal/pkg/dblogger/dblogger.go (76.0%)</option>
				
				<option value="file29">2024_2_ThereWillBeName/internal/pkg/httpresponses/responses.go (57.1%)</option>
				
				<option value="file30">2024_2_ThereWillBeName/internal/pkg/jwt/jwt.go (0.0%)</option>
				
				<option value="file31">2024_2_ThereWillBeName/internal/pkg/jwt/mocks/mock_jwt.go (0.0%)</option>
				
				<option value="file32">2024_2_ThereWillBeName/internal/pkg/logger/logger.go (32.4%)</option>
				
				<option value="file33">2024_2_ThereWillBeName/internal/pkg/metrics/prometheus.go (0.0%)</option>
				
				<option value="file34">2024_2_ThereWillBeName/internal/pkg/middleware/cors.go (0.0%)</option>
				
				<option value="file35">2024_2_ThereWillBeName/internal/pkg/middleware/interceptor.go (0.0%)</option>
				
				<option value="file36">2024_2_ThereWillBeName/internal/pkg/middleware/logger.go (0.0%)</option>
				
				<option value="file37">2024_2_ThereWillBeName/internal/pkg/middleware/middleware.go (0.0%)</option>
				
				<option value="file38">2024_2_ThereWillBeName/internal/pkg/reviews/delivery/grpc/gen/reviews.pb.go (0.0%)</option>
				
				<option value="file39">2024_2_ThereWillBeName/internal/pkg/reviews/delivery/grpc/gen/reviews_grpc.pb.go (0.0%)</option>
				
				<option value="file40">2024_2_ThereWillBeName/internal/pkg/reviews/delivery/grpc/grpc_server.go (0.0%)</option>
				
				<option value="file41">2024_2_ThereWillBeName/internal/pkg/reviews/delivery/http/handler.go (0.0%)</option>
				
				<option value="file42">2024_2_ThereWillBeName/internal/pkg/reviews/repo/reviews_repository.go (73.9%)</option>
				
				<option value="file43">2024_2_ThereWillBeName/internal/pkg/reviews/usecase/reviews_usecase.go (100.0%)</option>
				
				<option value="file44">2024_2_ThereWillBeName/internal/pkg/search/delivery/grpc/gen/search.pb.go (0.0%)</option>
				
				<option value="file45">2024_2_ThereWillBeName/internal/pkg/search/delivery/grpc/gen/search_grpc.pb.go (0.0%)</option>
				
				<option value="file46">2024_2_ThereWillBeName/internal/pkg/search/delivery/grpc/grpc.go (0.0%)</option>
				
				<option value="file47">2024_2_ThereWillBeName/internal/pkg/search/delivery/http/handler.go (0.0%)</option>
				
				<option value="file48">2024_2_ThereWillBeName/internal/pkg/search/mocks/mock_search.go (0.0%)</option>
				
				<option value="file49">2024_2_ThereWillBeName/internal/pkg/search/repo/search_repository.go (93.3%)</option>
				
				<option value="file50">2024_2_ThereWillBeName/internal/pkg/search/usecase/search_usecase.go (0.0%)</option>
				
				<option value="file51">2024_2_ThereWillBeName/internal/pkg/survey/delivery/grpc/gen/survey.pb.go (0.0%)</option>
				
				<option value="file52">2024_2_ThereWillBeName/internal/pkg/survey/delivery/grpc/gen/survey_grpc.pb.go (0.0%)</option>
				
				<option value="file53">2024_2_ThereWillBeName/internal/pkg/survey/delivery/grpc/grpc_server.go (0.0%)</option>
				
				<option value="file54">2024_2_ThereWillBeName/internal/pkg/survey/delivery/http/handler.go (0.0%)</option>
				
				<option value="file55">2024_2_ThereWillBeName/internal/pkg/survey/repo/survey_repository.go (0.0%)</option>
				
				<option value="file56">2024_2_ThereWillBeName/internal/pkg/survey/usecase/survey_usecase.go (0.0%)</option>
				
				<option value="file57">2024_2_ThereWillBeName/internal/pkg/trips/delivery/grpc/gen/trips.pb.go (2.9%)</option>
				
				<option value="file58">2024_2_ThereWillBeName/internal/pkg/trips/delivery/grpc/gen/trips_grpc.pb.go (0.0%)</option>
				
				<option value="file59">2024_2_ThereWillBeName/internal/pkg/trips/delivery/grpc/grpc.go (72.4%)</option>
				
				<option value="file60">2024_2_ThereWillBeName/internal/pkg/trips/delivery/http/handler.go (86.9%)</option>
				
				<option value="file61">2024_2_ThereWillBeName/internal/pkg/trips/mocks/mock_grpc_trips.go (51.2%)</option>
				
				<option value="file62">2024_2_ThereWillBeName/internal/pkg/trips/mocks/mock_trips.go (94.4%)</option>
				
				<option value="file63">2024_2_ThereWillBeName/internal/pkg/trips/repo/trips_repository.go (71.1%)</option>
				
				<option value="file64">2024_2_ThereWillBeName/internal/pkg/trips/usecase/trips_usecase.go (100.0%)</option>
				
				<option value="file65">2024_2_ThereWillBeName/internal/pkg/user/delivery/grpc/gen/user.pb.go (3.4%)</option>
				
				<option value="file66">2024_2_ThereWillBeName/internal/pkg/user/delivery/grpc/gen/user_grpc.pb.go (0.0%)</option>
				
				<option value="file67">2024_2_ThereWillBeName/internal/pkg/user/delivery/grpc/grpc_server.go (0.0%)</option>
				
				<option value="file68">2024_2_ThereWillBeName/internal/pkg/user/delivery/http/handler.go (0.0%)</option>
				
				<option value="file69">2024_2_ThereWillBeName/internal/pkg/user/repo/user_repository.go (94.7%)</option>
				
				<option value="file70">2024_2_ThereWillBeName/internal/pkg/user/usecase/user_usecase.go (24.1%)</option>
				
				<option value="file71">2024_2_ThereWillBeName/internal/validator/validator.go (42.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "2024_2_ThereWillBeName/internal/models"
        grpcAttractions "2024_2_ThereWillBeName/internal/pkg/attractions/delivery/grpc"
        genPlaces "2024_2_ThereWillBeName/internal/pkg/attractions/delivery/grpc/gen"
        placeRepo "2024_2_ThereWillBeName/internal/pkg/attractions/repo"
        placeUsecase "2024_2_ThereWillBeName/internal/pkg/attractions/usecase"
        grpcCategories "2024_2_ThereWillBeName/internal/pkg/categories/delivery/grpc"
        genCategories "2024_2_ThereWillBeName/internal/pkg/categories/delivery/grpc/gen"
        categoriesRepo "2024_2_ThereWillBeName/internal/pkg/categories/repo"
        categoriesUsecase "2024_2_ThereWillBeName/internal/pkg/categories/usecase"
        grpcCities "2024_2_ThereWillBeName/internal/pkg/cities/delivery/grpc"
        genCities "2024_2_ThereWillBeName/internal/pkg/cities/delivery/grpc/gen"
        citiesRepo "2024_2_ThereWillBeName/internal/pkg/cities/repo"
        citiesUsecase "2024_2_ThereWillBeName/internal/pkg/cities/usecase"
        "2024_2_ThereWillBeName/internal/pkg/dblogger"
        "2024_2_ThereWillBeName/internal/pkg/logger"
        grpcReviews "2024_2_ThereWillBeName/internal/pkg/reviews/delivery/grpc"
        genReviews "2024_2_ThereWillBeName/internal/pkg/reviews/delivery/grpc/gen"
        reviewRepo "2024_2_ThereWillBeName/internal/pkg/reviews/repo"
        reviewUsecase "2024_2_ThereWillBeName/internal/pkg/reviews/usecase"
        grpcSearch "2024_2_ThereWillBeName/internal/pkg/search/delivery/grpc"
        genSearch "2024_2_ThereWillBeName/internal/pkg/search/delivery/grpc/gen"
        searchRepo "2024_2_ThereWillBeName/internal/pkg/search/repo"
        searchUsecase "2024_2_ThereWillBeName/internal/pkg/search/usecase"
        "database/sql"
        "flag"
        "log"
        "log/slog"
        "net"
        "os"
        "os/signal"
        "strconv"
        "syscall"

        _ "github.com/lib/pq"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
)

func main() <span class="cov0" title="0">{
        var cfg models.ConfigGrpc
        flag.IntVar(&amp;cfg.Port, "grpc-port", 50051, "gRPC server port")
        flag.StringVar(&amp;cfg.ConnStr, "connStr", "host=tripdb port=5432 user=service password=test dbname=trip sslmode=disable", "PostgreSQL connection string")
        flag.Parse()

        logger := setupLogger()

        db, err := sql.Open("postgres", cfg.ConnStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        wrappedDB := dblogger.NewDB(db, logger)

        reviewsRepo := reviewRepo.NewReviewRepository(wrappedDB)
        reviewUsecase := reviewUsecase.NewReviewsUsecase(reviewsRepo)
        placeRepo := placeRepo.NewPLaceRepository(wrappedDB)
        placeUsecase := placeUsecase.NewPlaceUsecase(placeRepo)
        citiesRepo := citiesRepo.NewCitiesRepository(wrappedDB)
        citiesUsecase := citiesUsecase.NewCitiesUsecase(citiesRepo)
        categoriesRepo := categoriesRepo.NewCategoriesRepo(wrappedDB)
        categoriesUsecase := categoriesUsecase.NewCategoriesUsecase(categoriesRepo)
        searchRepo := searchRepo.NewSearchRepository(wrappedDB)
        searchUsecase := searchUsecase.NewSearchUsecase(searchRepo)

        grpcAttractionsServer := grpc.NewServer()

        attractionsHandler := grpcAttractions.NewGrpcAttractionsHandler(placeUsecase)
        genPlaces.RegisterAttractionsServer(grpcAttractionsServer, attractionsHandler)

        citiesHandler := grpcCities.NewGrpcCitiesHandler(citiesUsecase)
        genCities.RegisterCitiesServer(grpcAttractionsServer, citiesHandler)

        reviewsHandler := grpcReviews.NewGrpcReviewsHandler(reviewUsecase)
        genReviews.RegisterReviewsServer(grpcAttractionsServer, reviewsHandler)

        categoriesHandler := grpcCategories.NewGrpcCategoriesHandler(categoriesUsecase)
        genCategories.RegisterCategoriesServer(grpcAttractionsServer, categoriesHandler)

        searchHandler := grpcSearch.NewGrpcSearchHandler(searchUsecase, logger)
        genSearch.RegisterSearchServer(grpcAttractionsServer, searchHandler)

        reflection.Register(grpcAttractionsServer)

        go func() </span><span class="cov0" title="0">{
                listener, err := net.Listen("tcp", ":8081")
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to listen: %v", err)
                }</span>
                <span class="cov0" title="0">log.Printf("gRPC server listening on :%d", cfg.Port)
                if err := grpcAttractionsServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to serve gRPC: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
        &lt;-stop

        log.Println("Shutting down gRPC server...")
        grpcAttractionsServer.GracefulStop()
        log.Println("gRPC server gracefully stopped")</span>
}

func setupLogger() *slog.Logger <span class="cov0" title="0">{

        levelEnv := os.Getenv("LOG_LEVEL")
        logLevel := slog.LevelDebug
        if level, err := strconv.Atoi(levelEnv); err == nil </span><span class="cov0" title="0">{
                logLevel = slog.Level(level)
        }</span>

        <span class="cov0" title="0">opts := logger.PrettyHandlerOptions{
                SlogOpts: slog.HandlerOptions{
                        Level: logLevel,
                },
        }

        handler := logger.NewPrettyHandler(os.Stdout, opts)

        return slog.New(handler)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "2024_2_ThereWillBeName/internal/models"
        genAttractions "2024_2_ThereWillBeName/internal/pkg/attractions/delivery/grpc/gen"
        httpPlaces "2024_2_ThereWillBeName/internal/pkg/attractions/delivery/http"
        genCategories "2024_2_ThereWillBeName/internal/pkg/categories/delivery/grpc/gen"
        httpCategories "2024_2_ThereWillBeName/internal/pkg/categories/delivery/http"
        genCities "2024_2_ThereWillBeName/internal/pkg/cities/delivery/grpc/gen"
        httpCities "2024_2_ThereWillBeName/internal/pkg/cities/delivery/http"
        "2024_2_ThereWillBeName/internal/pkg/httpresponses"
        httpresponse "2024_2_ThereWillBeName/internal/pkg/httpresponses"
        "2024_2_ThereWillBeName/internal/pkg/jwt"
        "2024_2_ThereWillBeName/internal/pkg/logger"
        "2024_2_ThereWillBeName/internal/pkg/middleware"
        genReviews "2024_2_ThereWillBeName/internal/pkg/reviews/delivery/grpc/gen"
        httpReviews "2024_2_ThereWillBeName/internal/pkg/reviews/delivery/http"
        genSearch "2024_2_ThereWillBeName/internal/pkg/search/delivery/grpc/gen"
        httpSearch "2024_2_ThereWillBeName/internal/pkg/search/delivery/http"
        genSurvey "2024_2_ThereWillBeName/internal/pkg/survey/delivery/grpc/gen"
        httpSurvey "2024_2_ThereWillBeName/internal/pkg/survey/delivery/http"
        genTrips "2024_2_ThereWillBeName/internal/pkg/trips/delivery/grpc/gen"
        httpTrips "2024_2_ThereWillBeName/internal/pkg/trips/delivery/http"
        genUsers "2024_2_ThereWillBeName/internal/pkg/user/delivery/grpc/gen"
        httpUsers "2024_2_ThereWillBeName/internal/pkg/user/delivery/http"
        "context"
        "errors"
        "flag"
        "fmt"
        "log"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "strconv"
        "syscall"

        _ "github.com/lib/pq"

        "github.com/gorilla/mux"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

func main() <span class="cov0" title="0">{
        var cfg models.Config
        flag.IntVar(&amp;cfg.Port, "port", 8080, "API server port")
        flag.StringVar(&amp;cfg.Env, "env", "production", "Environment")
        flag.StringVar(&amp;cfg.AllowedOrigin, "allowed-origin", "*", "Allowed origin")
        flag.Parse()

        logger := setupLogger()

        jwtSecret := os.Getenv("JWT_SECRET")
        jwtHandler := jwt.NewJWT(jwtSecret, logger)

        attractionsConn, err := grpc.Dial("attractions:8081", grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("did not connect to attractions service: %v", err)
        }</span>
        <span class="cov0" title="0">defer attractionsConn.Close()

        attractionsClient := genAttractions.NewAttractionsClient(attractionsConn)
        categoriesClient := genCategories.NewCategoriesClient(attractionsConn)
        citiesClient := genCities.NewCitiesClient(attractionsConn)
        reviewsClient := genReviews.NewReviewsClient(attractionsConn)
        searchClient := genSearch.NewSearchClient(attractionsConn)

        usersConn, err := grpc.NewClient("users:50052", grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("did not connect to users service: %v", err)
        }</span>
        <span class="cov0" title="0">defer usersConn.Close()
        usersClient := genUsers.NewUserServiceClient(usersConn)

        tripsConn, err := grpc.NewClient("trips:50053", grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("did not connect to trips service: %v", err)
        }</span>
        <span class="cov0" title="0">defer tripsConn.Close()
        tripsClient := genTrips.NewTripsClient(tripsConn)

        surveyConn, err := grpc.NewClient("survey:50054", grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("did not connect to survey service: %v", err)
        }</span>
        <span class="cov0" title="0">defer surveyConn.Close()
        surveyClient := genSurvey.NewSurveyServiceClient(surveyConn)

        // Инициализация HTTP сервера
        corsMiddleware := middleware.NewCORSMiddleware([]string{cfg.AllowedOrigin})
        r := mux.NewRouter().PathPrefix("/api/v1").Subrouter()
        r.Use(corsMiddleware.CorsMiddleware)

        r.Use(middleware.RequestLoggerMiddleware(logger))

        // Обработка ненайденных маршрутов
        r.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                response := httpresponses.ErrorResponse{
                        Message: "Not found",
                }
                httpresponses.SendJSONResponse(w, response, http.StatusNotFound, logger)
        }</span>)

        // Маршрут для healthcheck
        <span class="cov0" title="0">r.HandleFunc("/healthcheck", healthcheckHandler).Methods(http.MethodGet)

        // Маршруты для attractions
        placesHandler := httpPlaces.NewPlacesHandler(attractionsClient, logger)
        places := r.PathPrefix("/places").Subrouter()
        places.HandleFunc("", placesHandler.GetPlacesHandler).Methods(http.MethodGet)
        places.HandleFunc("/search", placesHandler.SearchPlacesHandler).Methods(http.MethodGet)
        places.HandleFunc("/{id}", placesHandler.GetPlaceHandler).Methods(http.MethodGet)
        places.HandleFunc("/category/{categoryName}", placesHandler.GetPlacesByCategoryHandler).Methods(http.MethodGet)

        categoriesHandler := httpCategories.NewCategoriesHandler(categoriesClient, logger)
        categories := r.PathPrefix("/categories").Subrouter()
        categories.HandleFunc("", categoriesHandler.GetCategoriesHandler).Methods(http.MethodGet)

        reviewsHandler := httpReviews.NewReviewHandler(reviewsClient, logger)
        reviews := places.PathPrefix("/{placeID}/reviews").Subrouter()
        reviews.Handle("", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(reviewsHandler.CreateReviewHandler), logger)).Methods(http.MethodPost)
        reviews.Handle("/{reviewID}", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(reviewsHandler.UpdateReviewHandler), logger)).Methods(http.MethodPut)
        reviews.Handle("/{reviewID}", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(reviewsHandler.DeleteReviewHandler), logger)).Methods(http.MethodDelete)
        reviews.HandleFunc("/{reviewID}", reviewsHandler.GetReviewHandler).Methods(http.MethodGet)
        reviews.HandleFunc("", reviewsHandler.GetReviewsByPlaceIDHandler).Methods(http.MethodGet)

        citiesHandler := httpCities.NewCitiesHandler(citiesClient, logger)
        cities := r.PathPrefix("/cities").Subrouter()
        cities.HandleFunc("/search", citiesHandler.SearchCitiesByNameHandler).Methods(http.MethodGet)
        cities.HandleFunc("/{id}", citiesHandler.SearchCityByIDHandler).Methods(http.MethodGet)

        searchHandler := httpSearch.NewSearchHandler(searchClient, logger)
        search := r.PathPrefix("/search").Subrouter()
        search.HandleFunc("", searchHandler.Search).Methods(http.MethodGet)

        //Маршруты для Users
        usersHandler := httpUsers.NewUserHandler(usersClient, jwtHandler, logger)
        auth := r.PathPrefix("/auth").Subrouter()
        auth.HandleFunc("/signup", usersHandler.SignUp).Methods(http.MethodPost)
        auth.HandleFunc("/login", usersHandler.Login).Methods(http.MethodPost)
        auth.Handle("/logout", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(usersHandler.Logout), logger)).Methods(http.MethodPost)

        users := r.PathPrefix("/users").Subrouter()
        users.Handle("/me", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(usersHandler.CurrentUser), logger)).Methods(http.MethodGet)

        user := users.PathPrefix("/{userID}").Subrouter()

        user.Handle("/avatars", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(usersHandler.UploadAvatar), logger)).Methods(http.MethodPut)
        user.Handle("/profile", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(usersHandler.GetProfile), logger)).Methods(http.MethodGet)
        user.Handle("/update/password", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(usersHandler.UpdatePassword), logger)).Methods(http.MethodPut)
        user.Handle("/profile", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(usersHandler.UpdateProfile), logger)).Methods(http.MethodPut)

        tripsHandler := httpTrips.NewTripHandler(tripsClient, logger)
        trips := r.PathPrefix("/trips").Subrouter()
        trips.Handle("/{id}", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(tripsHandler.GetTripHandler), logger)).Methods(http.MethodGet)
        trips.Handle("", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(tripsHandler.CreateTripHandler), logger)).Methods(http.MethodPost)
        trips.Handle("/{id}", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(tripsHandler.UpdateTripHandler), logger)).Methods(http.MethodPut)
        trips.Handle("/{id}", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(tripsHandler.DeleteTripHandler), logger)).Methods(http.MethodDelete)
        trips.Handle("/{id}", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(tripsHandler.AddPlaceToTripHandler), logger)).Methods(http.MethodPost)
        user.Handle("/trips", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(tripsHandler.GetTripsByUserIDHandler), logger)).Methods(http.MethodGet)
        trips.Handle("/{id}/photos", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(tripsHandler.AddPhotosToTripHandler), logger)).Methods(http.MethodPut)
        trips.Handle("/{id}/photos", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(tripsHandler.DeletePhotoHandler), logger)).Methods(http.MethodDelete)

        surveyHandler := httpSurvey.NewSurveyHandler(surveyClient, logger)
        survey := r.PathPrefix("/survey").Subrouter()
        survey.Handle("/stats/{id}", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(surveyHandler.GetSurveyStatsBySurveyId), logger)).Methods(http.MethodGet)
        survey.Handle("/{id}", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(surveyHandler.GetSurveyById), logger)).Methods(http.MethodGet)
        survey.Handle("/{id}", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(surveyHandler.CreateSurveyResponse), logger)).Methods(http.MethodPost)
        survey.Handle("/users/{id}", middleware.MiddlewareAuth(jwtHandler, http.HandlerFunc(surveyHandler.GetSurveyStatsByUserId), logger)).Methods(http.MethodGet)

        httpSrv := &amp;http.Server{Handler: r, Addr: fmt.Sprintf(":%d", cfg.Port)}
        go func() </span><span class="cov0" title="0">{
                logger.Info("HTTP server listening on :%d", cfg.Port)
                if err := httpSrv.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        logger.Error("failed to serve HTTP: %d", err)
                        os.Exit(1)
                }</span>
        }()

        <span class="cov0" title="0">stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
        &lt;-stop

        logger.Info("Shutting down HTTP server...")
        if err := httpSrv.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                logger.Error("HTTP server shutdown failed: %v", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Info("HTTP server gracefully stopped")</span>
}

func healthcheckHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logger := setupLogger()

        _, err := fmt.Fprintf(w, "STATUS: OK")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to write healthcheck response", slog.Any("error", err))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid request",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, logger)
        }</span>
}

func setupLogger() *slog.Logger <span class="cov0" title="0">{

        levelEnv := os.Getenv("LOG_LEVEL")
        logLevel := slog.LevelDebug
        if level, err := strconv.Atoi(levelEnv); err == nil </span><span class="cov0" title="0">{
                logLevel = slog.Level(level)
        }</span>

        <span class="cov0" title="0">opts := logger.PrettyHandlerOptions{
                SlogOpts: slog.HandlerOptions{
                        Level: logLevel,
                },
        }

        handler := logger.NewPrettyHandler(os.Stdout, opts)

        return slog.New(handler)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/logger"
        grpcSurvey "2024_2_ThereWillBeName/internal/pkg/survey/delivery/grpc"
        "2024_2_ThereWillBeName/internal/pkg/survey/delivery/grpc/gen"
        surveyRepo "2024_2_ThereWillBeName/internal/pkg/survey/repo"
        surveyUsecase "2024_2_ThereWillBeName/internal/pkg/survey/usecase"
        "database/sql"
        "flag"
        "fmt"
        _ "github.com/lib/pq"
        "log"
        "log/slog"
        "net"
        "os"
        "os/signal"
        "strconv"
        "syscall"

        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
)

func main() <span class="cov0" title="0">{
        var cfg models.ConfigGrpc
        flag.IntVar(&amp;cfg.Port, "grpc-port", 50054, "gRPC server port")
        flag.StringVar(&amp;cfg.ConnStr, "connStr", "host=tripdb port=5432 user=service password=test dbname=trip sslmode=disable", "PostgreSQL connection string")
        flag.Parse()

        logger := setupLogger()

        db, err := sql.Open("postgres", cfg.ConnStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        surveyRepoImpl := surveyRepo.NewPLaceRepository(db)
        surveyUsecaseImpl := surveyUsecase.NewSurveysUsecase(surveyRepoImpl)

        grpcSurveyServer := grpc.NewServer()
        surveyHandler := grpcSurvey.NewGrpcSurveyHandler(surveyUsecaseImpl, logger)
        gen.RegisterSurveyServiceServer(grpcSurveyServer, surveyHandler)
        reflection.Register(grpcSurveyServer)

        go func() </span><span class="cov0" title="0">{
                listener, err := net.Listen("tcp", fmt.Sprintf(":%d", cfg.Port))
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to listen: %v", err)
                }</span>
                <span class="cov0" title="0">log.Printf("gRPC server listening on :%d", cfg.Port)
                if err := grpcSurveyServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to serve gRPC: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
        &lt;-stop

        log.Println("Shutting down gRPC server...")
        grpcSurveyServer.GracefulStop()
        log.Println("gRPC server gracefully stopped")</span>
}
func setupLogger() *slog.Logger <span class="cov0" title="0">{

        levelEnv := os.Getenv("LOG_LEVEL")
        logLevel := slog.LevelDebug
        if level, err := strconv.Atoi(levelEnv); err == nil </span><span class="cov0" title="0">{
                logLevel = slog.Level(level)
        }</span>

        <span class="cov0" title="0">opts := logger.PrettyHandlerOptions{
                SlogOpts: slog.HandlerOptions{
                        Level: logLevel,
                },
        }

        handler := logger.NewPrettyHandler(os.Stdout, opts)

        return slog.New(handler)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/dblogger"
        "2024_2_ThereWillBeName/internal/pkg/logger"
        grpcTrips "2024_2_ThereWillBeName/internal/pkg/trips/delivery/grpc"
        "2024_2_ThereWillBeName/internal/pkg/trips/delivery/grpc/gen"
        tripRepo "2024_2_ThereWillBeName/internal/pkg/trips/repo"
        tripUsecase "2024_2_ThereWillBeName/internal/pkg/trips/usecase"
        "database/sql"
        "flag"
        "fmt"
        "log"
        "log/slog"
        "net"
        "os"
        "os/signal"
        "strconv"
        "syscall"

        _ "github.com/lib/pq"

        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
)

func main() <span class="cov0" title="0">{
        var cfg models.ConfigGrpc
        flag.IntVar(&amp;cfg.Port, "grpc-port", 50053, "gRPC server port")
        flag.StringVar(&amp;cfg.ConnStr, "connStr", "host=tripdb port=5432 user=service password=test dbname=trip sslmode=disable", "PostgreSQL connection string")
        flag.Parse()

        logger := setupLogger()

        db, err := sql.Open("postgres", cfg.ConnStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        wrappedDB := dblogger.NewDB(db, logger)

        tripRepo := tripRepo.NewTripRepository(wrappedDB)
        tripUsecase := tripUsecase.NewTripsUsecase(tripRepo)

        grpcTripsServer := grpc.NewServer()
        tripsHandler := grpcTrips.NewGrpcTripHandler(tripUsecase, logger)
        gen.RegisterTripsServer(grpcTripsServer, tripsHandler)
        reflection.Register(grpcTripsServer)

        go func() </span><span class="cov0" title="0">{
                listener, err := net.Listen("tcp", fmt.Sprintf(":%d", cfg.Port))
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to listen: %v", err)
                }</span>
                <span class="cov0" title="0">log.Printf("gRPC server listening on :%d", cfg.Port)
                if err := grpcTripsServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to serve gRPC: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
        &lt;-stop

        log.Println("Shutting down gRPC server...")
        grpcTripsServer.GracefulStop()
        log.Println("gRPC server gracefully stopped")</span>
}
func setupLogger() *slog.Logger <span class="cov0" title="0">{

        levelEnv := os.Getenv("LOG_LEVEL")
        logLevel := slog.LevelDebug
        if level, err := strconv.Atoi(levelEnv); err == nil </span><span class="cov0" title="0">{
                logLevel = slog.Level(level)
        }</span>

        <span class="cov0" title="0">opts := logger.PrettyHandlerOptions{
                SlogOpts: slog.HandlerOptions{
                        Level: logLevel,
                },
        }

        handler := logger.NewPrettyHandler(os.Stdout, opts)

        return slog.New(handler)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/dblogger"
        "2024_2_ThereWillBeName/internal/pkg/logger"
        grpcUsers "2024_2_ThereWillBeName/internal/pkg/user/delivery/grpc"
        "2024_2_ThereWillBeName/internal/pkg/user/delivery/grpc/gen"
        userRepo "2024_2_ThereWillBeName/internal/pkg/user/repo"
        userUsecase "2024_2_ThereWillBeName/internal/pkg/user/usecase"
        "database/sql"
        "flag"
        "fmt"
        "log"
        "log/slog"
        "net"
        "os"
        "os/signal"
        "strconv"
        "syscall"

        _ "github.com/lib/pq"

        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
)

func main() <span class="cov0" title="0">{
        var cfg models.ConfigGrpc
        flag.IntVar(&amp;cfg.Port, "grpc-port", 50052, "gRPC server port")
        flag.StringVar(&amp;cfg.ConnStr, "connStr", "host=tripdb port=5432 user=service password=test dbname=trip sslmode=disable", "PostgreSQL connection string")
        flag.Parse()

        logger := setupLogger()

        storagePath := os.Getenv("AVATAR_STORAGE_PATH")

        db, err := sql.Open("postgres", cfg.ConnStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        wrappedDB := dblogger.NewDB(db, logger)

        userRepo := userRepo.NewAuthRepository(wrappedDB)
        userUsecase := userUsecase.NewUserUsecase(userRepo, storagePath)

        grpcUsersServer := grpc.NewServer()
        usersHandler := grpcUsers.NewGrpcUserHandler(userUsecase, logger)
        gen.RegisterUserServiceServer(grpcUsersServer, usersHandler)
        reflection.Register(grpcUsersServer)

        go func() </span><span class="cov0" title="0">{
                listener, err := net.Listen("tcp", fmt.Sprintf(":%d", cfg.Port))
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to listen: %v", err)
                }</span>
                <span class="cov0" title="0">log.Printf("gRPC server listening on :%d", cfg.Port)
                if err := grpcUsersServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to serve gRPC: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
        &lt;-stop

        log.Println("Shutting down gRPC server...")
        grpcUsersServer.GracefulStop()
        log.Println("gRPC server gracefully stopped")</span>
}

func setupLogger() *slog.Logger <span class="cov0" title="0">{

        levelEnv := os.Getenv("LOG_LEVEL")
        logLevel := slog.LevelDebug
        if level, err := strconv.Atoi(levelEnv); err == nil </span><span class="cov0" title="0">{
                logLevel = slog.Level(level)
        }</span>

        <span class="cov0" title="0">opts := logger.PrettyHandlerOptions{
                SlogOpts: slog.HandlerOptions{
                        Level: logLevel,
                },
        }

        handler := logger.NewPrettyHandler(os.Stdout, opts)

        return slog.New(handler)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/cities/search": {
            "get": {
                "description": "Get cities details by city name",
                "produces": [
                    "application/json"
                ],
                "summary": "Retrieve cities by name",
                "responses": {
                    "200": {
                        "description": "Cities details",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.City"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid query",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Invalid token",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Cities not found",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to retrieve cities",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/cities/{id}": {
            "get": {
                "description": "Get city details by city ID",
                "produces": [
                    "application/json"
                ],
                "summary": "Retrieve a city by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "City ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "City details",
                        "schema": {
                            "$ref": "#/definitions/models.City"
                        }
                    },
                    "400": {
                        "description": "Invalid city ID",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Invalid CSRF token",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "City not found",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to retrieve cities",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/healthcheck": {
            "get": {
                "description": "Check the health status of the service",
                "produces": [
                    "text/plain"
                ],
                "summary": "Health check",
                "responses": {
                    "200": {
                        "description": "STATUS: OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/login": {
            "post": {
                "description": "Authenticate a user and return a token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Login a user",
                "parameters": [
                    {
                        "description": "User credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.Credentials"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Token",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/logout": {
            "post": {
                "description": "Log out the user by clearing the authentication token",
                "produces": [
                    "application/json"
                ],
                "summary": "Logout a user",
                "responses": {
                    "200": {
                        "description": "Logged out successfully",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/attractions": {
            "get": {
                "description": "Retrieve a list of attractions from the database",
                "produces": [
                    "application/json"
                ],
                "summary": "Get a list of attractions",
                "responses": {
                    "200": {
                        "description": "List of attractions",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.GetPlace"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Add a new place to the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Create a new place",
                "parameters": [
                    {
                        "description": "Place data",
                        "name": "place",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreatePlace"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Place successfully created",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Invalid token",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/attractions/search/{placeName}": {
            "get": {
                "description": "Get a list of attractions from the database that match the provided search string",
                "produces": [
                    "application/json"
                ],
                "summary": "Retrieve attractions by search string",
                "parameters": [
                    {
                        "description": "Name of the attractions to retrieve",
                        "name": "searchString",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of attractions matching the provided searchString",
                        "schema": {
                            "$ref": "#/definitions/models.GetPlace"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/attractions/{id}": {
            "get": {
                "description": "Get details of a place from the database by its id",
                "produces": [
                    "application/json"
                ],
                "summary": "Retrieve an existing place",
                "parameters": [
                    {
                        "description": "ID of the place to retrieve",
                        "name": "id",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "integer"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Details of the requested place",
                        "schema": {
                            "$ref": "#/definitions/models.GetPlace"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Update the details of an existing place in the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Update an existing place",
                "parameters": [
                    {
                        "description": "Updated place data",
                        "name": "place",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UpdatePlace"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Place successfully updated",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Invalid token",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Remove a place from the database by its name",
                "produces": [
                    "application/json"
                ],
                "summary": "Delete an existing place",
                "parameters": [
                    {
                        "description": "Name of the place to be deleted",
                        "name": "name",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Place successfully deleted",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Invalid token",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/attractions/{placeID}/reviews": {
            "get": {
                "description": "Get all reviews for a specific place",
                "produces": [
                    "application/json"
                ],
                "summary": "Retrieve reviews by place ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Place ID",
                        "name": "placeID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of reviews",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.Review"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid place ID",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "No reviews found for the place",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to retrieve reviews",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/reviews": {
            "post": {
                "description": "Create a new review for a place",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Create a new review",
                "parameters": [
                    {
                        "description": "Review details",
                        "name": "review",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.Review"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Review created successfully",
                        "schema": {
                            "$ref": "#/definitions/models.Review"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Invalid token",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to create review",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/reviews/{id}": {
            "get": {
                "description": "Get review details by review ID",
                "produces": [
                    "application/json"
                ],
                "summary": "Retrieve a review by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Review ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Review details",
                        "schema": {
                            "$ref": "#/definitions/models.GetReview"
                        }
                    },
                    "400": {
                        "description": "Invalid review ID",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Review not found",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to retrieve review",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Update review details by review ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Update an existing review",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Review ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated review details",
                        "name": "review",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.Review"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Review updated successfully",
                        "schema": {
                            "$ref": "#/definitions/models.Review"
                        }
                    },
                    "400": {
                        "description": "Invalid review ID",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Invalid token",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Review not found",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to update review",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a review by review ID",
                "produces": [
                    "application/json"
                ],
                "summary": "Delete a review",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Review ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Review deleted successfully"
                    },
                    "400": {
                        "description": "Invalid review ID",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Invalid token",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Review not found",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to delete review",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/signup": {
            "post": {
                "description": "Create a new user with login and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Sign up a new user",
                "parameters": [
                    {
                        "description": "User credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.Credentials"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User created successfully",
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/trips": {
            "post": {
                "description": "Create a new trip with given fields",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Create a new trip",
                "parameters": [
                    {
                        "description": "Trip details",
                        "name": "tripData",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.TripData"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Trip created successfully",
                        "schema": {
                            "$ref": "#/definitions/models.Trip"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Invalid token",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Invalid request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to create trip",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/trips/{id}": {
            "get": {
                "description": "Get trip details by trip ID",
                "produces": [
                    "application/json"
                ],
                "summary": "Retrieve a trip by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Trip ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Trip details",
                        "schema": {
                            "$ref": "#/definitions/models.Trip"
                        }
                    },
                    "400": {
                        "description": "Invalid trip ID",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Trip not found",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to retrieve trip",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Update trip details by trip ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Update an existing trip",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Trip ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated trip details",
                        "name": "tripData",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/http.TripData"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Trip updated successfully",
                        "schema": {
                            "$ref": "#/definitions/models.Trip"
                        }
                    },
                    "400": {
                        "description": "Invalid trip data",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Invalid token",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Trip not found",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to update trip",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Add a place with given place_id to a trip",
                "produces": [
                    "application/json"
                ],
                "summary": "Add a place to a trip",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Trip ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Place ID",
                        "name": "place_id",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "integer"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Place added to trip successfully"
                    },
                    "400": {
                        "description": "Invalid place ID",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Place not found",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to add place to trip",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a trip by trip ID",
                "produces": [
                    "application/json"
                ],
                "summary": "Delete a trip",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Trip ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Trip deleted successfully"
                    },
                    "400": {
                        "description": "Invalid trip ID",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Invalid token",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Trip not found",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to delete trip",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/me": {
            "get": {
                "description": "Retrieve the current authenticated user information",
                "produces": [
                    "application/json"
                ],
                "summary": "Get the current user",
                "responses": {
                    "200": {
                        "description": "Current user",
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/{userID}/avatar": {
            "put": {
                "description": "Upload an avatar image for the user",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Upload user avatar",
                "parameters": [
                    {
                        "type": "file",
                        "description": "Avatar file",
                        "name": "avatar",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Avatar uploaded successfully",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/{userID}/profile": {
            "get": {
                "description": "Retrieve the user profile information",
                "produces": [
                    "application/json"
                ],
                "summary": "Get user profile",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "userID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "User profile",
                        "schema": {
                            "$ref": "#/definitions/models.UserProfile"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/{userID}/reviews": {
            "get": {
                "description": "Get all reviews for an user",
                "produces": [
                    "application/json"
                ],
                "summary": "Retrieve reviews by user ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "userID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of reviews",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.GetReviewByUserID"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid user ID",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "No reviews found for the user",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to retrieve reviews",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/{userID}/trips": {
            "get": {
                "description": "Get all trips for a specific user",
                "produces": [
                    "application/json"
                ],
                "summary": "Retrieve trips by user ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "userID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of trips",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.Trip"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid user ID",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Invalid token",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Trips not found",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to retrieve trips",
                        "schema": {
                            "$ref": "#/definitions/httpresponses.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "http.Credentials": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "login": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "http.TripData": {
            "type": "object",
            "properties": {
                "city_id": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "end_date": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "private_trip": {
                    "type": "boolean"
                },
                "start_date": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "httpresponses.ErrorResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "models.City": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "models.CreatePlace": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "categoriesId": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "cityId": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "imagePath": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "numberOfReviews": {
                    "type": "integer"
                },
                "phoneNumber": {
                    "type": "string"
                },
                "rating": {
                    "type": "integer"
                }
            }
        },
        "models.GetPlace": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "categories": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "city": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "imagePath": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "numberOfReviews": {
                    "type": "integer"
                },
                "phoneNumber": {
                    "type": "string"
                },
                "rating": {
                    "type": "integer"
                }
            }
        },
        "models.GetReview": {
            "type": "object",
            "properties": {
                "avatar_path": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "rating": {
                    "type": "integer"
                },
                "review_text": {
                    "type": "string"
                },
                "user_login": {
                    "type": "string"
                }
            }
        },
        "models.GetReviewByUserID": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "place_name": {
                    "type": "string"
                },
                "rating": {
                    "type": "integer"
                },
                "review_text": {
                    "type": "string"
                }
            }
        },
        "models.Review": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "place_id": {
                    "type": "integer"
                },
                "rating": {
                    "type": "integer"
                },
                "review_text": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "models.Trip": {
            "type": "object",
            "properties": {
                "city_id": {
                    "type": "integer"
                },
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "end_date": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "private_trip": {
                    "type": "boolean"
                },
                "start_date": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "models.UpdatePlace": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "categoriesId": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "cityId": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "imagePath": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "numberOfReviews": {
                    "type": "integer"
                },
                "phoneNumber": {
                    "type": "string"
                },
                "rating": {
                    "type": "integer"
                }
            }
        },
        "models.User": {
            "type": "object",
            "properties": {
                "avatar_path": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "login": {
                    "type": "string"
                }
            }
        },
        "models.UserProfile": {
            "type": "object",
            "properties": {
                "avatar_path": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "login": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "",
        Description:      "",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

import "2024_2_ThereWillBeName/internal/validator"

type CreatePlace struct {
        Name            string  `json:"name"`
        ImagePath       string  `json:"imagePath"`
        Description     string  `json:"description"`
        Rating          int     `json:"rating"`
        NumberOfReviews int     `json:"numberOfReviews"`
        Address         string  `json:"address"`
        CityId          int     `json:"cityId"`
        PhoneNumber     string  `json:"phoneNumber"`
        CategoriesId    []int   `json:"categoriesId"`
        Latitude        float64 `json:"latitude"`
        Longitude       float64 `json:"longitude"`
}

type GetPlace struct {
        ID              int      `json:"id"`
        Name            string   `json:"name"`
        ImagePath       string   `json:"imagePath"`
        Description     string   `json:"description"`
        Rating          int      `json:"rating"`
        NumberOfReviews int      `json:"numberOfReviews"`
        Address         string   `json:"address"`
        City            string   `json:"city"`
        PhoneNumber     string   `json:"phoneNumber"`
        Categories      []string `json:"categories"`
        Latitude        float64  `json:"latitude"`
        Longitude       float64  `json:"longitude"`
}

type UpdatePlace struct {
        ID              int     `json:"id"`
        Name            string  `json:"name"`
        ImagePath       string  `json:"imagePath"`
        Description     string  `json:"description"`
        Rating          int     `json:"rating"`
        NumberOfReviews int     `json:"numberOfReviews"`
        Address         string  `json:"address"`
        CityId          int     `json:"cityId"`
        PhoneNumber     string  `json:"phoneNumber"`
        CategoriesId    []int   `json:"categoriesId"`
        Latitude        float64 `json:"latitude"`
        Longitude       float64 `json:"longitude"`
}

func ValidateCreatePlace(v *validator.Validator, place *CreatePlace) <span class="cov0" title="0">{
        v.Check(place.Name != "", "name", "must be provided")
        v.Check(len(place.Name) &lt;= 255, "name", "must not be more than 255 symbols")
        v.Check(place.Description != "", "descriprion", "must be provided")
        v.Check(len(place.Description) &lt;= 255, "description", "must not be more than 255 symbols")
        v.Check(place.ImagePath != "", "image path", "must be provided")
        v.Check(len(place.ImagePath) &lt;= 255, "image path", "must not be more than 255 symbols")
        v.Check(place.Address != "", "address", "must be provided")
        v.Check(len(place.Address) &lt;= 255, "address", "must not be more than 255 symbols")
        v.Check(place.CityId != 0, "city id", "must be provided")
}</span>

func ValidateUpdatePlace(v *validator.Validator, place *UpdatePlace) <span class="cov0" title="0">{
        v.Check(place.Name != "", "name", "must be provided")
        v.Check(len(place.Name) &lt;= 255, "name", "must not be more than 255 symbols")
        v.Check(place.Description != "", "descriprion", "must be provided")
        v.Check(len(place.Description) &lt;= 255, "description", "must not be more than 255 symbols")
        v.Check(place.ImagePath != "", "image path", "must be provided")
        v.Check(len(place.ImagePath) &lt;= 255, "image path", "must not be more than 255 symbols")
        v.Check(place.Address != "", "address", "must be provided")
        v.Check(len(place.Address) &lt;= 255, "address", "must not be more than 255 symbols")
        v.Check(place.CityId != 0, "city id", "must be provided")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package models

import (
        "2024_2_ThereWillBeName/internal/validator"
        "time"
)

type Review struct {
        ID         uint      `json:"id"`
        UserID     uint      `json:"user_id"`
        PlaceID    uint      `json:"place_id"`
        Rating     int       `json:"rating"`
        ReviewText string    `json:"review_text"`
        CreatedAt  time.Time `json:"created_at"`
}

type GetReview struct {
        ID         uint   `json:"id"`
        UserLogin  string `json:"user_login"`
        AvatarPath string `json:"avatar_path"`
        Rating     int    `json:"rating"`
        ReviewText string `json:"review_text"`
}

type GetReviewByUserID struct {
        ID         uint   `json:"id"`
        PlaceName  string `json:"place_name"`
        Rating     int    `json:"rating"`
        ReviewText string `json:"review_text"`
}

func ValidateReview(v *validator.Validator, review *Review) <span class="cov0" title="0">{
        v.Check(review.ReviewText != "", "reviewText", "must be provided")
        v.Check(len(review.ReviewText) &lt;= 255, "reviewText", "must not be more than 255 symbols")
        v.Check(review.Rating != 0, "rating", "must be provided")
        v.Check(review.PlaceID != 0, "place id", "must be provided")
        v.Check(review.UserID != 0, "user id", "must be provided")
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "2024_2_ThereWillBeName/internal/validator"
        "time"
)

type Trip struct {
        ID          uint      `json:"id"`
        UserID      uint      `json:"user_id"`
        Name        string    `json:"name"`
        Description string    `json:"description"`
        CityID      uint      `json:"city_id"`
        StartDate   string    `json:"start_date"`
        EndDate     string    `json:"end_date"`
        Private     bool      `json:"private_trip"`
        Photos      []string  `json:"photos"`
        CreatedAt   time.Time `json:"created_at"`
}

func ValidateTrip(v *validator.Validator, trip *Trip) <span class="cov8" title="1">{
        v.Check(trip.Name != "", "name", "must be provided")
        v.Check(len(trip.Name) &lt;= 255, "name", "must not be more than 255 symbols")
        v.Check(trip.UserID != 0, "user id", "must be provided")
        v.Check(len(trip.Description) &lt;= 255, "description", "must not be more than 255 symbols")
        v.Check(trip.CityID != 0, "city id", "must be provided")

        startDate, _ := time.Parse("2006-01-02", trip.StartDate)
        endDate, _ := time.Parse("2006-01-02", trip.EndDate)

        now := time.Now()
        oneMonthAgo := now.AddDate(0, -1, 0)
        twoYearsAhead := now.AddDate(2, 0, 0)
        v.Check(startDate.Before(twoYearsAhead), "start date", "must not be too late")
        v.Check(startDate.After(oneMonthAgo), "start date", "must not be too early")
        v.Check(endDate.Before(twoYearsAhead), "end date", "must not be too late")
        v.Check(endDate.After(oneMonthAgo), "end date", "must not be too early")
        v.Check(endDate.After(startDate), "dates", "start must not be later than end")
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package models

import (
        "2024_2_ThereWillBeName/internal/validator"
        "time"
)

type User struct {
        ID         uint      `json:"id"`
        Login      string    `json:"login"`
        Email      string    `json:"email"`
        Password   string    `json:"-"`
        AvatarPath string    `json:"avatar_path,omitempty"`
        CreatedAt  time.Time `json:"created_at"`
}

type UserProfile struct {
        Login      string `json:"login"`
        AvatarPath string `json:"avatar_path,omitempty"`
        Email      string `json:"email,omitempty"`
}

func ValidateUser(v *validator.Validator, user *User) <span class="cov0" title="0">{
        // v.Check(user.Login != "", "login", "must be provided")
        v.Check(user.Password != "", "password", "must be provided")
        v.Check(user.Email != "", "email", "must be provided")
        v.Matches(user.Email, validator.EmailRX)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v4.25.1
// source: internal/pkg/attractions/delivery/grpc/proto/attractions.proto

package gen

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Place struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id          uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Name        string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        ImagePath   string   `protobuf:"bytes,3,opt,name=imagePath,proto3" json:"imagePath,omitempty"`
        Description string   `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
        Rating      int32    `protobuf:"varint,5,opt,name=rating,proto3" json:"rating,omitempty"`
        Address     string   `protobuf:"bytes,6,opt,name=address,proto3" json:"address,omitempty"`
        City        string   `protobuf:"bytes,7,opt,name=city,proto3" json:"city,omitempty"`
        PhoneNumber string   `protobuf:"bytes,8,opt,name=phoneNumber,proto3" json:"phoneNumber,omitempty"`
        Categories  []string `protobuf:"bytes,9,rep,name=categories,proto3" json:"categories,omitempty"`
        Latitude    float64  `protobuf:"fixed64,10,opt,name=latitude,proto3" json:"latitude,omitempty"`
        Longitude   float64  `protobuf:"fixed64,11,opt,name=longitude,proto3" json:"longitude,omitempty"`
}

func (x *Place) Reset() <span class="cov0" title="0">{
        *x = Place{}
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Place) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Place) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Place) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Place.ProtoReflect.Descriptor instead.
func (*Place) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Place) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Place) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Place) GetImagePath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ImagePath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Place) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Place) GetRating() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Place) GetAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Place) GetCity() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.City
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Place) GetPhoneNumber() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PhoneNumber
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Place) GetCategories() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Categories
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Place) GetLatitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Latitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Place) GetLongitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Longitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetPlacesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Limit  int32 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset int32 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *GetPlacesRequest) Reset() <span class="cov0" title="0">{
        *x = GetPlacesRequest{}
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPlacesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPlacesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPlacesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPlacesRequest.ProtoReflect.Descriptor instead.
func (*GetPlacesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetPlacesRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetPlacesRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetPlacesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Places []*Place `protobuf:"bytes,1,rep,name=places,proto3" json:"places,omitempty"`
}

func (x *GetPlacesResponse) Reset() <span class="cov0" title="0">{
        *x = GetPlacesResponse{}
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPlacesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPlacesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPlacesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPlacesResponse.ProtoReflect.Descriptor instead.
func (*GetPlacesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetPlacesResponse) GetPlaces() []*Place <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Places
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetPlaceRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *GetPlaceRequest) Reset() <span class="cov0" title="0">{
        *x = GetPlaceRequest{}
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPlaceRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPlaceRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPlaceRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPlaceRequest.ProtoReflect.Descriptor instead.
func (*GetPlaceRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetPlaceRequest) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetPlaceResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Place *Place `protobuf:"bytes,1,opt,name=place,proto3" json:"place,omitempty"`
}

func (x *GetPlaceResponse) Reset() <span class="cov0" title="0">{
        *x = GetPlaceResponse{}
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPlaceResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPlaceResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPlaceResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPlaceResponse.ProtoReflect.Descriptor instead.
func (*GetPlaceResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescGZIP(), []int{4}
}</span>

func (x *GetPlaceResponse) GetPlace() *Place <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Place
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SearchPlacesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name     string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Category int32  `protobuf:"varint,2,opt,name=category,proto3" json:"category,omitempty"`
        City     int32  `protobuf:"varint,3,opt,name=city,proto3" json:"city,omitempty"`
        Limit    int32  `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset   int32  `protobuf:"varint,5,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *SearchPlacesRequest) Reset() <span class="cov0" title="0">{
        *x = SearchPlacesRequest{}
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchPlacesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchPlacesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchPlacesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchPlacesRequest.ProtoReflect.Descriptor instead.
func (*SearchPlacesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescGZIP(), []int{5}
}</span>

func (x *SearchPlacesRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchPlacesRequest) GetCategory() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Category
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SearchPlacesRequest) GetCity() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.City
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SearchPlacesRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SearchPlacesRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type SearchPlacesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Places []*Place `protobuf:"bytes,1,rep,name=places,proto3" json:"places,omitempty"`
}

func (x *SearchPlacesResponse) Reset() <span class="cov0" title="0">{
        *x = SearchPlacesResponse{}
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchPlacesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchPlacesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchPlacesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchPlacesResponse.ProtoReflect.Descriptor instead.
func (*SearchPlacesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescGZIP(), []int{6}
}</span>

func (x *SearchPlacesResponse) GetPlaces() []*Place <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Places
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetPlacesByCategoryRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Category string `protobuf:"bytes,1,opt,name=category,proto3" json:"category,omitempty"`
        Limit    int32  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset   int32  `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *GetPlacesByCategoryRequest) Reset() <span class="cov0" title="0">{
        *x = GetPlacesByCategoryRequest{}
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPlacesByCategoryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPlacesByCategoryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPlacesByCategoryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPlacesByCategoryRequest.ProtoReflect.Descriptor instead.
func (*GetPlacesByCategoryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetPlacesByCategoryRequest) GetCategory() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Category
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetPlacesByCategoryRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetPlacesByCategoryRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetPlacesByCategoryResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Places []*Place `protobuf:"bytes,1,rep,name=places,proto3" json:"places,omitempty"`
}

func (x *GetPlacesByCategoryResponse) Reset() <span class="cov0" title="0">{
        *x = GetPlacesByCategoryResponse{}
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPlacesByCategoryResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPlacesByCategoryResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPlacesByCategoryResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPlacesByCategoryResponse.ProtoReflect.Descriptor instead.
func (*GetPlacesByCategoryResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescGZIP(), []int{8}
}</span>

func (x *GetPlacesByCategoryResponse) GetPlaces() []*Place <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Places
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_internal_pkg_attractions_delivery_grpc_proto_attractions_proto protoreflect.FileDescriptor

var file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDesc = []byte{
        0x0a, 0x3e, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x61,
        0x74, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x64, 0x65, 0x6c, 0x69, 0x76,
        0x65, 0x72, 0x79, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x61,
        0x74, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x12, 0x0b, 0x61, 0x74, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0xad, 0x02,
        0x0a, 0x05, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x69,
        0x6d, 0x61, 0x67, 0x65, 0x50, 0x61, 0x74, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
        0x69, 0x6d, 0x61, 0x67, 0x65, 0x50, 0x61, 0x74, 0x68, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73,
        0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,
        0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x72,
        0x61, 0x74, 0x69, 0x6e, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x72, 0x61, 0x74,
        0x69, 0x6e, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x06,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x12, 0x0a,
        0x04, 0x63, 0x69, 0x74, 0x79, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x69, 0x74,
        0x79, 0x12, 0x20, 0x0a, 0x0b, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72,
        0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d,
        0x62, 0x65, 0x72, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65,
        0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72,
        0x69, 0x65, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x18,
        0x0a, 0x20, 0x01, 0x28, 0x01, 0x52, 0x08, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x12,
        0x1c, 0x0a, 0x09, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x0b, 0x20, 0x01,
        0x28, 0x01, 0x52, 0x09, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x22, 0x40, 0x0a,
        0x10, 0x47, 0x65, 0x74, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05,
        0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65,
        0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22,
        0x3f, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2a, 0x0a, 0x06, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x18, 0x01,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x61, 0x74, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x52, 0x06, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73,
        0x22, 0x21, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52,
        0x02, 0x69, 0x64, 0x22, 0x3c, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x05, 0x70, 0x6c, 0x61, 0x63, 0x65,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x61, 0x74, 0x74, 0x72, 0x61, 0x63, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x52, 0x05, 0x70, 0x6c, 0x61, 0x63,
        0x65, 0x22, 0x87, 0x01, 0x0a, 0x13, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x50, 0x6c, 0x61, 0x63,
        0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a,
        0x08, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x08, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x69, 0x74,
        0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x63, 0x69, 0x74, 0x79, 0x12, 0x14, 0x0a,
        0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x6c, 0x69,
        0x6d, 0x69, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x05, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22, 0x42, 0x0a, 0x14, 0x53,
        0x65, 0x61, 0x72, 0x63, 0x68, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x2a, 0x0a, 0x06, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x61, 0x74, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x2e, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x52, 0x06, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x22,
        0x66, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x42, 0x79, 0x43, 0x61,
        0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a,
        0x08, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x08, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d,
        0x69, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x12,
        0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22, 0x49, 0x0a, 0x1b, 0x47, 0x65, 0x74, 0x50, 0x6c,
        0x61, 0x63, 0x65, 0x73, 0x42, 0x79, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2a, 0x0a, 0x06, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73,
        0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x61, 0x74, 0x74, 0x72, 0x61, 0x63, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x52, 0x06, 0x70, 0x6c, 0x61, 0x63,
        0x65, 0x73, 0x32, 0xe9, 0x02, 0x0a, 0x0b, 0x41, 0x74, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x12, 0x4c, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x12,
        0x1d, 0x2e, 0x61, 0x74, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x47, 0x65,
        0x74, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e,
        0x2e, 0x61, 0x74, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x47, 0x65, 0x74,
        0x50, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
        0x12, 0x49, 0x0a, 0x08, 0x47, 0x65, 0x74, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x12, 0x1c, 0x2e, 0x61,
        0x74, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x50, 0x6c,
        0x61, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x61, 0x74, 0x74,
        0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x50, 0x6c, 0x61, 0x63,
        0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x55, 0x0a, 0x0c, 0x53,
        0x65, 0x61, 0x72, 0x63, 0x68, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x12, 0x20, 0x2e, 0x61, 0x74,
        0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,
        0x50, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e,
        0x61, 0x74, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x61, 0x72,
        0x63, 0x68, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x22, 0x00, 0x12, 0x6a, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x42,
        0x79, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x12, 0x27, 0x2e, 0x61, 0x74, 0x74, 0x72,
        0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x50, 0x6c, 0x61, 0x63, 0x65,
        0x73, 0x42, 0x79, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x28, 0x2e, 0x61, 0x74, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x47, 0x65, 0x74, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x42, 0x79, 0x43, 0x61, 0x74, 0x65,
        0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x07,
        0x5a, 0x05, 0x2e, 0x3b, 0x67, 0x65, 0x6e, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescOnce sync.Once
        file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescData = file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDesc
)

func file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescData = protoimpl.X.CompressGZIP(file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDescData</span>
}

var file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_goTypes = []any{
        (*Place)(nil),                       // 0: attractions.Place
        (*GetPlacesRequest)(nil),            // 1: attractions.GetPlacesRequest
        (*GetPlacesResponse)(nil),           // 2: attractions.GetPlacesResponse
        (*GetPlaceRequest)(nil),             // 3: attractions.GetPlaceRequest
        (*GetPlaceResponse)(nil),            // 4: attractions.GetPlaceResponse
        (*SearchPlacesRequest)(nil),         // 5: attractions.SearchPlacesRequest
        (*SearchPlacesResponse)(nil),        // 6: attractions.SearchPlacesResponse
        (*GetPlacesByCategoryRequest)(nil),  // 7: attractions.GetPlacesByCategoryRequest
        (*GetPlacesByCategoryResponse)(nil), // 8: attractions.GetPlacesByCategoryResponse
}
var file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_depIdxs = []int32{
        0, // 0: attractions.GetPlacesResponse.places:type_name -&gt; attractions.Place
        0, // 1: attractions.GetPlaceResponse.place:type_name -&gt; attractions.Place
        0, // 2: attractions.SearchPlacesResponse.places:type_name -&gt; attractions.Place
        0, // 3: attractions.GetPlacesByCategoryResponse.places:type_name -&gt; attractions.Place
        1, // 4: attractions.Attractions.GetPlaces:input_type -&gt; attractions.GetPlacesRequest
        3, // 5: attractions.Attractions.GetPlace:input_type -&gt; attractions.GetPlaceRequest
        5, // 6: attractions.Attractions.SearchPlaces:input_type -&gt; attractions.SearchPlacesRequest
        7, // 7: attractions.Attractions.GetPlacesByCategory:input_type -&gt; attractions.GetPlacesByCategoryRequest
        2, // 8: attractions.Attractions.GetPlaces:output_type -&gt; attractions.GetPlacesResponse
        4, // 9: attractions.Attractions.GetPlace:output_type -&gt; attractions.GetPlaceResponse
        6, // 10: attractions.Attractions.SearchPlaces:output_type -&gt; attractions.SearchPlacesResponse
        8, // 11: attractions.Attractions.GetPlacesByCategory:output_type -&gt; attractions.GetPlacesByCategoryResponse
        8, // [8:12] is the sub-list for method output_type
        4, // [4:8] is the sub-list for method input_type
        4, // [4:4] is the sub-list for extension type_name
        4, // [4:4] is the sub-list for extension extendee
        0, // [0:4] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_init() }</span>
func file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_init() <span class="cov8" title="1">{
        if File_internal_pkg_attractions_delivery_grpc_proto_attractions_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   9,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_goTypes,
                DependencyIndexes: file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_depIdxs,
                MessageInfos:      file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_msgTypes,
        }.Build()
        File_internal_pkg_attractions_delivery_grpc_proto_attractions_proto = out.File
        file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_rawDesc = nil
        file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_goTypes = nil
        file_internal_pkg_attractions_delivery_grpc_proto_attractions_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.1
// source: internal/pkg/attractions/delivery/grpc/proto/attractions.proto

package gen

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Attractions_GetPlaces_FullMethodName           = "/attractions.Attractions/GetPlaces"
        Attractions_GetPlace_FullMethodName            = "/attractions.Attractions/GetPlace"
        Attractions_SearchPlaces_FullMethodName        = "/attractions.Attractions/SearchPlaces"
        Attractions_GetPlacesByCategory_FullMethodName = "/attractions.Attractions/GetPlacesByCategory"
)

// AttractionsClient is the client API for Attractions service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AttractionsClient interface {
        GetPlaces(ctx context.Context, in *GetPlacesRequest, opts ...grpc.CallOption) (*GetPlacesResponse, error)
        // rpc CreatePlace(CreatePlaceRequest) returns (CreatePlaceResponse) {}
        GetPlace(ctx context.Context, in *GetPlaceRequest, opts ...grpc.CallOption) (*GetPlaceResponse, error)
        // rpc UpdatePlace(UpdatePlaceRequest) returns (UpdatePlaceResponse) {}
        // rpc DeletePlace(DeletePlaceRequest) returns (DeletePlaceResponse) {}
        SearchPlaces(ctx context.Context, in *SearchPlacesRequest, opts ...grpc.CallOption) (*SearchPlacesResponse, error)
        GetPlacesByCategory(ctx context.Context, in *GetPlacesByCategoryRequest, opts ...grpc.CallOption) (*GetPlacesByCategoryResponse, error)
}

type attractionsClient struct {
        cc grpc.ClientConnInterface
}

func NewAttractionsClient(cc grpc.ClientConnInterface) AttractionsClient <span class="cov0" title="0">{
        return &amp;attractionsClient{cc}
}</span>

func (c *attractionsClient) GetPlaces(ctx context.Context, in *GetPlacesRequest, opts ...grpc.CallOption) (*GetPlacesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetPlacesResponse)
        err := c.cc.Invoke(ctx, Attractions_GetPlaces_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *attractionsClient) GetPlace(ctx context.Context, in *GetPlaceRequest, opts ...grpc.CallOption) (*GetPlaceResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetPlaceResponse)
        err := c.cc.Invoke(ctx, Attractions_GetPlace_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *attractionsClient) SearchPlaces(ctx context.Context, in *SearchPlacesRequest, opts ...grpc.CallOption) (*SearchPlacesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SearchPlacesResponse)
        err := c.cc.Invoke(ctx, Attractions_SearchPlaces_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *attractionsClient) GetPlacesByCategory(ctx context.Context, in *GetPlacesByCategoryRequest, opts ...grpc.CallOption) (*GetPlacesByCategoryResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetPlacesByCategoryResponse)
        err := c.cc.Invoke(ctx, Attractions_GetPlacesByCategory_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AttractionsServer is the server API for Attractions service.
// All implementations must embed UnimplementedAttractionsServer
// for forward compatibility.
type AttractionsServer interface {
        GetPlaces(context.Context, *GetPlacesRequest) (*GetPlacesResponse, error)
        // rpc CreatePlace(CreatePlaceRequest) returns (CreatePlaceResponse) {}
        GetPlace(context.Context, *GetPlaceRequest) (*GetPlaceResponse, error)
        // rpc UpdatePlace(UpdatePlaceRequest) returns (UpdatePlaceResponse) {}
        // rpc DeletePlace(DeletePlaceRequest) returns (DeletePlaceResponse) {}
        SearchPlaces(context.Context, *SearchPlacesRequest) (*SearchPlacesResponse, error)
        GetPlacesByCategory(context.Context, *GetPlacesByCategoryRequest) (*GetPlacesByCategoryResponse, error)
        mustEmbedUnimplementedAttractionsServer()
}

// UnimplementedAttractionsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAttractionsServer struct{}

func (UnimplementedAttractionsServer) GetPlaces(context.Context, *GetPlacesRequest) (*GetPlacesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetPlaces not implemented")
}</span>
func (UnimplementedAttractionsServer) GetPlace(context.Context, *GetPlaceRequest) (*GetPlaceResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetPlace not implemented")
}</span>
func (UnimplementedAttractionsServer) SearchPlaces(context.Context, *SearchPlacesRequest) (*SearchPlacesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SearchPlaces not implemented")
}</span>
func (UnimplementedAttractionsServer) GetPlacesByCategory(context.Context, *GetPlacesByCategoryRequest) (*GetPlacesByCategoryResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetPlacesByCategory not implemented")
}</span>
func (UnimplementedAttractionsServer) mustEmbedUnimplementedAttractionsServer() {<span class="cov0" title="0">}</span>
func (UnimplementedAttractionsServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeAttractionsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AttractionsServer will
// result in compilation errors.
type UnsafeAttractionsServer interface {
        mustEmbedUnimplementedAttractionsServer()
}

func RegisterAttractionsServer(s grpc.ServiceRegistrar, srv AttractionsServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedAttractionsServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Attractions_ServiceDesc, srv)</span>
}

func _Attractions_GetPlaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetPlacesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AttractionsServer).GetPlaces(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Attractions_GetPlaces_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AttractionsServer).GetPlaces(ctx, req.(*GetPlacesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Attractions_GetPlace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetPlaceRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AttractionsServer).GetPlace(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Attractions_GetPlace_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AttractionsServer).GetPlace(ctx, req.(*GetPlaceRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Attractions_SearchPlaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SearchPlacesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AttractionsServer).SearchPlaces(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Attractions_SearchPlaces_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AttractionsServer).SearchPlaces(ctx, req.(*SearchPlacesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Attractions_GetPlacesByCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetPlacesByCategoryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AttractionsServer).GetPlacesByCategory(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Attractions_GetPlacesByCategory_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AttractionsServer).GetPlacesByCategory(ctx, req.(*GetPlacesByCategoryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Attractions_ServiceDesc is the grpc.ServiceDesc for Attractions service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Attractions_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "attractions.Attractions",
        HandlerType: (*AttractionsServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetPlaces",
                        Handler:    _Attractions_GetPlaces_Handler,
                },
                {
                        MethodName: "GetPlace",
                        Handler:    _Attractions_GetPlace_Handler,
                },
                {
                        MethodName: "SearchPlaces",
                        Handler:    _Attractions_SearchPlaces_Handler,
                },
                {
                        MethodName: "GetPlacesByCategory",
                        Handler:    _Attractions_GetPlacesByCategory_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "internal/pkg/attractions/delivery/grpc/proto/attractions.proto",
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package grpc

//go:generate protoc -I . proto/attractions.proto --go_out=./gen --go-grpc_out=./gen

import (
        "2024_2_ThereWillBeName/internal/pkg/attractions"
        "2024_2_ThereWillBeName/internal/pkg/attractions/delivery/grpc/gen"
        "context"
)

type GrpcAttractionsHandler struct {
        gen.UnimplementedAttractionsServer
        placeUsecase attractions.PlaceUsecase
}

func NewGrpcAttractionsHandler(placeUsecase attractions.PlaceUsecase) *GrpcAttractionsHandler <span class="cov0" title="0">{
        return &amp;GrpcAttractionsHandler{placeUsecase: placeUsecase}
}</span>

func (s *GrpcAttractionsHandler) GetPlaces(ctx context.Context, req *gen.GetPlacesRequest) (*gen.GetPlacesResponse, error) <span class="cov0" title="0">{
        places, err := s.placeUsecase.GetPlaces(ctx, int(req.Limit), int(req.Offset))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">placesResponse := make([]*gen.Place, len(places))
        for i, place := range places </span><span class="cov0" title="0">{
                placesResponse[i] = &amp;gen.Place{
                        Id:          uint32(place.ID),
                        Name:        place.Name,
                        ImagePath:   place.ImagePath,
                        Description: place.Description,
                        Rating:      int32(place.Rating),
                        Address:     place.Address,
                        City:        place.City,
                        PhoneNumber: place.PhoneNumber,
                        Categories:  place.Categories,
                        Latitude:    place.Latitude,
                        Longitude:   place.Longitude,
                }
        }</span>
        <span class="cov0" title="0">return &amp;gen.GetPlacesResponse{Places: placesResponse}, nil</span>
}

func (s *GrpcAttractionsHandler) GetPlace(ctx context.Context, req *gen.GetPlaceRequest) (*gen.GetPlaceResponse, error) <span class="cov0" title="0">{
        place, err := s.placeUsecase.GetPlace(ctx, uint(req.Id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">placeResponse := &amp;gen.Place{
                Id:          uint32(place.ID),
                Name:        place.Name,
                ImagePath:   place.ImagePath,
                Description: place.Description,
                Rating:      int32(place.Rating),
                Address:     place.Address,
                City:        place.City,
                PhoneNumber: place.PhoneNumber,
                Categories:  place.Categories,
                Latitude:    place.Latitude,
                Longitude:   place.Longitude,
        }
        return &amp;gen.GetPlaceResponse{Place: placeResponse}, nil</span>
}

func (s *GrpcAttractionsHandler) SearchPlaces(ctx context.Context, req *gen.SearchPlacesRequest) (*gen.SearchPlacesResponse, error) <span class="cov0" title="0">{
        places, err := s.placeUsecase.SearchPlaces(ctx, req.Name, int(req.Category), int(req.City), int(req.Limit), int(req.Offset))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">placesResponse := make([]*gen.Place, len(places))
        for i, place := range places </span><span class="cov0" title="0">{
                placesResponse[i] = &amp;gen.Place{
                        Id:          uint32(place.ID),
                        Name:        place.Name,
                        ImagePath:   place.ImagePath,
                        Description: place.Description,
                        Rating:      int32(place.Rating),
                        Address:     place.Address,
                        City:        place.City,
                        PhoneNumber: place.PhoneNumber,
                        Categories:  place.Categories,
                        Latitude:    place.Latitude,
                        Longitude:   place.Longitude,
                }
        }</span>
        <span class="cov0" title="0">return &amp;gen.SearchPlacesResponse{Places: placesResponse}, nil</span>
}

func (s *GrpcAttractionsHandler) GetPlacesByCategory(ctx context.Context, req *gen.GetPlacesByCategoryRequest) (*gen.GetPlacesByCategoryResponse, error) <span class="cov0" title="0">{
        places, err := s.placeUsecase.GetPlacesByCategory(ctx, req.Category, int(req.Limit), int(req.Offset))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">placesResponse := make([]*gen.Place, len(places))
        for i, place := range places </span><span class="cov0" title="0">{
                placesResponse[i] = &amp;gen.Place{
                        Id:          uint32(place.ID),
                        Name:        place.Name,
                        Description: place.Description,
                        Rating:      int32(place.Rating),
                        Address:     place.Address,
                        City:        place.City,
                        PhoneNumber: place.PhoneNumber,
                        Categories:  place.Categories,
                        Latitude:    place.Latitude,
                        Longitude:   place.Longitude,
                }
        }</span>
        <span class="cov0" title="0">return &amp;gen.GetPlacesByCategoryResponse{Places: placesResponse}, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package http

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/attractions/delivery/grpc/gen"
        httpresponse "2024_2_ThereWillBeName/internal/pkg/httpresponses"
        log "2024_2_ThereWillBeName/internal/pkg/logger"
        "errors"
        "html/template"
        "log/slog"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
)

type PlacesHandler struct {
        client gen.AttractionsClient
        logger *slog.Logger
}

func NewPlacesHandler(client gen.AttractionsClient, logger *slog.Logger) *PlacesHandler <span class="cov0" title="0">{
        return &amp;PlacesHandler{client, logger}
}</span>

// GetPlaceHandler godoc
// @Summary Get a list of attractions
// @Description Retrieve a list of attractions from the database
// @Produce json
// @Success 200 {array} models.GetPlace "List of attractions"
// @Failure 400 {object} httpresponses.ErrorResponse "Bad request"
// @Failure 500 {object} httpresponses.ErrorResponse "Internal Server Error"
// @Router /attractions [get]
func (h *PlacesHandler) GetPlacesHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for searching attractions")

        offset, err := strconv.Atoi(r.URL.Query().Get("offset"))
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
                h.logger.Warn("Invalid offset parameter", slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">limit, err := strconv.Atoi(r.URL.Query().Get("limit"))
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
                h.logger.Warn("Invalid limit parameter", slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">places, err := h.client.GetPlaces(r.Context(), &amp;gen.GetPlacesRequest{Limit: int32(limit), Offset: int32(offset)})
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusInternalServerError, h.logger)
                h.logger.Error("Couldn't get list of attractions",
                        slog.Int("limit", limit),
                        slog.Int("offset", offset),
                        slog.String("error", err.Error()))
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully retrieved attractions")

        httpresponse.SendJSONResponse(w, places.Places, http.StatusOK, h.logger)</span>
}

// PostPlaceHandler godoc
// @Summary Create a new place
// @Description Add a new place to the database
// @Accept json
// @Produce json
// @Param place body models.CreatePlace true "Place data"
// @Success 201 {object} httpresponses.ErrorResponse "Place successfully created"
// @Failure 400 {object} httpresponses.ErrorResponse
// @Failure 403 {object} httpresponses.ErrorResponse "Token is missing"
// @Failure 403 {object} httpresponses.ErrorResponse "Invalid token"
// @Failure 422 {object} httpresponses.ErrorResponse
// @Failure 500 {object} httpresponses.ErrorResponse
// @Router /attractions [post]
//func (h *PlacesHandler) PostPlaceHandler(w http.ResponseWriter, r *http.Request) {
//        w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'; style-src 'self';")
//        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
//        h.logger.DebugContext(logCtx, "Handling request for creating a place")
//
//        var place models.CreatePlace
//        if err := json.NewDecoder(r.Body).Decode(&amp;place); err != nil {
//                httpresponse.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
//                h.logger.Warn("Failed to decode place data",
//                        slog.String("error", err.Error()),
//                        slog.String("place_data", fmt.Sprintf("%+v", place)))
//                return
//        }
//        v := validator.New()
//        if models.ValidateCreatePlace(v, &amp;place); !v.Valid() {
//                httpresponse.SendJSONResponse(w, nil, http.StatusUnprocessableEntity, h.logger)
//                return
//        }
//
//        place.Name = template.HTMLEscapeString(place.Name)
//        place.ImagePath = template.HTMLEscapeString(place.ImagePath)
//        place.Description = template.HTMLEscapeString(place.Description)
//        place.Address = template.HTMLEscapeString(place.Address)
//        place.PhoneNumber = template.HTMLEscapeString(place.PhoneNumber)
//
//        if err := h.uc.CreatePlace(r.Context(), place); err != nil {
//                httpresponse.SendJSONResponse(w, nil, http.StatusInternalServerError, h.logger)
//                h.logger.Error("Failed to create place",
//                        slog.String("placeName", place.Name),
//                        slog.String("error", err.Error()))
//                return
//        }
//
//        h.logger.DebugContext(logCtx, "Successfully created place")
//
//        httpresponse.SendJSONResponse(w, "Place succesfully created", http.StatusCreated, h.logger)
//}
//
//// PutPlaceHandler godoc
//// @Summary Update an existing place
//// @Description Update the details of an existing place in the database
//// @Accept json
//// @Produce json
//// @Param place body models.UpdatePlace true "Updated place data"
//// @Success 200 {object} httpresponses.ErrorResponse "Place successfully updated"
//// @Failure 400 {object} httpresponses.ErrorResponse
//// @Failure 403 {object} httpresponses.ErrorResponse "Token is missing"
//// @Failure 403 {object} httpresponses.ErrorResponse "Invalid token"
//// @Failure 422 {object} httpresponses.ErrorResponse
//// @Failure 500 {object} httpresponses.ErrorResponse
//// @Router /attractions/{id} [put]
//func (h *PlacesHandler) PutPlaceHandler(w http.ResponseWriter, r *http.Request) {
//        w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'; style-src 'self';")
//        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
//        h.logger.DebugContext(logCtx, "Handling request for updating a place")
//
//        var place models.UpdatePlace
//
//        if err := json.NewDecoder(r.Body).Decode(&amp;place); err != nil {
//                httpresponse.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
//                h.logger.Warn("Failed to decode place data",
//                        slog.String("error", err.Error()),
//                        slog.String("place_data", fmt.Sprintf("%+v", place)))
//                return
//        }
//
//        v := validator.New()
//        if models.ValidateUpdatePlace(v, &amp;place); !v.Valid() {
//                httpresponse.SendJSONResponse(w, nil, http.StatusUnprocessableEntity, h.logger)
//                return
//        }
//
//        place.Name = template.HTMLEscapeString(place.Name)
//        place.ImagePath = template.HTMLEscapeString(place.ImagePath)
//        place.Description = template.HTMLEscapeString(place.Description)
//        place.Address = template.HTMLEscapeString(place.Address)
//        place.PhoneNumber = template.HTMLEscapeString(place.PhoneNumber)
//
//        if err := h.uc.UpdatePlace(r.Context(), place); err != nil {
//                httpresponse.SendJSONResponse(w, nil, http.StatusInternalServerError, h.logger)
//                h.logger.Error("Failed to update place",
//                        slog.Int("placeID", place.ID),
//                        slog.String("error", err.Error()))
//                return
//        }
//
//        h.logger.DebugContext(logCtx, "Successfully updated place")
//
//        httpresponse.SendJSONResponse(w, "place successfully updated", http.StatusOK, h.logger)
//}
//
//// DeletePlaceHandler godoc
//// @Summary Delete an existing place
//// @Description Remove a place from the database by its name
//// @Produce json
//// @Param name body string true "Name of the place to be deleted"
//// @Success 200 {object} httpresponses.ErrorResponse "Place successfully deleted"
//// @Failure 400 {object} httpresponses.ErrorResponse
//// @Failure 403 {object} httpresponses.ErrorResponse "Token is missing"
//// @Failure 403 {object} httpresponses.ErrorResponse "Invalid token"
//// @Failure 500 {object} httpresponses.ErrorResponse
//// @Router /attractions/{id} [delete]
//func (h *PlacesHandler) DeletePlaceHandler(w http.ResponseWriter, r *http.Request) {
//
//        idStr := mux.Vars(r)["id"]
//
//        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
//        h.logger.DebugContext(logCtx, "Handling request for deleting a place by ID", slog.String("placeID", idStr))
//
//        id, err := strconv.ParseUint(idStr, 10, 64)
//        if err != nil {
//                httpresponse.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
//                h.logger.Warn("Failed to parse place ID", slog.String("placeID", idStr), slog.String("error", err.Error()))
//                return
//        }
//        if err := h.uc.DeletePlace(r.Context(), uint(id)); err != nil {
//                if errors.Is(err, models.ErrNotFound) {
//                        httpresponse.SendJSONResponse(w, nil, http.StatusNotFound, h.logger)
//                        h.logger.Warn("Place not found", slog.String("placeID", idStr), slog.String("error", err.Error()))
//                        return
//                }
//                httpresponse.SendJSONResponse(w, nil, http.StatusInternalServerError, h.logger)
//                h.logger.Error("Failed to delete a place", slog.String("placeID", idStr), slog.String("error", err.Error()))
//                return
//        }
//        httpresponse.SendJSONResponse(w, "place successfully deleted", http.StatusOK, h.logger)
//
//        h.logger.DebugContext(logCtx, "Successfully updated place")
//}

// GetPlaceHandler godoc
// @Summary Retrieve an existing place
// @Description Get details of a place from the database by its id
// @Produce json
// @Param id body int true "ID of the place to retrieve"
// @Success 200 {object} models.GetPlace "Details of the requested place"
// @Failure 400 {object} httpresponses.ErrorResponse
// @Failure 500 {object} httpresponses.ErrorResponse
// @Router /attractions/{id} [get]
func (h *PlacesHandler) GetPlaceHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idStr := mux.Vars(r)["id"]

        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for getting a place by ID", slog.String("placeID", idStr))

        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
                h.logger.Warn("Failed to parse place ID", slog.String("placeID", idStr), slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">place, err := h.client.GetPlace(r.Context(), &amp;gen.GetPlaceRequest{Id: uint32(id)})
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        response := httpresponse.ErrorResponse{
                                Message: "place not found",
                        }
                        httpresponse.SendJSONResponse(w, response, http.StatusNotFound, h.logger)
                        h.logger.Warn("Place not found", slog.String("placeID", idStr), slog.String("error", err.Error()))
                        return
                }</span>
                <span class="cov0" title="0">httpresponse.SendJSONResponse(w, nil, http.StatusInternalServerError, h.logger)
                h.logger.Error("Failed to get a place", slog.String("placeID", idStr), slog.String("error", err.Error()))
                return</span>
        }
        <span class="cov0" title="0">httpresponse.SendJSONResponse(w, place.Place, http.StatusOK, h.logger)

        h.logger.DebugContext(logCtx, "Successfully getting place")</span>
}

// GetPlacesByNameHandler godoc
// @Summary Retrieve attractions by search string
// @Description Get a list of attractions from the database that match the provided search string
// @Produce json
// @Param searchString body string true "Name of the attractions to retrieve"
// @Success 200 {object} models.GetPlace "List of attractions matching the provided searchString"
// @Failure 400 {object} httpresponses.ErrorResponse
// @Failure 500 {object} httpresponses.ErrorResponse
// @Router /attractions/search/{placeName} [get]
func (h *PlacesHandler) SearchPlacesHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'; style-src 'self';")
        placeName := r.URL.Query().Get("placeName")
        placeName = template.HTMLEscapeString(placeName)

        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for searching attractions by place name", slog.String("placeName", placeName))

        offset, err := strconv.Atoi(r.URL.Query().Get("offset"))
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
                h.logger.Warn("Invalid offset parameter", slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">limit, err := strconv.Atoi(r.URL.Query().Get("limit"))
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
                h.logger.Warn("Invalid limit parameter", slog.String("error", err.Error()))
                return
        }</span>

        <span class="cov0" title="0">cityStr := r.URL.Query().Get("city")
        categoryStr := r.URL.Query().Get("category")

        var city, category int
        if cityStr != "" </span><span class="cov0" title="0">{
                city, err = strconv.Atoi(cityStr)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Warn("Invalid city parameter", slog.String("error", err.Error()))
                        httpresponse.SendJSONResponse(w, httpresponse.ErrorResponse{
                                Message: "Invalid city parameter",
                        }, http.StatusBadRequest, h.logger)
                        return
                }</span>
        }

        <span class="cov0" title="0">if categoryStr != "" </span><span class="cov0" title="0">{
                category, err = strconv.Atoi(categoryStr)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Warn("Invalid category parameter", slog.String("error", err.Error()))
                        httpresponse.SendJSONResponse(w, httpresponse.ErrorResponse{
                                Message: "Invalid category parameter",
                        }, http.StatusBadRequest, h.logger)
                        return
                }</span>
        }

        <span class="cov0" title="0">places, err := h.client.SearchPlaces(r.Context(), &amp;gen.SearchPlacesRequest{Name: placeName, Category: int32(category), City: int32(city), Limit: int32(limit), Offset: int32(offset)})
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusInternalServerError, h.logger)
                h.logger.Error("Failed to search attractions", slog.String("placeName", placeName), slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">httpresponse.SendJSONResponse(w, places.Places, http.StatusOK, h.logger)

        h.logger.DebugContext(logCtx, "Successfully getting attractions by name")</span>
}

func (h *PlacesHandler) GetPlacesByCategoryHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        categoryName := mux.Vars(r)["categoryName"]

        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for searching attractions by category", slog.String("categoryName", categoryName))

        offset, err := strconv.Atoi(r.URL.Query().Get("offset"))
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
                h.logger.Warn("Invalid offset parameter", slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">limit, err := strconv.Atoi(r.URL.Query().Get("limit"))
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
                h.logger.Warn("Invalid limit parameter", slog.String("error", err.Error()))
                return
        }</span>

        <span class="cov0" title="0">places, err := h.client.GetPlacesByCategory(r.Context(), &amp;gen.GetPlacesByCategoryRequest{Category: categoryName, Limit: int32(limit), Offset: int32(offset)})
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusInternalServerError, h.logger)
                h.logger.Error("Error getting attractions by category",
                        slog.Int("limit", limit),
                        slog.Int("offset", offset),
                        slog.String("categoryName", categoryName),
                        slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">httpresponse.SendJSONResponse(w, places.Places, http.StatusOK, h.logger)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package repo

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/dblogger"
        "context"
        "database/sql"
        _ "embed"
        "errors"
        "fmt"

        "github.com/lib/pq"
)

type PlaceRepository struct {
        db *dblogger.DB
}

func NewPLaceRepository(db *dblogger.DB) *PlaceRepository <span class="cov0" title="0">{
        return &amp;PlaceRepository{db: db}
}</span>

func (r *PlaceRepository) GetPlaces(ctx context.Context, limit, offset int) ([]models.GetPlace, error) <span class="cov0" title="0">{
        query := "SELECT p.id, p.name, p.image_path, p.description, p.rating, p.address, p.phone_number, p.latitude, p.longitude, c.name AS city_name, ARRAY_AGG(ca.name) AS categories FROM place p JOIN city c ON p.city_id = c.id JOIN place_category pc ON p.id = pc.place_id JOIN category ca ON pc.category_id = ca.id GROUP BY p.id, c.name ORDER BY p.id LIMIT $1 OFFSET $2"
        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("couldn't get attractions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var places []models.GetPlace
        for rows.Next() </span><span class="cov0" title="0">{
                var place models.GetPlace
                err := rows.Scan(&amp;place.ID, &amp;place.Name, &amp;place.ImagePath, &amp;place.Description, &amp;place.Rating, &amp;place.Address, &amp;place.PhoneNumber, &amp;place.Latitude, &amp;place.Longitude, &amp;place.City, pq.Array(&amp;place.Categories))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("couldn't unmarshal list of attractions: %w", err)
                }</span>
                <span class="cov0" title="0">places = append(places, place)</span>
        }
        <span class="cov0" title="0">return places, nil</span>
}

func (r *PlaceRepository) CreatePlace(ctx context.Context, place models.CreatePlace) error <span class="cov0" title="0">{
        query := "INSERT INTO place (name, image_path, description, rating, address, city_id, phone_number, latitude, longitude) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id"
        var id int
        err := r.db.QueryRowContext(ctx, query, place.Name, place.ImagePath, place.Description, place.Rating, place.Address, place.CityId, place.PhoneNumber, place.Latitude, place.Longitude).Scan(&amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("coldn't create place: %w", err)
        }</span>
        <span class="cov0" title="0">for _, categoryId := range place.CategoriesId </span><span class="cov0" title="0">{
                query = "INSERT INTO place_category (place_id, category_id) VALUES ($1, $2)"
                result, err := r.db.ExecContext(ctx, query, id, categoryId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("coldn't create place_category: %w", err)
                }</span>
                <span class="cov0" title="0">if _, err = result.RowsAffected(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("couldn't get number of rows affected: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *PlaceRepository) GetPlace(ctx context.Context, id uint) (models.GetPlace, error) <span class="cov0" title="0">{
        var place models.GetPlace
        query := "SELECT p.id, p.name, p.image_path, p.description, p.rating, p.address, p.phone_number, p.latitude, p.longitude, c.name AS city_name, ARRAY_AGG(ca.name) AS categories FROM place p JOIN city c ON p.city_id = c.id JOIN place_category pc ON p.id = pc.place_id JOIN category ca ON pc.category_id = ca.id WHERE p.id = $1 GROUP BY p.id, c.name ORDER BY p.id"
        row := r.db.QueryRowContext(ctx, query, id)
        err := row.Scan(&amp;place.ID, &amp;place.Name, &amp;place.ImagePath, &amp;place.Description, &amp;place.Rating, &amp;place.Address, &amp;place.PhoneNumber, &amp;place.Latitude, &amp;place.Longitude, &amp;place.City, pq.Array(&amp;place.Categories))
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.GetPlace{}, fmt.Errorf("place not found")
                }</span>
                <span class="cov0" title="0">return models.GetPlace{}, fmt.Errorf("couldn't get place by name: %w", err)</span>
        }
        <span class="cov0" title="0">return place, nil</span>
}

func (r *PlaceRepository) UpdatePlace(ctx context.Context, place models.UpdatePlace) error <span class="cov0" title="0">{
        query := "UPDATE place SET name = $1, image_path = $2, description = $3, rating = $4, address = $5, phone_number = $6, latitude = $7, longitude = $8, updated_at = NOW() WHERE id=$7"
        result, err := r.db.ExecContext(ctx, query, place.Name, place.ImagePath, place.Description, place.Rating, place.Address, place.PhoneNumber, place.Latitude, place.Longitude, place.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't update place: %w", err)
        }</span>
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't get number of rows affected: %w", err)
        }</span>
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no rows were updated")
        }</span>

        <span class="cov0" title="0">query = "DELETE FROM place_category WHERE place_id=$1"
        result, err = r.db.ExecContext(ctx, query, place.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't delete place_category: %w", err)
        }</span>
        <span class="cov0" title="0">rowsAffected, err = result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't get number of rows affected: %w", err)
        }</span>
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no rows were deleted")
        }</span>

        <span class="cov0" title="0">for _, categoryId := range place.CategoriesId </span><span class="cov0" title="0">{
                query = "INSERT INTO place_category (place_id, category_id) VALUES ($1, $2)"
                result, err := r.db.ExecContext(ctx, query, place.ID, categoryId)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("coldn't create place_category: %w", err)
                }</span>
                <span class="cov0" title="0">if _, err = result.RowsAffected(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("couldn't get number of rows affected: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *PlaceRepository) DeletePlace(ctx context.Context, id uint) error <span class="cov0" title="0">{
        query := "DELETE FROM place WHERE id=$1"
        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't delete place: %w", err)
        }</span>
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't get number of rows affected: %w", err)
        }</span>
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no rows were deleted: %w", models.ErrNotFound)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *PlaceRepository) SearchPlaces(ctx context.Context, name string, category, city, limit, offset int) ([]models.GetPlace, error) <span class="cov0" title="0">{
        var places []models.GetPlace

        query := `
                SELECT 
                        p.id, p.name, p.image_path, p.description, p.rating, 
                        p.address, p.phone_number, c.name AS city_name, 
                        ARRAY_AGG(ca.name) AS categories 
                FROM 
                        place p 
                JOIN 
                        city c ON p.city_id = c.id 
                JOIN 
                        place_category pc ON p.id = pc.place_id 
                JOIN 
                        category ca ON pc.category_id = ca.id 
                WHERE 
                        p.name LIKE '%' || $1 || '%'`

        args := []interface{}{name}

        if category &gt; 0 </span><span class="cov0" title="0">{
                query += " AND pc.category_id = $2"
                args = append(args, category)
        }</span>

        <span class="cov0" title="0">if city &gt; 0 </span><span class="cov0" title="0">{
                query += " AND p.city_id = $" + fmt.Sprint(len(args)+1)
                args = append(args, city)
        }</span>

        <span class="cov0" title="0">query += `
                GROUP BY 
                        p.id, c.name 
                ORDER BY 
                        p.id 
                LIMIT $` + fmt.Sprint(len(args)+1) + ` OFFSET $` + fmt.Sprint(len(args)+2)
        args = append(args, limit, offset)

        stmt, err := r.db.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("couldn't prepare query: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        rows, err := stmt.QueryContext(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("couldn't get places: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var place models.GetPlace
                err := rows.Scan(&amp;place.ID, &amp;place.Name, &amp;place.ImagePath, &amp;place.Description, &amp;place.Rating, &amp;place.Address, &amp;place.PhoneNumber, &amp;place.City, pq.Array(&amp;place.Categories))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("couldn't unmarshal list of places: %w", err)
                }</span>
                <span class="cov0" title="0">places = append(places, place)</span>
        }

        <span class="cov0" title="0">return places, nil</span>
}

func (r *PlaceRepository) GetPlacesByCategory(ctx context.Context, category string, limit, offset int) ([]models.GetPlace, error) <span class="cov0" title="0">{
        query := `SELECT 
                    p.id, p.name, p.image_path, p.description, p.rating, p.address, p.phone_number, p.latitude, p.longitude,
                    c.name AS city_name,
                    ARRAY_AGG(ca.name) AS categories
                        FROM place p 
                        JOIN city c 
                        ON p.city_id = c.id 
                        JOIN place_category pc
                        ON p.id = pc.place_id
                        JOIN category ca 
                        ON pc.category_id = ca.id 
                        WHERE p.id IN (
                                               SELECT p.id 
                                            FROM place p 
                                            JOIN place_category pc 
                                            ON p.id = pc.place_id 
                                            JOIN category ca 
                                            ON pc.category_id = ca.id 
                                            WHERE ca.name = $1)
                        GROUP BY p.id, c.name
                        ORDER BY p.id 
                        LIMIT $2 
                        OFFSET $3`
        rows, err := r.db.QueryContext(ctx, query, category, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("couldn't get attractions by category: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var places []models.GetPlace
        for rows.Next() </span><span class="cov0" title="0">{
                var place models.GetPlace
                err := rows.Scan(&amp;place.ID, &amp;place.Name, &amp;place.ImagePath, &amp;place.Description, &amp;place.Rating, &amp;place.Address, &amp;place.PhoneNumber, &amp;place.Latitude, &amp;place.Longitude, &amp;place.City, pq.Array(&amp;place.Categories))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("couldn't unmarshal list of attractions: %w", err)
                }</span>
                <span class="cov0" title="0">places = append(places, place)</span>
        }
        <span class="cov0" title="0">return places, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package usecase

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/attractions"
        "context"
)

type PlaceUsecaseImpl struct {
        repo attractions.PlaceRepo
}

func NewPlaceUsecase(repo attractions.PlaceRepo) *PlaceUsecaseImpl <span class="cov8" title="1">{
        return &amp;PlaceUsecaseImpl{repo: repo}
}</span>

func (i *PlaceUsecaseImpl) GetPlaces(ctx context.Context, limit, offset int) ([]models.GetPlace, error) <span class="cov8" title="1">{
        places, err := i.repo.GetPlaces(ctx, limit, offset)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return places, nil</span>
}

func (i *PlaceUsecaseImpl) CreatePlace(ctx context.Context, place models.CreatePlace) error <span class="cov8" title="1">{

        return i.repo.CreatePlace(ctx, place)
}</span>

func (i *PlaceUsecaseImpl) UpdatePlace(ctx context.Context, place models.UpdatePlace) error <span class="cov8" title="1">{
        return i.repo.UpdatePlace(ctx, place)
}</span>

func (i *PlaceUsecaseImpl) DeletePlace(ctx context.Context, id uint) error <span class="cov8" title="1">{
        return i.repo.DeletePlace(ctx, id)
}</span>

func (i *PlaceUsecaseImpl) GetPlace(ctx context.Context, id uint) (models.GetPlace, error) <span class="cov8" title="1">{
        return i.repo.GetPlace(ctx, id)
}</span>

func (i *PlaceUsecaseImpl) SearchPlaces(ctx context.Context, name string, category, city, limit, offset int) ([]models.GetPlace, error) <span class="cov0" title="0">{
        return i.repo.SearchPlaces(ctx, name, category, city, limit, offset)
}</span>
func (i *PlaceUsecaseImpl) GetPlacesByCategory(ctx context.Context, category string, limit, offset int) ([]models.GetPlace, error) <span class="cov8" title="1">{
        return i.repo.GetPlacesByCategory(ctx, category, limit, offset)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v5.29.0--rc2
// source: proto/categories.proto

package gen

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Category struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id   uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *Category) Reset() <span class="cov0" title="0">{
        *x = Category{}
        mi := &amp;file_proto_categories_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Category) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Category) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Category) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_categories_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Category.ProtoReflect.Descriptor instead.
func (*Category) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_categories_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Category) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Category) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetCategoriesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Limit  int32 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset int32 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *GetCategoriesRequest) Reset() <span class="cov0" title="0">{
        *x = GetCategoriesRequest{}
        mi := &amp;file_proto_categories_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetCategoriesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetCategoriesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetCategoriesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_categories_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetCategoriesRequest.ProtoReflect.Descriptor instead.
func (*GetCategoriesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_categories_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetCategoriesRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetCategoriesRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetCategoriesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Categories []*Category `protobuf:"bytes,1,rep,name=categories,proto3" json:"categories,omitempty"`
}

func (x *GetCategoriesResponse) Reset() <span class="cov0" title="0">{
        *x = GetCategoriesResponse{}
        mi := &amp;file_proto_categories_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetCategoriesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetCategoriesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetCategoriesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_categories_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetCategoriesResponse.ProtoReflect.Descriptor instead.
func (*GetCategoriesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_categories_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetCategoriesResponse) GetCategories() []*Category <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Categories
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_proto_categories_proto protoreflect.FileDescriptor

var file_proto_categories_proto_rawDesc = []byte{
        0x0a, 0x16, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69,
        0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f,
        0x72, 0x69, 0x65, 0x73, 0x22, 0x2e, 0x0a, 0x08, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79,
        0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64,
        0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x22, 0x44, 0x0a, 0x14, 0x47, 0x65, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67,
        0x6f, 0x72, 0x69, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05,
        0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d,
        0x69, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x05, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22, 0x4d, 0x0a, 0x15, 0x47, 0x65,
        0x74, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x34, 0x0a, 0x0a, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65,
        0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f,
        0x72, 0x69, 0x65, 0x73, 0x2e, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x0a, 0x63,
        0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x32, 0x64, 0x0a, 0x0a, 0x43, 0x61, 0x74,
        0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x12, 0x56, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x43, 0x61,
        0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x12, 0x20, 0x2e, 0x63, 0x61, 0x74, 0x65, 0x67,
        0x6f, 0x72, 0x69, 0x65, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72,
        0x69, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x63, 0x61, 0x74,
        0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67,
        0x6f, 0x72, 0x69, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42,
        0x07, 0x5a, 0x05, 0x2e, 0x3b, 0x67, 0x65, 0x6e, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_proto_categories_proto_rawDescOnce sync.Once
        file_proto_categories_proto_rawDescData = file_proto_categories_proto_rawDesc
)

func file_proto_categories_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_categories_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_categories_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_categories_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_proto_categories_proto_rawDescData</span>
}

var file_proto_categories_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_proto_categories_proto_goTypes = []any{
        (*Category)(nil),              // 0: categories.Category
        (*GetCategoriesRequest)(nil),  // 1: categories.GetCategoriesRequest
        (*GetCategoriesResponse)(nil), // 2: categories.GetCategoriesResponse
}
var file_proto_categories_proto_depIdxs = []int32{
        0, // 0: categories.GetCategoriesResponse.categories:type_name -&gt; categories.Category
        1, // 1: categories.Categories.GetCategories:input_type -&gt; categories.GetCategoriesRequest
        2, // 2: categories.Categories.GetCategories:output_type -&gt; categories.GetCategoriesResponse
        2, // [2:3] is the sub-list for method output_type
        1, // [1:2] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_proto_categories_proto_init() }</span>
func file_proto_categories_proto_init() <span class="cov8" title="1">{
        if File_proto_categories_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_proto_categories_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_categories_proto_goTypes,
                DependencyIndexes: file_proto_categories_proto_depIdxs,
                MessageInfos:      file_proto_categories_proto_msgTypes,
        }.Build()
        File_proto_categories_proto = out.File
        file_proto_categories_proto_rawDesc = nil
        file_proto_categories_proto_goTypes = nil
        file_proto_categories_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.0--rc2
// source: proto/categories.proto

package gen

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Categories_GetCategories_FullMethodName = "/categories.Categories/GetCategories"
)

// CategoriesClient is the client API for Categories service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CategoriesClient interface {
        GetCategories(ctx context.Context, in *GetCategoriesRequest, opts ...grpc.CallOption) (*GetCategoriesResponse, error)
}

type categoriesClient struct {
        cc grpc.ClientConnInterface
}

func NewCategoriesClient(cc grpc.ClientConnInterface) CategoriesClient <span class="cov0" title="0">{
        return &amp;categoriesClient{cc}
}</span>

func (c *categoriesClient) GetCategories(ctx context.Context, in *GetCategoriesRequest, opts ...grpc.CallOption) (*GetCategoriesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetCategoriesResponse)
        err := c.cc.Invoke(ctx, Categories_GetCategories_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// CategoriesServer is the server API for Categories service.
// All implementations must embed UnimplementedCategoriesServer
// for forward compatibility.
type CategoriesServer interface {
        GetCategories(context.Context, *GetCategoriesRequest) (*GetCategoriesResponse, error)
        mustEmbedUnimplementedCategoriesServer()
}

// UnimplementedCategoriesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCategoriesServer struct{}

func (UnimplementedCategoriesServer) GetCategories(context.Context, *GetCategoriesRequest) (*GetCategoriesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetCategories not implemented")
}</span>
func (UnimplementedCategoriesServer) mustEmbedUnimplementedCategoriesServer() {<span class="cov0" title="0">}</span>
func (UnimplementedCategoriesServer) testEmbeddedByValue()                    {<span class="cov0" title="0">}</span>

// UnsafeCategoriesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CategoriesServer will
// result in compilation errors.
type UnsafeCategoriesServer interface {
        mustEmbedUnimplementedCategoriesServer()
}

func RegisterCategoriesServer(s grpc.ServiceRegistrar, srv CategoriesServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedCategoriesServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Categories_ServiceDesc, srv)</span>
}

func _Categories_GetCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetCategoriesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CategoriesServer).GetCategories(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Categories_GetCategories_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(CategoriesServer).GetCategories(ctx, req.(*GetCategoriesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Categories_ServiceDesc is the grpc.ServiceDesc for Categories service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Categories_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "categories.Categories",
        HandlerType: (*CategoriesServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetCategories",
                        Handler:    _Categories_GetCategories_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/categories.proto",
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package grpc

import (
        "2024_2_ThereWillBeName/internal/pkg/categories"
        "2024_2_ThereWillBeName/internal/pkg/categories/delivery/grpc/gen"
        "context"
)

//go:generate protoc -I . proto/categories.proto --go_out=./gen --go-grpc_out=./gen

type GrpcCategoriesHandler struct {
        gen.UnimplementedCategoriesServer
        uc categories.CategoriesUsecase
}

func NewGrpcCategoriesHandler(uc categories.CategoriesUsecase) *GrpcCategoriesHandler <span class="cov0" title="0">{
        return &amp;GrpcCategoriesHandler{uc: uc}
}</span>

func (s *GrpcCategoriesHandler) GetCategories(ctx context.Context, req *gen.GetCategoriesRequest) (*gen.GetCategoriesResponse, error) <span class="cov0" title="0">{
        categories, err := s.uc.GetCategories(ctx, int(req.Limit), int(req.Offset))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">categoriesResponse := make([]*gen.Category, len(categories))
        for i, category := range categories </span><span class="cov0" title="0">{
                categoriesResponse[i] = &amp;gen.Category{
                        Id:   uint32(category.ID),
                        Name: category.Name,
                }
        }</span>
        <span class="cov0" title="0">return &amp;gen.GetCategoriesResponse{Categories: categoriesResponse}, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package http

import (
        "2024_2_ThereWillBeName/internal/pkg/categories/delivery/grpc/gen"
        httpresponse "2024_2_ThereWillBeName/internal/pkg/httpresponses"
        log "2024_2_ThereWillBeName/internal/pkg/logger"
        "log/slog"
        "net/http"
        "strconv"
)

type CategoriesHandler struct {
        client gen.CategoriesClient
        logger *slog.Logger
}

func NewCategoriesHandler(client gen.CategoriesClient, logger *slog.Logger) *CategoriesHandler <span class="cov0" title="0">{
        return &amp;CategoriesHandler{client, logger}
}</span>

func (h *CategoriesHandler) GetCategoriesHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for getting categories")

        offset, err := strconv.Atoi(r.URL.Query().Get("offset"))
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
                h.logger.Warn("Invalid offset parameter", slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">limit, err := strconv.Atoi(r.URL.Query().Get("limit"))
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
                h.logger.Warn("Invalid limit parameter", slog.String("error", err.Error()))
                return
        }</span>

        <span class="cov0" title="0">categories, err := h.client.GetCategories(logCtx, &amp;gen.GetCategoriesRequest{Limit: int32(limit), Offset: int32(offset)})
        if err != nil </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusInternalServerError, h.logger)
                h.logger.Error("Error getting categories",
                        slog.Int("limit", limit),
                        slog.Int("offset", offset),
                        slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully retrieved categories", slog.Any("categories", categories),
                slog.Int("limit", limit),
                slog.Int("offset", offset))
        httpresponse.SendJSONResponse(w, categories.Categories, http.StatusOK, h.logger)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package repo

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/dblogger"
        "context"
        "fmt"
)

type CategoriesRepo struct {
        db *dblogger.DB
}

func NewCategoriesRepo(db *dblogger.DB) *CategoriesRepo <span class="cov8" title="1">{
        return &amp;CategoriesRepo{db: db}
}</span>

func (r *CategoriesRepo) GetCategories(ctx context.Context, limit, offset int) ([]models.Category, error) <span class="cov8" title="1">{
        query := "SELECT id, name FROM category ORDER BY id LIMIT $1 OFFSET $2"
        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("couldn't get categories: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var categories []models.Category
        for rows.Next() </span><span class="cov8" title="1">{
                var category models.Category
                err := rows.Scan(&amp;category.ID, &amp;category.Name)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("Couldn't unmarshal list of categories: %w", err)
                }</span>
                <span class="cov8" title="1">categories = append(categories, category)</span>
        }
        <span class="cov8" title="1">return categories, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package usecase

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/categories"
        "context"
)

type CategoriesUsecase struct {
        repo categories.CategoriesRepository
}

func NewCategoriesUsecase(repo categories.CategoriesRepository) *CategoriesUsecase <span class="cov8" title="1">{
        return &amp;CategoriesUsecase{repo: repo}
}</span>

func (u *CategoriesUsecase) GetCategories(ctx context.Context, limit, offset int) ([]models.Category, error) <span class="cov8" title="1">{
        return u.repo.GetCategories(ctx, limit, offset)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v5.29.0--rc2
// source: proto/cities.proto

package gen

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type City struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id   uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *City) Reset() <span class="cov0" title="0">{
        *x = City{}
        mi := &amp;file_proto_cities_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *City) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*City) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *City) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cities_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use City.ProtoReflect.Descriptor instead.
func (*City) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cities_proto_rawDescGZIP(), []int{0}
}</span>

func (x *City) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *City) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SearchCitiesByNameRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
}

func (x *SearchCitiesByNameRequest) Reset() <span class="cov0" title="0">{
        *x = SearchCitiesByNameRequest{}
        mi := &amp;file_proto_cities_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchCitiesByNameRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchCitiesByNameRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchCitiesByNameRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cities_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchCitiesByNameRequest.ProtoReflect.Descriptor instead.
func (*SearchCitiesByNameRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cities_proto_rawDescGZIP(), []int{1}
}</span>

func (x *SearchCitiesByNameRequest) GetQuery() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Query
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SearchCitiesByNameResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Cities []*City `protobuf:"bytes,1,rep,name=cities,proto3" json:"cities,omitempty"`
}

func (x *SearchCitiesByNameResponse) Reset() <span class="cov0" title="0">{
        *x = SearchCitiesByNameResponse{}
        mi := &amp;file_proto_cities_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchCitiesByNameResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchCitiesByNameResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchCitiesByNameResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cities_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchCitiesByNameResponse.ProtoReflect.Descriptor instead.
func (*SearchCitiesByNameResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cities_proto_rawDescGZIP(), []int{2}
}</span>

func (x *SearchCitiesByNameResponse) GetCities() []*City <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Cities
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SearchCityByIDRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *SearchCityByIDRequest) Reset() <span class="cov0" title="0">{
        *x = SearchCityByIDRequest{}
        mi := &amp;file_proto_cities_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchCityByIDRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchCityByIDRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchCityByIDRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cities_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchCityByIDRequest.ProtoReflect.Descriptor instead.
func (*SearchCityByIDRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cities_proto_rawDescGZIP(), []int{3}
}</span>

func (x *SearchCityByIDRequest) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type SearchCityByIDResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        City *City `protobuf:"bytes,1,opt,name=city,proto3" json:"city,omitempty"`
}

func (x *SearchCityByIDResponse) Reset() <span class="cov0" title="0">{
        *x = SearchCityByIDResponse{}
        mi := &amp;file_proto_cities_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchCityByIDResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchCityByIDResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchCityByIDResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cities_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchCityByIDResponse.ProtoReflect.Descriptor instead.
func (*SearchCityByIDResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cities_proto_rawDescGZIP(), []int{4}
}</span>

func (x *SearchCityByIDResponse) GetCity() *City <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.City
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_proto_cities_proto protoreflect.FileDescriptor

var file_proto_cities_proto_rawDesc = []byte{
        0x0a, 0x12, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x69, 0x74, 0x69, 0x65, 0x73, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06, 0x63, 0x69, 0x74, 0x69, 0x65, 0x73, 0x22, 0x2a, 0x0a, 0x04,
        0x43, 0x69, 0x74, 0x79, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
        0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x31, 0x0a, 0x19, 0x53, 0x65, 0x61, 0x72,
        0x63, 0x68, 0x43, 0x69, 0x74, 0x69, 0x65, 0x73, 0x42, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x22, 0x42, 0x0a, 0x1a, 0x53,
        0x65, 0x61, 0x72, 0x63, 0x68, 0x43, 0x69, 0x74, 0x69, 0x65, 0x73, 0x42, 0x79, 0x4e, 0x61, 0x6d,
        0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x24, 0x0a, 0x06, 0x63, 0x69, 0x74,
        0x69, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x63, 0x69, 0x74, 0x69,
        0x65, 0x73, 0x2e, 0x43, 0x69, 0x74, 0x79, 0x52, 0x06, 0x63, 0x69, 0x74, 0x69, 0x65, 0x73, 0x22,
        0x27, 0x0a, 0x15, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x43, 0x69, 0x74, 0x79, 0x42, 0x79, 0x49,
        0x44, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x22, 0x3a, 0x0a, 0x16, 0x53, 0x65, 0x61, 0x72,
        0x63, 0x68, 0x43, 0x69, 0x74, 0x79, 0x42, 0x79, 0x49, 0x44, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x20, 0x0a, 0x04, 0x63, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x0c, 0x2e, 0x63, 0x69, 0x74, 0x69, 0x65, 0x73, 0x2e, 0x43, 0x69, 0x74, 0x79, 0x52, 0x04,
        0x63, 0x69, 0x74, 0x79, 0x32, 0xba, 0x01, 0x0a, 0x06, 0x43, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12,
        0x5d, 0x0a, 0x12, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x43, 0x69, 0x74, 0x69, 0x65, 0x73, 0x42,
        0x79, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x21, 0x2e, 0x63, 0x69, 0x74, 0x69, 0x65, 0x73, 0x2e, 0x53,
        0x65, 0x61, 0x72, 0x63, 0x68, 0x43, 0x69, 0x74, 0x69, 0x65, 0x73, 0x42, 0x79, 0x4e, 0x61, 0x6d,
        0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x63, 0x69, 0x74, 0x69, 0x65,
        0x73, 0x2e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x43, 0x69, 0x74, 0x69, 0x65, 0x73, 0x42, 0x79,
        0x4e, 0x61, 0x6d, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x51,
        0x0a, 0x0e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x43, 0x69, 0x74, 0x79, 0x42, 0x79, 0x49, 0x44,
        0x12, 0x1d, 0x2e, 0x63, 0x69, 0x74, 0x69, 0x65, 0x73, 0x2e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,
        0x43, 0x69, 0x74, 0x79, 0x42, 0x79, 0x49, 0x44, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x1e, 0x2e, 0x63, 0x69, 0x74, 0x69, 0x65, 0x73, 0x2e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x43,
        0x69, 0x74, 0x79, 0x42, 0x79, 0x49, 0x44, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
        0x00, 0x42, 0x07, 0x5a, 0x05, 0x2e, 0x3b, 0x67, 0x65, 0x6e, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x33,
}

var (
        file_proto_cities_proto_rawDescOnce sync.Once
        file_proto_cities_proto_rawDescData = file_proto_cities_proto_rawDesc
)

func file_proto_cities_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_cities_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_cities_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_cities_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_proto_cities_proto_rawDescData</span>
}

var file_proto_cities_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_proto_cities_proto_goTypes = []any{
        (*City)(nil),                       // 0: cities.City
        (*SearchCitiesByNameRequest)(nil),  // 1: cities.SearchCitiesByNameRequest
        (*SearchCitiesByNameResponse)(nil), // 2: cities.SearchCitiesByNameResponse
        (*SearchCityByIDRequest)(nil),      // 3: cities.SearchCityByIDRequest
        (*SearchCityByIDResponse)(nil),     // 4: cities.SearchCityByIDResponse
}
var file_proto_cities_proto_depIdxs = []int32{
        0, // 0: cities.SearchCitiesByNameResponse.cities:type_name -&gt; cities.City
        0, // 1: cities.SearchCityByIDResponse.city:type_name -&gt; cities.City
        1, // 2: cities.Cities.SearchCitiesByName:input_type -&gt; cities.SearchCitiesByNameRequest
        3, // 3: cities.Cities.SearchCityByID:input_type -&gt; cities.SearchCityByIDRequest
        2, // 4: cities.Cities.SearchCitiesByName:output_type -&gt; cities.SearchCitiesByNameResponse
        4, // 5: cities.Cities.SearchCityByID:output_type -&gt; cities.SearchCityByIDResponse
        4, // [4:6] is the sub-list for method output_type
        2, // [2:4] is the sub-list for method input_type
        2, // [2:2] is the sub-list for extension type_name
        2, // [2:2] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_proto_cities_proto_init() }</span>
func file_proto_cities_proto_init() <span class="cov0" title="0">{
        if File_proto_cities_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_proto_cities_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   5,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_cities_proto_goTypes,
                DependencyIndexes: file_proto_cities_proto_depIdxs,
                MessageInfos:      file_proto_cities_proto_msgTypes,
        }.Build()
        File_proto_cities_proto = out.File
        file_proto_cities_proto_rawDesc = nil
        file_proto_cities_proto_goTypes = nil
        file_proto_cities_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.0--rc2
// source: proto/cities.proto

package gen

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Cities_SearchCitiesByName_FullMethodName = "/cities.Cities/SearchCitiesByName"
        Cities_SearchCityByID_FullMethodName     = "/cities.Cities/SearchCityByID"
)

// CitiesClient is the client API for Cities service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CitiesClient interface {
        SearchCitiesByName(ctx context.Context, in *SearchCitiesByNameRequest, opts ...grpc.CallOption) (*SearchCitiesByNameResponse, error)
        SearchCityByID(ctx context.Context, in *SearchCityByIDRequest, opts ...grpc.CallOption) (*SearchCityByIDResponse, error)
}

type citiesClient struct {
        cc grpc.ClientConnInterface
}

func NewCitiesClient(cc grpc.ClientConnInterface) CitiesClient <span class="cov0" title="0">{
        return &amp;citiesClient{cc}
}</span>

func (c *citiesClient) SearchCitiesByName(ctx context.Context, in *SearchCitiesByNameRequest, opts ...grpc.CallOption) (*SearchCitiesByNameResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SearchCitiesByNameResponse)
        err := c.cc.Invoke(ctx, Cities_SearchCitiesByName_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *citiesClient) SearchCityByID(ctx context.Context, in *SearchCityByIDRequest, opts ...grpc.CallOption) (*SearchCityByIDResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SearchCityByIDResponse)
        err := c.cc.Invoke(ctx, Cities_SearchCityByID_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// CitiesServer is the server API for Cities service.
// All implementations must embed UnimplementedCitiesServer
// for forward compatibility.
type CitiesServer interface {
        SearchCitiesByName(context.Context, *SearchCitiesByNameRequest) (*SearchCitiesByNameResponse, error)
        SearchCityByID(context.Context, *SearchCityByIDRequest) (*SearchCityByIDResponse, error)
        mustEmbedUnimplementedCitiesServer()
}

// UnimplementedCitiesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCitiesServer struct{}

func (UnimplementedCitiesServer) SearchCitiesByName(context.Context, *SearchCitiesByNameRequest) (*SearchCitiesByNameResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SearchCitiesByName not implemented")
}</span>
func (UnimplementedCitiesServer) SearchCityByID(context.Context, *SearchCityByIDRequest) (*SearchCityByIDResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SearchCityByID not implemented")
}</span>
func (UnimplementedCitiesServer) mustEmbedUnimplementedCitiesServer() {<span class="cov0" title="0">}</span>
func (UnimplementedCitiesServer) testEmbeddedByValue()                {<span class="cov0" title="0">}</span>

// UnsafeCitiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CitiesServer will
// result in compilation errors.
type UnsafeCitiesServer interface {
        mustEmbedUnimplementedCitiesServer()
}

func RegisterCitiesServer(s grpc.ServiceRegistrar, srv CitiesServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedCitiesServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Cities_ServiceDesc, srv)</span>
}

func _Cities_SearchCitiesByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SearchCitiesByNameRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CitiesServer).SearchCitiesByName(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Cities_SearchCitiesByName_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(CitiesServer).SearchCitiesByName(ctx, req.(*SearchCitiesByNameRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Cities_SearchCityByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SearchCityByIDRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CitiesServer).SearchCityByID(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Cities_SearchCityByID_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(CitiesServer).SearchCityByID(ctx, req.(*SearchCityByIDRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Cities_ServiceDesc is the grpc.ServiceDesc for Cities service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Cities_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "cities.Cities",
        HandlerType: (*CitiesServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "SearchCitiesByName",
                        Handler:    _Cities_SearchCitiesByName_Handler,
                },
                {
                        MethodName: "SearchCityByID",
                        Handler:    _Cities_SearchCityByID_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/cities.proto",
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package grpc

import (
        "2024_2_ThereWillBeName/internal/pkg/cities"
        "2024_2_ThereWillBeName/internal/pkg/cities/delivery/grpc/gen"
        "context"
)

//go:generate protoc -I . proto/cities.proto --go_out=./gen --go-grpc_out=./gen

type GrpcCitiesHandler struct {
        gen.UnimplementedCitiesServer
        uc cities.CitiesUsecase
}

func NewGrpcCitiesHandler(uc cities.CitiesUsecase) *GrpcCitiesHandler <span class="cov0" title="0">{
        return &amp;GrpcCitiesHandler{uc: uc}
}</span>

func (s *GrpcCitiesHandler) SearchCitiesByName(ctx context.Context, req *gen.SearchCitiesByNameRequest) (*gen.SearchCitiesByNameResponse, error) <span class="cov0" title="0">{
        cities, err := s.uc.SearchCitiesByName(ctx, req.Query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">citiesResponse := make([]*gen.City, len(cities))
        for i, city := range cities </span><span class="cov0" title="0">{
                citiesResponse[i] = &amp;gen.City{
                        Id:   uint32(city.ID),
                        Name: city.Name,
                }
        }</span>
        <span class="cov0" title="0">return &amp;gen.SearchCitiesByNameResponse{Cities: citiesResponse}, nil</span>
}

func (s *GrpcCitiesHandler) SearchCityByID(ctx context.Context, req *gen.SearchCityByIDRequest) (*gen.SearchCityByIDResponse, error) <span class="cov0" title="0">{
        city, err := s.uc.SearchCityByID(ctx, uint(req.Id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;gen.SearchCityByIDResponse{City: &amp;gen.City{Id: uint32(city.ID), Name: city.Name}}, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package http

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/cities/delivery/grpc/gen"
        httpresponse "2024_2_ThereWillBeName/internal/pkg/httpresponses"
        log "2024_2_ThereWillBeName/internal/pkg/logger"
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
)

type CitiesHandler struct {
        client gen.CitiesClient
        logger *slog.Logger
}

func NewCitiesHandler(client gen.CitiesClient, logger *slog.Logger) *CitiesHandler <span class="cov0" title="0">{
        return &amp;CitiesHandler{client, logger}
}</span>

func ErrorCheck(err error, action string, logger *slog.Logger, ctx context.Context) (httpresponse.ErrorResponse, int) <span class="cov0" title="0">{
        if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                logContext := log.AppendCtx(ctx, slog.String("action", action))
                logger.ErrorContext(logContext, fmt.Sprintf("Error during %s operation", action), slog.Any("error", err.Error()))

                response := httpresponse.ErrorResponse{
                        Message: "Invalid request",
                }
                return response, http.StatusNotFound
        }</span>
        <span class="cov0" title="0">logContext := log.AppendCtx(ctx, slog.String("action", action))
        logger.ErrorContext(logContext, fmt.Sprintf("Failed to %s cities", action), slog.Any("error", err.Error()))

        response := httpresponse.ErrorResponse{
                Message: fmt.Sprintf("Failed to %s cities", action),
        }
        return response, http.StatusInternalServerError</span>
}

// SearchCitiesByNameHandler godoc
// @Summary Retrieve cities by name
// @Description Get cities details by city name
// @Produce json
// @Success 200 {array} models.City "Cities details"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid query"
// @Failure 403 {object} httpresponses.ErrorResponse "Token is missing"
// @Failure 403 {object} httpresponses.ErrorResponse "Invalid token"
// @Failure 404 {object} httpresponses.ErrorResponse "Cities not found"
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to retrieve cities"
// @Router /cities/search [get]
func (h *CitiesHandler) SearchCitiesByNameHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query().Get("q")

        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for searching attractions by name", slog.String("name", query))

        if query == "" </span><span class="cov0" title="0">{
                h.logger.Error("Search query parameter is empty")
                response := httpresponse.ErrorResponse{
                        Message: "Invalid query",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">cities, err := h.client.SearchCitiesByName(context.Background(), &amp;gen.SearchCitiesByNameRequest{Query: query})
        if err != nil </span><span class="cov0" title="0">{
                logCtx := log.AppendCtx(context.Background(), slog.String("name", query))
                response, status := ErrorCheck(err, "retrieve", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully retrieved cities")
        httpresponse.SendJSONResponse(w, cities.Cities, http.StatusOK, h.logger)</span>
}

// SearchCityByIDHandler godoc
// @Summary Retrieve a city by ID
// @Description Get city details by city ID
// @Produce json
// @Param id path int true "City ID"
// @Success 200 {object} models.City "City details"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid city ID"
// @Failure 403 {object} httpresponses.ErrorResponse "CSRF token missing"
// @Failure 403 {object} httpresponses.ErrorResponse "Invalid CSRF token"
// @Failure 404 {object} httpresponses.ErrorResponse "City not found"
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to retrieve cities"
// @Router /cities/{id} [get]
func (h *CitiesHandler) SearchCityByIDHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        cityIDStr := vars["id"]

        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for searching cities by ID", slog.String("ID", cityIDStr))

        if cityIDStr == "" </span><span class="cov0" title="0">{
                h.logger.Error("Search ID parameter is empty")

                response := httpresponse.ErrorResponse{
                        Message: "Invalid city ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">cityID, err := strconv.ParseUint(cityIDStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid city ID")
                response := httpresponse.ErrorResponse{
                        Message: "Invalid city ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">city, err := h.client.SearchCityByID(context.Background(), &amp;gen.SearchCityByIDRequest{Id: uint32(cityID)})
        if err != nil </span><span class="cov0" title="0">{
                logCtx := log.AppendCtx(context.Background(), slog.Uint64("ID", (cityID)))
                response, status := ErrorCheck(err, "retrieve", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully retrieved cities")

        httpresponse.SendJSONResponse(w, city.City, http.StatusOK, h.logger)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repo

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/dblogger"

        "context"
        "database/sql"
        "errors"
        "fmt"
)

type CitiesRepository struct {
        db *dblogger.DB
}

func NewCitiesRepository(db *dblogger.DB) *CitiesRepository <span class="cov0" title="0">{
        return &amp;CitiesRepository{db: db}
}</span>

func (r *CitiesRepository) SearchCitiesByName(ctx context.Context, query string) ([]models.City, error) <span class="cov0" title="0">{
        var cities []models.City

        searchQuery := `SELECT id, name, created_at FROM city WHERE name ILIKE $1`

        rows, err := r.db.QueryContext(ctx, searchQuery, query+"%")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search cities: %w", models.ErrInternal)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var city models.City
                err := rows.Scan(&amp;city.ID, &amp;city.Name, &amp;city.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan city row: %w", models.ErrInternal)
                }</span>
                <span class="cov0" title="0">cities = append(cities, city)</span>
        }

        <span class="cov0" title="0">if len(cities) == 0 </span><span class="cov0" title="0">{
                return nil, models.ErrNotFound
        }</span>

        <span class="cov0" title="0">return cities, nil</span>
}

func (r *CitiesRepository) SearchCityByID(ctx context.Context, id uint) (models.City, error) <span class="cov0" title="0">{
        var city models.City

        query := `SELECT id, name, created_at FROM city WHERE id = $1`
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;city.ID, &amp;city.Name, &amp;city.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return city, models.ErrNotFound
                }</span>
                <span class="cov0" title="0">return city, fmt.Errorf("failed to retrieve city: %w", models.ErrInternal)</span>
        }

        <span class="cov0" title="0">return city, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package usecase

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/cities"
        "context"
        "errors"
        "fmt"
)

type CitiesUsecaseImpl struct {
        citiesRepo cities.CitiesRepo
}

func NewCitiesUsecase(repo cities.CitiesRepo) *CitiesUsecaseImpl <span class="cov0" title="0">{
        return &amp;CitiesUsecaseImpl{
                citiesRepo: repo,
        }
}</span>

func (u *CitiesUsecaseImpl) SearchCitiesByName(ctx context.Context, query string) ([]models.City, error) <span class="cov0" title="0">{
        citiesFound, err := u.citiesRepo.SearchCitiesByName(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not find cities: %w", models.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }
        <span class="cov0" title="0">return citiesFound, nil</span>
}

func (u *CitiesUsecaseImpl) SearchCityByID(ctx context.Context, id uint) (models.City, error) <span class="cov0" title="0">{
        city, err := u.citiesRepo.SearchCityByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        return models.City{}, fmt.Errorf("could not find city: %w", models.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return models.City{}, fmt.Errorf("internal error^ %w", models.ErrInternal)</span>

        }
        <span class="cov0" title="0">return city, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package dblogger

import (
        "context"
        "database/sql"
        "log/slog"
        "time"
)

type DB struct {
        db     *sql.DB
        logger *slog.Logger
}

func NewDB(db *sql.DB, logger *slog.Logger) *DB <span class="cov8" title="1">{
        return &amp;DB{
                db:     db,
                logger: logger,
        }
}</span>

func (d *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{
        start := time.Now()
        rows, err := d.db.QueryContext(ctx, query, args...)
        duration := time.Since(start)

        d.logger.DebugContext(ctx, "Executing QueryContext",
                slog.String("query", query),
                slog.Any("args", args),
                slog.Duration("duration", duration),
                slog.String("error", errToString(err)),
        )

        return rows, err
}</span>

func (d *DB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="1">{
        start := time.Now()
        result, err := d.db.ExecContext(ctx, query, args...)
        duration := time.Since(start)

        d.logger.DebugContext(ctx, "Executing ExecContext",
                slog.String("query", query),
                slog.Any("args", args),
                slog.Duration("duration", duration),
                slog.String("error", errToString(err)),
        )

        return result, err
}</span>

func (d *DB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{
        start := time.Now()
        row := d.db.QueryRowContext(ctx, query, args...)
        duration := time.Since(start)

        d.logger.DebugContext(ctx, "Executing QueryRowContext",
                slog.String("query", query),
                slog.Any("args", args),
                slog.Duration("duration", duration),
        )

        return row
}</span>

func (d *DB) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        start := time.Now()
        stmt, err := d.db.PrepareContext(ctx, query)
        duration := time.Since(start)

        d.logger.DebugContext(ctx, "Preparing statement",
                slog.String("query", query),
                slog.Duration("duration", duration),
                slog.String("error", errToString(err)),
        )

        return stmt, err
}</span>

func (d *DB) Close() error <span class="cov0" title="0">{
        return d.db.Close()
}</span>

func errToString(err error) string <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                return err.Error()
        }</span>
        <span class="cov8" title="1">return "nil"</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package httpresponses

import (
        "encoding/json"
        "log/slog"
        "net/http"
)

type ErrorResponse struct {
        Message string `json:"message"`
}

func SendJSONResponse(w http.ResponseWriter, data interface{}, status int, logger *slog.Logger) <span class="cov8" title="1">{
        w.WriteHeader(status)

        if data == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to encode response to JSON", slog.Any("error", err.Error()))

                http.Error(w, "Failed to convert to json", http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package jwt

import (
        "fmt"
        "log/slog"
        "time"

        "github.com/dgrijalva/jwt-go"
)

type JWT struct {
        secret []byte
        logger *slog.Logger
}

func NewJWT(secret string, logger *slog.Logger) *JWT <span class="cov0" title="0">{
        return &amp;JWT{
                secret: []byte(secret),
                logger: logger,
        }

}</span>

func (j *JWT) GenerateToken(userID uint, email, login string) (string, error) <span class="cov0" title="0">{
        claims := jwt.MapClaims{
                "userID": userID,
                "email":  email,
                "login":  login,
                "exp":    time.Now().Add(time.Hour * 24).Unix(),
        }

        j.logger.Debug("checking claims", "claims:", claims)
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(j.secret)
}</span>

func (j *JWT) ParseToken(token string) (map[string]interface{}, error) <span class="cov0" title="0">{
        parsedToken, err := jwt.Parse(token, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return j.secret, nil</span>
        })

        <span class="cov0" title="0">if claims, ok := parsedToken.Claims.(jwt.MapClaims); ok &amp;&amp; parsedToken.Valid </span><span class="cov0" title="0">{
                j.logger.Debug("from Generate token", "JWT_claims", claims)
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, err</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/pkg/jwt/interfaces.go

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockJWTInterface is a mock of JWTInterface interface.
type MockJWTInterface struct {
        ctrl     *gomock.Controller
        recorder *MockJWTInterfaceMockRecorder
}

// MockJWTInterfaceMockRecorder is the mock recorder for MockJWTInterface.
type MockJWTInterfaceMockRecorder struct {
        mock *MockJWTInterface
}

// NewMockJWTInterface creates a new mock instance.
func NewMockJWTInterface(ctrl *gomock.Controller) *MockJWTInterface <span class="cov0" title="0">{
        mock := &amp;MockJWTInterface{ctrl: ctrl}
        mock.recorder = &amp;MockJWTInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJWTInterface) EXPECT() *MockJWTInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GenerateToken mocks base method.
func (m *MockJWTInterface) GenerateToken(userID uint, email, login string) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GenerateToken", userID, email, login)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GenerateToken indicates an expected call of GenerateToken.
func (mr *MockJWTInterfaceMockRecorder) GenerateToken(userID, email, login interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateToken", reflect.TypeOf((*MockJWTInterface)(nil).GenerateToken), userID, email, login)
}</span>

// ParseToken mocks base method.
func (m *MockJWTInterface) ParseToken(token string) (map[string]interface{}, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ParseToken", token)
        ret0, _ := ret[0].(map[string]interface{})
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ParseToken indicates an expected call of ParseToken.
func (mr *MockJWTInterfaceMockRecorder) ParseToken(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParseToken", reflect.TypeOf((*MockJWTInterface)(nil).ParseToken), token)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package logger

import (
        "context"
        "encoding/json"
        "github.com/fatih/color"
        "io"
        "log"
        "log/slog"
)

type ctxKey string

const (
        slogFields ctxKey = "slog_fields"
)

type PrettyHandlerOptions struct {
        SlogOpts slog.HandlerOptions
}

type PrettyHandler struct {
        slog.Handler
        l *log.Logger
}

func (h *PrettyHandler) Handle(ctx context.Context, r slog.Record) error <span class="cov0" title="0">{
        if attrs, ok := ctx.Value(slogFields).([]slog.Attr); ok </span><span class="cov0" title="0">{
                for _, v := range attrs </span><span class="cov0" title="0">{
                        r.AddAttrs(v)
                }</span>
        }

        <span class="cov0" title="0">level := r.Level.String() + ":"

        switch r.Level </span>{
        case slog.LevelDebug:<span class="cov0" title="0">
                level = color.MagentaString(level)</span>
        case slog.LevelInfo:<span class="cov0" title="0">
                level = color.BlueString(level)</span>
        case slog.LevelWarn:<span class="cov0" title="0">
                level = color.YellowString(level)</span>
        case slog.LevelError:<span class="cov0" title="0">
                level = color.RedString(level)</span>
        }

        <span class="cov0" title="0">fields := make(map[string]interface{}, r.NumAttrs())
        r.Attrs(func(a slog.Attr) bool </span><span class="cov0" title="0">{
                fields[a.Key] = a.Value.Any()

                return true
        }</span>)

        // Подготовка записи лога в формате JSON
        // logEntry := map[string]interface{}{
        //         "time":    r.Time.Format("2006-01-02 15:04:05"),
        //         "level":   r.Level.String(),
        //         "message": r.Message,
        //         "fields":  fields,
        // }
        <span class="cov0" title="0">b, err := json.MarshalIndent(fields, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">timeStr := r.Time.Format("2006-01-02 15:04:05")

        msg := color.CyanString(r.Message)

        h.l.Println(timeStr, level, msg, string(b))

        return nil</span>
}

func NewPrettyHandler(out io.Writer, opts PrettyHandlerOptions) *PrettyHandler <span class="cov0" title="0">{
        h := &amp;PrettyHandler{
                Handler: slog.NewJSONHandler(out, &amp;opts.SlogOpts), // Используем JSON обработчик
                l:       log.New(out, "", 0),
        }

        return h
}</span>

func AppendCtx(parent context.Context, attr slog.Attr) context.Context <span class="cov8" title="1">{
        if parent == nil </span><span class="cov0" title="0">{
                parent = context.Background()
        }</span>

        <span class="cov8" title="1">if v, ok := parent.Value(slogFields).([]slog.Attr); ok </span><span class="cov8" title="1">{
                v = append(v, attr)
                return context.WithValue(parent, slogFields, v)
        }</span>

        <span class="cov8" title="1">v := []slog.Attr{}
        v = append(v, attr)
        return context.WithValue(parent, slogFields, v)</span>
}

func LogRequestStart(ctx context.Context, method, uri string) context.Context <span class="cov8" title="1">{
        logCtx := context.Background()
        logCtx = AppendCtx(logCtx, slog.String("method", method))
        logCtx = AppendCtx(logCtx, slog.String("uri", uri))
        return logCtx
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
)

type PrometheusMetrics struct {
        hits      *prometheus.CounterVec
        errors    *prometheus.CounterVec
        durations *prometheus.HistogramVec
}

func NewPrometheusMetrics() *PrometheusMetrics <span class="cov0" title="0">{
        hits := prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "grpc_method_hits_total",
                        Help: "Total number of gRPC method calls.",
                },
                []string{"method"},
        )
        errors := prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "grpc_method_errors_total",
                        Help: "Total number of gRPC method errors.",
                },
                []string{"method"},
        )
        durations := prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "grpc_method_duration_seconds",
                        Help:    "Histogram of gRPC method call durations.",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method"},
        )

        prometheus.MustRegister(hits, errors, durations)

        return &amp;PrometheusMetrics{
                hits:      hits,
                errors:    errors,
                durations: durations,
        }
}</span>

func (m *PrometheusMetrics) IncreaseHits(method string) <span class="cov0" title="0">{
        m.hits.WithLabelValues(method).Inc()
}</span>

func (m *PrometheusMetrics) IncreaseErr(method string) <span class="cov0" title="0">{
        m.errors.WithLabelValues(method).Inc()
}</span>

func (m *PrometheusMetrics) AddDurationToHistogram(method string, duration time.Duration) <span class="cov0" title="0">{
        m.durations.WithLabelValues(method).Observe(duration.Seconds())
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package middleware

import "net/http"

type CORSMiddleware struct {
        AllowedOrigins []string
}

func NewCORSMiddleware(allowedOrigins []string) *CORSMiddleware <span class="cov0" title="0">{
        return &amp;CORSMiddleware{
                AllowedOrigins: allowedOrigins,
        }
}</span>
func (c *CORSMiddleware) CorsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Methods", "POST,PUT,DELETE,GET")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
                w.Header().Set("Access-Control-Allow-Credentials", "true")
                if len(c.AllowedOrigins) &gt; 0 </span><span class="cov0" title="0">{
                        w.Header().Set("Access-Control-Allow-Origin", c.AllowedOrigins[0])
                }</span>
                <span class="cov0" title="0">if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        },
        )
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package middleware

import (
        "context"
        "time"

        "google.golang.org/grpc"
)

type MetricsInterface interface {
        IncreaseHits(method string)
        IncreaseErr(method string)
        AddDurationToHistogram(method string, duration time.Duration)
}

type GrpcMiddleware struct {
        metrics MetricsInterface
}

func NewGrpcMiddleware(metrics MetricsInterface) *GrpcMiddleware <span class="cov0" title="0">{
        return &amp;GrpcMiddleware{
                metrics: metrics,
        }
}</span>
func (m *GrpcMiddleware) ServerMetricsInterceptor(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
) (interface{}, error) <span class="cov0" title="0">{
        start := time.Now()

        resp, err := handler(ctx, req)

        duration := time.Since(start)

        m.metrics.IncreaseHits(info.FullMethod)

        if err != nil </span><span class="cov0" title="0">{
                m.metrics.IncreaseErr(info.FullMethod)
        }</span>
        <span class="cov0" title="0">m.metrics.AddDurationToHistogram(info.FullMethod, duration)

        return resp, err</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package middleware

import (
        log "2024_2_ThereWillBeName/internal/pkg/logger"
        "log/slog"
        "net/http"
        "time"

        "github.com/google/uuid"
)

const (
        RequestIDKey contextKey = "request_id"
        MethodKey    contextKey = "method"
        PathKey      contextKey = "path"
)

type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

func RequestLoggerMiddleware(logger *slog.Logger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        requestID := uuid.New().String()

                        logCtx := r.Context()
                        logCtx = log.AppendCtx(logCtx, slog.String("request_id", requestID))
                        logCtx = log.AppendCtx(logCtx, slog.String("method", r.Method))
                        logCtx = log.AppendCtx(logCtx, slog.String("path", r.URL.Path))
                        r = r.WithContext(logCtx)

                        startTime := time.Now()
                        logger.Info("Request started",
                                slog.String("request_id", requestID),
                                slog.String("method", r.Method),
                                slog.String("path", r.URL.Path),
                                slog.Time("start_time", startTime),
                        )

                        rw := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                        next.ServeHTTP(rw, r)

                        duration := time.Since(startTime)

                        logger.Info("Request completed",
                                slog.String("request_id", requestID),
                                slog.String("method", r.Method),
                                slog.String("path", r.URL.Path),
                                slog.Int("status_code", rw.statusCode),
                                slog.Duration("duration", duration),
                        )
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package middleware

import (
        httpresponse "2024_2_ThereWillBeName/internal/pkg/httpresponses"
        "2024_2_ThereWillBeName/internal/pkg/jwt"
        log "2024_2_ThereWillBeName/internal/pkg/logger"
        "context"
        "log/slog"
        "net/http"
        "strconv"
)

type contextKey string

const (
        IdKey    contextKey = "userID"
        LoginKey contextKey = "login"
        EmailKey contextKey = "email"
)

func MiddlewareAuth(jwtService jwt.JWTInterface, next http.Handler, logger *slog.Logger) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                token := r.Header.Get("X-Access-Token")

                if token == "" </span><span class="cov0" title="0">{
                        response := httpresponse.ErrorResponse{
                                Message: "Token is missing",
                        }
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Error("Token is missing")
                        }</span>
                        <span class="cov0" title="0">httpresponse.SendJSONResponse(w, response, http.StatusForbidden, logger)
                        return</span>
                }
                <span class="cov0" title="0">claims, err := jwtService.ParseToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        response := httpresponse.ErrorResponse{
                                Message: "Invalid token",
                        }

                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Error("Invalid token", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, logger)
                        return</span>
                }
                <span class="cov0" title="0">userID := uint(claims["userID"].(float64))
                login := claims["login"].(string)
                email := claims["email"].(string)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Debug("Token parsed", slog.Int("userID", int(userID)), slog.String("login", login), slog.String("email", email))
                }</span>
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), IdKey, userID)
                ctx = context.WithValue(ctx, LoginKey, login)
                ctx = context.WithValue(ctx, EmailKey, email)
                ctx = log.AppendCtx(ctx, slog.String("user_id", strconv.FormatUint(uint64(userID), 10)))

                r = r.WithContext(ctx)

                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v5.29.0--rc2
// source: proto/reviews.proto

package gen

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Review struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id         uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        UserId     uint32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        PlaceId    uint32 `protobuf:"varint,3,opt,name=place_id,json=placeId,proto3" json:"place_id,omitempty"`
        Rating     int32  `protobuf:"varint,4,opt,name=rating,proto3" json:"rating,omitempty"`
        ReviewText string `protobuf:"bytes,5,opt,name=review_text,json=reviewText,proto3" json:"review_text,omitempty"`
}

func (x *Review) Reset() <span class="cov0" title="0">{
        *x = Review{}
        mi := &amp;file_proto_reviews_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Review) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Review) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Review) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Review.ProtoReflect.Descriptor instead.
func (*Review) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Review) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Review) GetUserId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Review) GetPlaceId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlaceId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Review) GetRating() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Review) GetReviewText() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReviewText
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetReview struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id         uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        UserLogin  string `protobuf:"bytes,2,opt,name=user_login,json=userLogin,proto3" json:"user_login,omitempty"`
        AvatarPath string `protobuf:"bytes,3,opt,name=avatar_path,json=avatarPath,proto3" json:"avatar_path,omitempty"`
        Rating     int32  `protobuf:"varint,4,opt,name=rating,proto3" json:"rating,omitempty"`
        ReviewText string `protobuf:"bytes,5,opt,name=review_text,json=reviewText,proto3" json:"review_text,omitempty"`
}

func (x *GetReview) Reset() <span class="cov0" title="0">{
        *x = GetReview{}
        mi := &amp;file_proto_reviews_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetReview) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetReview) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetReview) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetReview.ProtoReflect.Descriptor instead.
func (*GetReview) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetReview) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetReview) GetUserLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserLogin
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetReview) GetAvatarPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvatarPath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetReview) GetRating() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetReview) GetReviewText() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReviewText
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetReviewByUserID struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id         uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        PlaceName  string `protobuf:"bytes,2,opt,name=place_name,json=placeName,proto3" json:"place_name,omitempty"`
        Rating     int32  `protobuf:"varint,3,opt,name=rating,proto3" json:"rating,omitempty"`
        ReviewText string `protobuf:"bytes,4,opt,name=review_text,json=reviewText,proto3" json:"review_text,omitempty"`
}

func (x *GetReviewByUserID) Reset() <span class="cov0" title="0">{
        *x = GetReviewByUserID{}
        mi := &amp;file_proto_reviews_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetReviewByUserID) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetReviewByUserID) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetReviewByUserID) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetReviewByUserID.ProtoReflect.Descriptor instead.
func (*GetReviewByUserID) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetReviewByUserID) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetReviewByUserID) GetPlaceName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlaceName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetReviewByUserID) GetRating() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetReviewByUserID) GetReviewText() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReviewText
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CreateReviewRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Review *Review `protobuf:"bytes,1,opt,name=review,proto3" json:"review,omitempty"`
}

func (x *CreateReviewRequest) Reset() <span class="cov0" title="0">{
        *x = CreateReviewRequest{}
        mi := &amp;file_proto_reviews_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateReviewRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateReviewRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateReviewRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateReviewRequest.ProtoReflect.Descriptor instead.
func (*CreateReviewRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{3}
}</span>

func (x *CreateReviewRequest) GetReview() *Review <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Review
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateReviewResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Review *GetReview `protobuf:"bytes,1,opt,name=review,proto3" json:"review,omitempty"`
}

func (x *CreateReviewResponse) Reset() <span class="cov0" title="0">{
        *x = CreateReviewResponse{}
        mi := &amp;file_proto_reviews_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateReviewResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateReviewResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateReviewResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateReviewResponse.ProtoReflect.Descriptor instead.
func (*CreateReviewResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{4}
}</span>

func (x *CreateReviewResponse) GetReview() *GetReview <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Review
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateReviewRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Review *Review `protobuf:"bytes,1,opt,name=review,proto3" json:"review,omitempty"`
}

func (x *UpdateReviewRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateReviewRequest{}
        mi := &amp;file_proto_reviews_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateReviewRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateReviewRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateReviewRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateReviewRequest.ProtoReflect.Descriptor instead.
func (*UpdateReviewRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{5}
}</span>

func (x *UpdateReviewRequest) GetReview() *Review <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Review
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateReviewResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (x *UpdateReviewResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateReviewResponse{}
        mi := &amp;file_proto_reviews_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateReviewResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateReviewResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateReviewResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateReviewResponse.ProtoReflect.Descriptor instead.
func (*UpdateReviewResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{6}
}</span>

func (x *UpdateReviewResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

type DeleteReviewRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *DeleteReviewRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteReviewRequest{}
        mi := &amp;file_proto_reviews_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteReviewRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteReviewRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteReviewRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteReviewRequest.ProtoReflect.Descriptor instead.
func (*DeleteReviewRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{7}
}</span>

func (x *DeleteReviewRequest) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DeleteReviewResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (x *DeleteReviewResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteReviewResponse{}
        mi := &amp;file_proto_reviews_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteReviewResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteReviewResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteReviewResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteReviewResponse.ProtoReflect.Descriptor instead.
func (*DeleteReviewResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{8}
}</span>

func (x *DeleteReviewResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

type GetReviewsByPlaceIDRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        PlaceId uint32 `protobuf:"varint,1,opt,name=place_id,json=placeId,proto3" json:"place_id,omitempty"`
        Limit   int32  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset  int32  `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *GetReviewsByPlaceIDRequest) Reset() <span class="cov0" title="0">{
        *x = GetReviewsByPlaceIDRequest{}
        mi := &amp;file_proto_reviews_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetReviewsByPlaceIDRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetReviewsByPlaceIDRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetReviewsByPlaceIDRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetReviewsByPlaceIDRequest.ProtoReflect.Descriptor instead.
func (*GetReviewsByPlaceIDRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetReviewsByPlaceIDRequest) GetPlaceId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlaceId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetReviewsByPlaceIDRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetReviewsByPlaceIDRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetReviewsByPlaceIDResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Reviews []*GetReview `protobuf:"bytes,1,rep,name=reviews,proto3" json:"reviews,omitempty"`
}

func (x *GetReviewsByPlaceIDResponse) Reset() <span class="cov0" title="0">{
        *x = GetReviewsByPlaceIDResponse{}
        mi := &amp;file_proto_reviews_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetReviewsByPlaceIDResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetReviewsByPlaceIDResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetReviewsByPlaceIDResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetReviewsByPlaceIDResponse.ProtoReflect.Descriptor instead.
func (*GetReviewsByPlaceIDResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{10}
}</span>

func (x *GetReviewsByPlaceIDResponse) GetReviews() []*GetReview <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reviews
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetReviewsByUserIDRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId uint32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Limit  int32  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset int32  `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *GetReviewsByUserIDRequest) Reset() <span class="cov0" title="0">{
        *x = GetReviewsByUserIDRequest{}
        mi := &amp;file_proto_reviews_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetReviewsByUserIDRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetReviewsByUserIDRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetReviewsByUserIDRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetReviewsByUserIDRequest.ProtoReflect.Descriptor instead.
func (*GetReviewsByUserIDRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{11}
}</span>

func (x *GetReviewsByUserIDRequest) GetUserId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetReviewsByUserIDRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetReviewsByUserIDRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetReviewsByUserIDResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Reviews []*GetReviewByUserID `protobuf:"bytes,1,rep,name=reviews,proto3" json:"reviews,omitempty"`
}

func (x *GetReviewsByUserIDResponse) Reset() <span class="cov0" title="0">{
        *x = GetReviewsByUserIDResponse{}
        mi := &amp;file_proto_reviews_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetReviewsByUserIDResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetReviewsByUserIDResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetReviewsByUserIDResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetReviewsByUserIDResponse.ProtoReflect.Descriptor instead.
func (*GetReviewsByUserIDResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{12}
}</span>

func (x *GetReviewsByUserIDResponse) GetReviews() []*GetReviewByUserID <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reviews
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetReviewRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *GetReviewRequest) Reset() <span class="cov0" title="0">{
        *x = GetReviewRequest{}
        mi := &amp;file_proto_reviews_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetReviewRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetReviewRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetReviewRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetReviewRequest.ProtoReflect.Descriptor instead.
func (*GetReviewRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{13}
}</span>

func (x *GetReviewRequest) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetReviewResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Review *GetReview `protobuf:"bytes,1,opt,name=review,proto3" json:"review,omitempty"`
}

func (x *GetReviewResponse) Reset() <span class="cov0" title="0">{
        *x = GetReviewResponse{}
        mi := &amp;file_proto_reviews_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetReviewResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetReviewResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetReviewResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_reviews_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetReviewResponse.ProtoReflect.Descriptor instead.
func (*GetReviewResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_reviews_proto_rawDescGZIP(), []int{14}
}</span>

func (x *GetReviewResponse) GetReview() *GetReview <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Review
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_proto_reviews_proto protoreflect.FileDescriptor

var file_proto_reviews_proto_rawDesc = []byte{
        0x0a, 0x13, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x07, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x22, 0x85,
        0x01, 0x0a, 0x06, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65,
        0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72,
        0x49, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x49, 0x64, 0x12, 0x16, 0x0a,
        0x06, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x72,
        0x61, 0x74, 0x69, 0x6e, 0x67, 0x12, 0x1f, 0x0a, 0x0b, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x5f,
        0x74, 0x65, 0x78, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x72, 0x65, 0x76, 0x69,
        0x65, 0x77, 0x54, 0x65, 0x78, 0x74, 0x22, 0x94, 0x01, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x52, 0x65,
        0x76, 0x69, 0x65, 0x77, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
        0x52, 0x02, 0x69, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x6c, 0x6f, 0x67,
        0x69, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x75, 0x73, 0x65, 0x72, 0x4c, 0x6f,
        0x67, 0x69, 0x6e, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x5f, 0x70, 0x61,
        0x74, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72,
        0x50, 0x61, 0x74, 0x68, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x12, 0x1f, 0x0a, 0x0b,
        0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x0a, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x54, 0x65, 0x78, 0x74, 0x22, 0x7b, 0x0a,
        0x11, 0x47, 0x65, 0x74, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72,
        0x49, 0x44, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02,
        0x69, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x4e, 0x61, 0x6d,
        0x65, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x05, 0x52, 0x06, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x12, 0x1f, 0x0a, 0x0b, 0x72, 0x65, 0x76,
        0x69, 0x65, 0x77, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a,
        0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x54, 0x65, 0x78, 0x74, 0x22, 0x3e, 0x0a, 0x13, 0x43, 0x72,
        0x65, 0x61, 0x74, 0x65, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x27, 0x0a, 0x06, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x0f, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x52, 0x65, 0x76, 0x69,
        0x65, 0x77, 0x52, 0x06, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x22, 0x42, 0x0a, 0x14, 0x43, 0x72,
        0x65, 0x61, 0x74, 0x65, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x2a, 0x0a, 0x06, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x12, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x47, 0x65, 0x74,
        0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x06, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x22, 0x3e,
        0x0a, 0x13, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x27, 0x0a, 0x06, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e,
        0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x06, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x22, 0x30,
        0x0a, 0x14, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73,
        0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73,
        0x22, 0x25, 0x0a, 0x13, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x22, 0x30, 0x0a, 0x14, 0x44, 0x65, 0x6c, 0x65, 0x74,
        0x65, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
        0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x22, 0x65, 0x0a, 0x1a, 0x47, 0x65, 0x74,
        0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x42, 0x79, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x49, 0x44,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x70, 0x6c, 0x61, 0x63, 0x65,
        0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x70, 0x6c, 0x61, 0x63, 0x65,
        0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73,
        0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74,
        0x22, 0x4b, 0x0a, 0x1b, 0x47, 0x65, 0x74, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x42, 0x79,
        0x50, 0x6c, 0x61, 0x63, 0x65, 0x49, 0x44, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x2c, 0x0a, 0x07, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x12, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x65,
        0x76, 0x69, 0x65, 0x77, 0x52, 0x07, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x22, 0x62, 0x0a,
        0x19, 0x47, 0x65, 0x74, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65,
        0x72, 0x49, 0x44, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73,
        0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x75, 0x73, 0x65,
        0x72, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66,
        0x73, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65,
        0x74, 0x22, 0x52, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x42,
        0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x34, 0x0a, 0x07, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x1a, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x65,
        0x76, 0x69, 0x65, 0x77, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x52, 0x07, 0x72, 0x65,
        0x76, 0x69, 0x65, 0x77, 0x73, 0x22, 0x22, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x52, 0x65, 0x76, 0x69,
        0x65, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x22, 0x3f, 0x0a, 0x11, 0x47, 0x65, 0x74,
        0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2a,
        0x0a, 0x06, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12,
        0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x65, 0x76, 0x69,
        0x65, 0x77, 0x52, 0x06, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x32, 0x81, 0x04, 0x0a, 0x07, 0x52,
        0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x12, 0x4d, 0x0a, 0x0c, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x12, 0x1c, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73,
        0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x43,
        0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4d, 0x0a, 0x0c, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52,
        0x65, 0x76, 0x69, 0x65, 0x77, 0x12, 0x1c, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e,
        0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x55, 0x70,
        0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x22, 0x00, 0x12, 0x4d, 0x0a, 0x0c, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65,
        0x76, 0x69, 0x65, 0x77, 0x12, 0x1c, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x44,
        0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x44, 0x65, 0x6c,
        0x65, 0x74, 0x65, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x22, 0x00, 0x12, 0x62, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77,
        0x73, 0x42, 0x79, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x49, 0x44, 0x12, 0x23, 0x2e, 0x72, 0x65, 0x76,
        0x69, 0x65, 0x77, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x42,
        0x79, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x49, 0x44, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x24, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x65, 0x76,
        0x69, 0x65, 0x77, 0x73, 0x42, 0x79, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x49, 0x44, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5f, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x52, 0x65,
        0x76, 0x69, 0x65, 0x77, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x12, 0x22, 0x2e,
        0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x65, 0x76, 0x69, 0x65,
        0x77, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x23, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x52,
        0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x44, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x52,
        0x65, 0x76, 0x69, 0x65, 0x77, 0x12, 0x19, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e,
        0x47, 0x65, 0x74, 0x52, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x1a, 0x2e, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x65,
        0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x07,
        0x5a, 0x05, 0x2e, 0x3b, 0x67, 0x65, 0x6e, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_proto_reviews_proto_rawDescOnce sync.Once
        file_proto_reviews_proto_rawDescData = file_proto_reviews_proto_rawDesc
)

func file_proto_reviews_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_reviews_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_reviews_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_reviews_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_proto_reviews_proto_rawDescData</span>
}

var file_proto_reviews_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_proto_reviews_proto_goTypes = []any{
        (*Review)(nil),                      // 0: reviews.Review
        (*GetReview)(nil),                   // 1: reviews.GetReview
        (*GetReviewByUserID)(nil),           // 2: reviews.GetReviewByUserID
        (*CreateReviewRequest)(nil),         // 3: reviews.CreateReviewRequest
        (*CreateReviewResponse)(nil),        // 4: reviews.CreateReviewResponse
        (*UpdateReviewRequest)(nil),         // 5: reviews.UpdateReviewRequest
        (*UpdateReviewResponse)(nil),        // 6: reviews.UpdateReviewResponse
        (*DeleteReviewRequest)(nil),         // 7: reviews.DeleteReviewRequest
        (*DeleteReviewResponse)(nil),        // 8: reviews.DeleteReviewResponse
        (*GetReviewsByPlaceIDRequest)(nil),  // 9: reviews.GetReviewsByPlaceIDRequest
        (*GetReviewsByPlaceIDResponse)(nil), // 10: reviews.GetReviewsByPlaceIDResponse
        (*GetReviewsByUserIDRequest)(nil),   // 11: reviews.GetReviewsByUserIDRequest
        (*GetReviewsByUserIDResponse)(nil),  // 12: reviews.GetReviewsByUserIDResponse
        (*GetReviewRequest)(nil),            // 13: reviews.GetReviewRequest
        (*GetReviewResponse)(nil),           // 14: reviews.GetReviewResponse
}
var file_proto_reviews_proto_depIdxs = []int32{
        0,  // 0: reviews.CreateReviewRequest.review:type_name -&gt; reviews.Review
        1,  // 1: reviews.CreateReviewResponse.review:type_name -&gt; reviews.GetReview
        0,  // 2: reviews.UpdateReviewRequest.review:type_name -&gt; reviews.Review
        1,  // 3: reviews.GetReviewsByPlaceIDResponse.reviews:type_name -&gt; reviews.GetReview
        2,  // 4: reviews.GetReviewsByUserIDResponse.reviews:type_name -&gt; reviews.GetReviewByUserID
        1,  // 5: reviews.GetReviewResponse.review:type_name -&gt; reviews.GetReview
        3,  // 6: reviews.Reviews.CreateReview:input_type -&gt; reviews.CreateReviewRequest
        5,  // 7: reviews.Reviews.UpdateReview:input_type -&gt; reviews.UpdateReviewRequest
        7,  // 8: reviews.Reviews.DeleteReview:input_type -&gt; reviews.DeleteReviewRequest
        9,  // 9: reviews.Reviews.GetReviewsByPlaceID:input_type -&gt; reviews.GetReviewsByPlaceIDRequest
        11, // 10: reviews.Reviews.GetReviewsByUserID:input_type -&gt; reviews.GetReviewsByUserIDRequest
        13, // 11: reviews.Reviews.GetReview:input_type -&gt; reviews.GetReviewRequest
        4,  // 12: reviews.Reviews.CreateReview:output_type -&gt; reviews.CreateReviewResponse
        6,  // 13: reviews.Reviews.UpdateReview:output_type -&gt; reviews.UpdateReviewResponse
        8,  // 14: reviews.Reviews.DeleteReview:output_type -&gt; reviews.DeleteReviewResponse
        10, // 15: reviews.Reviews.GetReviewsByPlaceID:output_type -&gt; reviews.GetReviewsByPlaceIDResponse
        12, // 16: reviews.Reviews.GetReviewsByUserID:output_type -&gt; reviews.GetReviewsByUserIDResponse
        14, // 17: reviews.Reviews.GetReview:output_type -&gt; reviews.GetReviewResponse
        12, // [12:18] is the sub-list for method output_type
        6,  // [6:12] is the sub-list for method input_type
        6,  // [6:6] is the sub-list for extension type_name
        6,  // [6:6] is the sub-list for extension extendee
        0,  // [0:6] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_proto_reviews_proto_init() }</span>
func file_proto_reviews_proto_init() <span class="cov0" title="0">{
        if File_proto_reviews_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_proto_reviews_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   15,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_reviews_proto_goTypes,
                DependencyIndexes: file_proto_reviews_proto_depIdxs,
                MessageInfos:      file_proto_reviews_proto_msgTypes,
        }.Build()
        File_proto_reviews_proto = out.File
        file_proto_reviews_proto_rawDesc = nil
        file_proto_reviews_proto_goTypes = nil
        file_proto_reviews_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.0--rc2
// source: proto/reviews.proto

package gen

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Reviews_CreateReview_FullMethodName        = "/reviews.Reviews/CreateReview"
        Reviews_UpdateReview_FullMethodName        = "/reviews.Reviews/UpdateReview"
        Reviews_DeleteReview_FullMethodName        = "/reviews.Reviews/DeleteReview"
        Reviews_GetReviewsByPlaceID_FullMethodName = "/reviews.Reviews/GetReviewsByPlaceID"
        Reviews_GetReviewsByUserID_FullMethodName  = "/reviews.Reviews/GetReviewsByUserID"
        Reviews_GetReview_FullMethodName           = "/reviews.Reviews/GetReview"
)

// ReviewsClient is the client API for Reviews service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReviewsClient interface {
        CreateReview(ctx context.Context, in *CreateReviewRequest, opts ...grpc.CallOption) (*CreateReviewResponse, error)
        UpdateReview(ctx context.Context, in *UpdateReviewRequest, opts ...grpc.CallOption) (*UpdateReviewResponse, error)
        DeleteReview(ctx context.Context, in *DeleteReviewRequest, opts ...grpc.CallOption) (*DeleteReviewResponse, error)
        GetReviewsByPlaceID(ctx context.Context, in *GetReviewsByPlaceIDRequest, opts ...grpc.CallOption) (*GetReviewsByPlaceIDResponse, error)
        GetReviewsByUserID(ctx context.Context, in *GetReviewsByUserIDRequest, opts ...grpc.CallOption) (*GetReviewsByUserIDResponse, error)
        GetReview(ctx context.Context, in *GetReviewRequest, opts ...grpc.CallOption) (*GetReviewResponse, error)
}

type reviewsClient struct {
        cc grpc.ClientConnInterface
}

func NewReviewsClient(cc grpc.ClientConnInterface) ReviewsClient <span class="cov0" title="0">{
        return &amp;reviewsClient{cc}
}</span>

func (c *reviewsClient) CreateReview(ctx context.Context, in *CreateReviewRequest, opts ...grpc.CallOption) (*CreateReviewResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateReviewResponse)
        err := c.cc.Invoke(ctx, Reviews_CreateReview_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *reviewsClient) UpdateReview(ctx context.Context, in *UpdateReviewRequest, opts ...grpc.CallOption) (*UpdateReviewResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateReviewResponse)
        err := c.cc.Invoke(ctx, Reviews_UpdateReview_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *reviewsClient) DeleteReview(ctx context.Context, in *DeleteReviewRequest, opts ...grpc.CallOption) (*DeleteReviewResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteReviewResponse)
        err := c.cc.Invoke(ctx, Reviews_DeleteReview_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *reviewsClient) GetReviewsByPlaceID(ctx context.Context, in *GetReviewsByPlaceIDRequest, opts ...grpc.CallOption) (*GetReviewsByPlaceIDResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetReviewsByPlaceIDResponse)
        err := c.cc.Invoke(ctx, Reviews_GetReviewsByPlaceID_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *reviewsClient) GetReviewsByUserID(ctx context.Context, in *GetReviewsByUserIDRequest, opts ...grpc.CallOption) (*GetReviewsByUserIDResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetReviewsByUserIDResponse)
        err := c.cc.Invoke(ctx, Reviews_GetReviewsByUserID_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *reviewsClient) GetReview(ctx context.Context, in *GetReviewRequest, opts ...grpc.CallOption) (*GetReviewResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetReviewResponse)
        err := c.cc.Invoke(ctx, Reviews_GetReview_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ReviewsServer is the server API for Reviews service.
// All implementations must embed UnimplementedReviewsServer
// for forward compatibility.
type ReviewsServer interface {
        CreateReview(context.Context, *CreateReviewRequest) (*CreateReviewResponse, error)
        UpdateReview(context.Context, *UpdateReviewRequest) (*UpdateReviewResponse, error)
        DeleteReview(context.Context, *DeleteReviewRequest) (*DeleteReviewResponse, error)
        GetReviewsByPlaceID(context.Context, *GetReviewsByPlaceIDRequest) (*GetReviewsByPlaceIDResponse, error)
        GetReviewsByUserID(context.Context, *GetReviewsByUserIDRequest) (*GetReviewsByUserIDResponse, error)
        GetReview(context.Context, *GetReviewRequest) (*GetReviewResponse, error)
        mustEmbedUnimplementedReviewsServer()
}

// UnimplementedReviewsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReviewsServer struct{}

func (UnimplementedReviewsServer) CreateReview(context.Context, *CreateReviewRequest) (*CreateReviewResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateReview not implemented")
}</span>
func (UnimplementedReviewsServer) UpdateReview(context.Context, *UpdateReviewRequest) (*UpdateReviewResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateReview not implemented")
}</span>
func (UnimplementedReviewsServer) DeleteReview(context.Context, *DeleteReviewRequest) (*DeleteReviewResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteReview not implemented")
}</span>
func (UnimplementedReviewsServer) GetReviewsByPlaceID(context.Context, *GetReviewsByPlaceIDRequest) (*GetReviewsByPlaceIDResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetReviewsByPlaceID not implemented")
}</span>
func (UnimplementedReviewsServer) GetReviewsByUserID(context.Context, *GetReviewsByUserIDRequest) (*GetReviewsByUserIDResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetReviewsByUserID not implemented")
}</span>
func (UnimplementedReviewsServer) GetReview(context.Context, *GetReviewRequest) (*GetReviewResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetReview not implemented")
}</span>
func (UnimplementedReviewsServer) mustEmbedUnimplementedReviewsServer() {<span class="cov0" title="0">}</span>
func (UnimplementedReviewsServer) testEmbeddedByValue()                 {<span class="cov0" title="0">}</span>

// UnsafeReviewsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReviewsServer will
// result in compilation errors.
type UnsafeReviewsServer interface {
        mustEmbedUnimplementedReviewsServer()
}

func RegisterReviewsServer(s grpc.ServiceRegistrar, srv ReviewsServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedReviewsServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Reviews_ServiceDesc, srv)</span>
}

func _Reviews_CreateReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateReviewRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ReviewsServer).CreateReview(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Reviews_CreateReview_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ReviewsServer).CreateReview(ctx, req.(*CreateReviewRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Reviews_UpdateReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateReviewRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ReviewsServer).UpdateReview(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Reviews_UpdateReview_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ReviewsServer).UpdateReview(ctx, req.(*UpdateReviewRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Reviews_DeleteReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteReviewRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ReviewsServer).DeleteReview(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Reviews_DeleteReview_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ReviewsServer).DeleteReview(ctx, req.(*DeleteReviewRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Reviews_GetReviewsByPlaceID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetReviewsByPlaceIDRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ReviewsServer).GetReviewsByPlaceID(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Reviews_GetReviewsByPlaceID_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ReviewsServer).GetReviewsByPlaceID(ctx, req.(*GetReviewsByPlaceIDRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Reviews_GetReviewsByUserID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetReviewsByUserIDRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ReviewsServer).GetReviewsByUserID(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Reviews_GetReviewsByUserID_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ReviewsServer).GetReviewsByUserID(ctx, req.(*GetReviewsByUserIDRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Reviews_GetReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetReviewRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ReviewsServer).GetReview(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Reviews_GetReview_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ReviewsServer).GetReview(ctx, req.(*GetReviewRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Reviews_ServiceDesc is the grpc.ServiceDesc for Reviews service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Reviews_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "reviews.Reviews",
        HandlerType: (*ReviewsServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateReview",
                        Handler:    _Reviews_CreateReview_Handler,
                },
                {
                        MethodName: "UpdateReview",
                        Handler:    _Reviews_UpdateReview_Handler,
                },
                {
                        MethodName: "DeleteReview",
                        Handler:    _Reviews_DeleteReview_Handler,
                },
                {
                        MethodName: "GetReviewsByPlaceID",
                        Handler:    _Reviews_GetReviewsByPlaceID_Handler,
                },
                {
                        MethodName: "GetReviewsByUserID",
                        Handler:    _Reviews_GetReviewsByUserID_Handler,
                },
                {
                        MethodName: "GetReview",
                        Handler:    _Reviews_GetReview_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/reviews.proto",
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package grpc

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/reviews"
        "2024_2_ThereWillBeName/internal/pkg/reviews/delivery/grpc/gen"
        "context"
)

//go:generate protoc -I . proto/reviews.proto --go_out=./gen --go-grpc_out=./gen

type GrpcReviewsHandler struct {
        gen.UnimplementedReviewsServer
        uc reviews.ReviewsUsecase
}

func NewGrpcReviewsHandler(uc reviews.ReviewsUsecase) *GrpcReviewsHandler <span class="cov0" title="0">{
        return &amp;GrpcReviewsHandler{uc: uc}
}</span>

func (s *GrpcReviewsHandler) CreateReview(ctx context.Context, req *gen.CreateReviewRequest) (*gen.CreateReviewResponse, error) <span class="cov0" title="0">{
        review := models.Review{
                ID:         uint(req.Review.Id),
                UserID:     uint(req.Review.UserId),
                PlaceID:    uint(req.Review.PlaceId),
                Rating:     int(req.Review.Rating),
                ReviewText: req.Review.ReviewText,
        }

        res, err := s.uc.CreateReview(ctx, review)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">reviewResponse := &amp;gen.GetReview{
                Id:         uint32(res.ID),
                UserLogin:  res.UserLogin,
                AvatarPath: res.AvatarPath,
                Rating:     int32(res.Rating),
                ReviewText: res.ReviewText,
        }
        return &amp;gen.CreateReviewResponse{Review: reviewResponse}, nil</span>
}

func (s *GrpcReviewsHandler) UpdateReview(ctx context.Context, req *gen.UpdateReviewRequest) (*gen.UpdateReviewResponse, error) <span class="cov0" title="0">{
        review := models.Review{
                ID:         uint(req.Review.Id),
                UserID:     uint(req.Review.UserId),
                PlaceID:    uint(req.Review.PlaceId),
                Rating:     int(req.Review.Rating),
                ReviewText: req.Review.ReviewText,
        }

        err := s.uc.UpdateReview(ctx, review)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;gen.UpdateReviewResponse{Success: false}, err
        }</span>
        <span class="cov0" title="0">return &amp;gen.UpdateReviewResponse{Success: true}, nil</span>
}

func (s *GrpcReviewsHandler) DeleteReview(ctx context.Context, req *gen.DeleteReviewRequest) (*gen.DeleteReviewResponse, error) <span class="cov0" title="0">{
        err := s.uc.DeleteReview(ctx, uint(req.Id))
        if err != nil </span><span class="cov0" title="0">{
                return &amp;gen.DeleteReviewResponse{Success: false}, err
        }</span>
        <span class="cov0" title="0">return &amp;gen.DeleteReviewResponse{Success: true}, nil</span>
}

func (s *GrpcReviewsHandler) GetReviewsByPlaceID(ctx context.Context, req *gen.GetReviewsByPlaceIDRequest) (*gen.GetReviewsByPlaceIDResponse, error) <span class="cov0" title="0">{
        reviews, err := s.uc.GetReviewsByPlaceID(ctx, uint(req.PlaceId), int(req.Limit), int(req.Offset))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">reviewsResponse := make([]*gen.GetReview, len(reviews))
        for i, review := range reviews </span><span class="cov0" title="0">{
                reviewsResponse[i] = &amp;gen.GetReview{
                        Id:         uint32(review.ID),
                        UserLogin:  review.UserLogin,
                        AvatarPath: review.AvatarPath,
                        Rating:     int32(review.Rating),
                        ReviewText: review.ReviewText,
                }
        }</span>
        <span class="cov0" title="0">return &amp;gen.GetReviewsByPlaceIDResponse{Reviews: reviewsResponse}, nil</span>
}

func (s *GrpcReviewsHandler) GetReviewsByUserID(ctx context.Context, req *gen.GetReviewsByUserIDRequest) (*gen.GetReviewsByUserIDResponse, error) <span class="cov0" title="0">{
        reviews, err := s.uc.GetReviewsByUserID(ctx, uint(req.UserId), int(req.Limit), int(req.Offset))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">reviewsResponse := make([]*gen.GetReviewByUserID, len(reviews))
        for i, review := range reviews </span><span class="cov0" title="0">{
                reviewsResponse[i] = &amp;gen.GetReviewByUserID{
                        Id:         uint32(review.ID),
                        PlaceName:  review.PlaceName,
                        Rating:     int32(review.Rating),
                        ReviewText: review.ReviewText,
                }
        }</span>
        <span class="cov0" title="0">return &amp;gen.GetReviewsByUserIDResponse{Reviews: reviewsResponse}, nil</span>
}

func (s *GrpcReviewsHandler) GetReview(ctx context.Context, req *gen.GetReviewRequest) (*gen.GetReviewResponse, error) <span class="cov0" title="0">{
        review, err := s.uc.GetReview(ctx, uint(req.Id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">reviewResponse := &amp;gen.GetReview{
                Id:         uint32(review.ID),
                UserLogin:  review.UserLogin,
                AvatarPath: review.AvatarPath,
                Rating:     int32(review.Rating),
                ReviewText: review.ReviewText,
        }
        return &amp;gen.GetReviewResponse{Review: reviewResponse}, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package http

import (
        "2024_2_ThereWillBeName/internal/models"
        httpresponse "2024_2_ThereWillBeName/internal/pkg/httpresponses"
        log "2024_2_ThereWillBeName/internal/pkg/logger"
        "2024_2_ThereWillBeName/internal/pkg/middleware"
        "2024_2_ThereWillBeName/internal/pkg/reviews/delivery/grpc/gen"
        "2024_2_ThereWillBeName/internal/validator"
        "context"
        "html/template"
        "log/slog"

        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
)

type ReviewHandler struct {
        client gen.ReviewsClient
        logger *slog.Logger
}

func NewReviewHandler(client gen.ReviewsClient, logger *slog.Logger) *ReviewHandler <span class="cov0" title="0">{
        return &amp;ReviewHandler{client, logger}
}</span>

func ErrorCheck(err error, action string, logger *slog.Logger, ctx context.Context) (httpresponse.ErrorResponse, int) <span class="cov0" title="0">{
        logContext := log.AppendCtx(ctx, slog.String("action", action))
        logContext = log.AppendCtx(logContext, slog.Any("error", err.Error()))

        if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{

                logger.ErrorContext(logContext, fmt.Sprintf("Error during %s operation", action))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid request",
                }
                return response, http.StatusNotFound
        }</span>
        <span class="cov0" title="0">logger.ErrorContext(logContext, fmt.Sprintf("Failed to %s reviews", action))
        response := httpresponse.ErrorResponse{
                Message: fmt.Sprintf("Failed to %s review", action),
        }
        return response, http.StatusInternalServerError</span>
}

// CreateReviewHandler godoc
// @Summary Create a new review
// @Description Create a new review for a place
// @Accept json
// @Produce json
// @Param review body models.Review true "Review details"
// @Success 201 {object} models.Review "Review created successfully"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid request"
// @Failure 403 {object} httpresponses.ErrorResponse "Token is missing"
// @Failure 403 {object} httpresponses.ErrorResponse "Invalid token"
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to create review"
// @Router /reviews [post]
func (h *ReviewHandler) CreateReviewHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := r.Context()
        h.logger.DebugContext(logCtx, "Handling request for creating a review")

        userID, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{

                h.logger.WarnContext(logCtx, "Failed to retrieve user ID from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">var review models.Review
        err := json.NewDecoder(r.Body).Decode(&amp;review)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.ErrorContext(logCtx, "Failed to decode review data",
                        slog.Any("error", err.Error()),
                        slog.String("review_data", fmt.Sprintf("%+v", review)))

                response := httpresponse.ErrorResponse{
                        Message: "Invalid request",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>
        <span class="cov0" title="0">v := validator.New()
        if models.ValidateReview(v, &amp;review); !v.Valid() </span><span class="cov0" title="0">{
                h.logger.WarnContext(logCtx, "Review data is not valid")
                httpresponse.SendJSONResponse(w, nil, http.StatusUnprocessableEntity, h.logger)
                return
        }</span>

        <span class="cov0" title="0">review.ReviewText = template.HTMLEscapeString(review.ReviewText)

        if review.Rating &lt; 1 || review.Rating &gt; 5 </span><span class="cov0" title="0">{
                h.logger.WarnContext(logCtx, "Invalid rating",
                        slog.String("rating", strconv.Itoa(review.Rating)))

                response := httpresponse.ErrorResponse{
                        Message: "Invalid rating",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">review.UserID = userID

        reviewRequest := &amp;gen.Review{
                Id:         uint32(review.ID),
                UserId:     uint32(review.UserID),
                PlaceId:    uint32(review.PlaceID),
                Rating:     int32(review.Rating),
                ReviewText: review.ReviewText,
        }

        h.logger.DebugContext(logCtx, "Review request details", slog.Any("reviewRequest", reviewRequest))

        createdReview, err := h.client.CreateReview(logCtx, &amp;gen.CreateReviewRequest{Review: reviewRequest})
        if err != nil </span><span class="cov0" title="0">{
                response, status := ErrorCheck(err, "create", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully created a review",
                slog.Int("review_id", int(createdReview.Review.Id)))

        httpresponse.SendJSONResponse(w, createdReview.Review, http.StatusCreated, h.logger)</span>
}

// UpdateReviewHandler godoc
// @Summary Update an existing review
// @Description Update review details by review ID
// @Accept json
// @Produce json
// @Param id path int true "Review ID"
// @Param review body models.Review true "Updated review details"
// @Success 200 {object} models.Review "Review updated successfully"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid review ID"
// @Failure 403 {object} httpresponses.ErrorResponse "Token is missing"
// @Failure 403 {object} httpresponses.ErrorResponse "Invalid token"
// @Failure 404 {object} httpresponses.ErrorResponse "Review not found"
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to update review"
// @Router /reviews/{id} [put]
func (h *ReviewHandler) UpdateReviewHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := r.Context()

        _, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{

                h.logger.WarnContext(logCtx, "Failed to retrieve user ID from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">var review models.Review
        vars := mux.Vars(r)
        reviewID, err := strconv.Atoi(vars["reviewID"])

        logCtx = log.AppendCtx(logCtx, slog.Int("review_id", reviewID))
        h.logger.DebugContext(logCtx, "Handling request for updating a review")

        if err != nil || reviewID &lt; 0 </span><span class="cov0" title="0">{
                response := httpresponse.ErrorResponse{
                        Message: "Invalid review ID",
                }
                h.logger.WarnContext(logCtx, "Failed to parse place ID", slog.Any("error", err.Error()))

                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>
        <span class="cov0" title="0">err = json.NewDecoder(r.Body).Decode(&amp;review)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WarnContext(logCtx, "Failed to decode review data", slog.String("review_data", fmt.Sprintf("%+v", review)), slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid review data",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">v := validator.New()
        if models.ValidateReview(v, &amp;review); !v.Valid() </span><span class="cov0" title="0">{
                h.logger.WarnContext(logCtx, "Review data is not valid")
                httpresponse.SendJSONResponse(w, nil, http.StatusUnprocessableEntity, h.logger)
                return
        }</span>

        <span class="cov0" title="0">review.ReviewText = template.HTMLEscapeString(review.ReviewText)

        review.ID = uint(reviewID)

        reviewRequest := &amp;gen.Review{
                ReviewText: review.ReviewText,
                UserId:     uint32(review.UserID),
                PlaceId:    uint32(review.PlaceID),
                Rating:     int32(review.Rating),
                Id:         uint32(review.ID),
        }

        h.logger.DebugContext(logCtx, "Review request details", slog.Any("reviewRequest", reviewRequest))

        res, err := h.client.UpdateReview(r.Context(), &amp;gen.UpdateReviewRequest{Review: reviewRequest})
        if err != nil </span><span class="cov0" title="0">{
                response, status := ErrorCheck(err, "update", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully updated a review")

        httpresponse.SendJSONResponse(w, res.Success, http.StatusOK, h.logger)</span>
}

// DeleteReviewHandler godoc
// @Summary Delete a review
// @Description Delete a review by review ID
// @Produce json
// @Param id path int true "Review ID"
// @Success 204 "Review deleted successfully"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid review ID"
// @Failure 403 {object} httpresponses.ErrorResponse "Token is missing"
// @Failure 403 {object} httpresponses.ErrorResponse "Invalid token"
// @Failure 404 {object} httpresponses.ErrorResponse "Review not found"
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to delete review"
// @Router /reviews/{id} [delete]
func (h *ReviewHandler) DeleteReviewHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := r.Context()

        vars := mux.Vars(r)
        idStr := vars["reviewID"]

        _, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{

                h.logger.WarnContext(logCtx, "Failed to retrieve user ID from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">logCtx = log.AppendCtx(logCtx, slog.String("reviewID", idStr))
        h.logger.DebugContext(logCtx, "Handling request for deleting a review")

        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WarnContext(logCtx, "Failed to parse review ID", slog.Any("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid review ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">_, err = h.client.DeleteReview(r.Context(), &amp;gen.DeleteReviewRequest{Id: uint32(id)})
        if err != nil </span><span class="cov0" title="0">{
                response, status := ErrorCheck(err, "delete", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully deleted a review")

        response := map[string]string{
                "message": "Review deleted successfully",
        }

        httpresponse.SendJSONResponse(w, response, http.StatusOK, h.logger)</span>
}

// GetReviewsByPlaceIDHandler godoc
// @Summary Retrieve reviews by place ID
// @Description Get all reviews for a specific place
// @Produce json
// @Param placeID path int true "Place ID"
// @Success 200 {array} models.Review "List of reviews"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid place ID"
// @Failure 404 {object} httpresponses.ErrorResponse "No reviews found for the place"
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to retrieve reviews"
// @Router /attractions/{placeID}/reviews [get]
func (h *ReviewHandler) GetReviewsByPlaceIDHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := r.Context()

        vars := mux.Vars(r)
        placeIDStr := vars["placeID"]

        logCtx = log.AppendCtx(logCtx, slog.String("place_id", placeIDStr))

        h.logger.DebugContext(logCtx, "Handling request for getting reviews by place ID")

        placeID, err := strconv.ParseUint(placeIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WarnContext(logCtx, "Failed to parse place ID", slog.Any("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid place ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>
        <span class="cov0" title="0">pageStr := r.URL.Query().Get("page")
        page := 1
        if pageStr != "" </span><span class="cov0" title="0">{
                page, err = strconv.Atoi(pageStr)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.WarnContext(logCtx, "Invalid page number", slog.Any("error", err.Error()))
                        response := httpresponse.ErrorResponse{
                                Message: "Invalid page number",
                        }
                        httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                        return
                }</span>
        }
        <span class="cov0" title="0">limit := 10
        offset := limit * (page - 1)
        reviews, err := h.client.GetReviewsByPlaceID(r.Context(), &amp;gen.GetReviewsByPlaceIDRequest{PlaceId: uint32(placeID), Limit: int32(limit), Offset: int32(offset)})
        if err != nil </span><span class="cov0" title="0">{
                response, status := ErrorCheck(err, "retrieve", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully got reviews by place ID", slog.Int("reviews_count", len(reviews.Reviews)))

        httpresponse.SendJSONResponse(w, reviews.Reviews, http.StatusOK, h.logger)</span>
}

// GetReviewsByUserIDHandler godoc
// @Summary Retrieve reviews by user ID
// @Description Get all reviews for an user
// @Produce json
// @Param userID path int true "User ID"
// @Success 200 {array} models.GetReviewByUserID "List of reviews"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid user ID"
// @Failure 404 {object} httpresponses.ErrorResponse "No reviews found for the user"
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to retrieve reviews"
// @Router /users/{userID}/reviews [get]
func (h *ReviewHandler) GetReviewsByUserIDHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := r.Context()

        userID, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{

                h.logger.WarnContext(logCtx, "Failed to retrieve user ID from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">logCtx = log.AppendCtx(logCtx, slog.Int("user_id", int(userID)))
        h.logger.DebugContext(logCtx, "Handling request for getting reviews by user ID")

        pageStr := r.URL.Query().Get("page")
        page := 1
        var err error
        if pageStr != "" </span><span class="cov0" title="0">{
                page, err = strconv.Atoi(pageStr)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.WarnContext(logCtx, "Invalid page number", slog.Any("error", err.Error()))
                        response := httpresponse.ErrorResponse{
                                Message: "Invalid page number",
                        }
                        httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                        return
                }</span>
        }
        <span class="cov0" title="0">limit := 10
        offset := limit * (page - 1)
        reviews, err := h.client.GetReviewsByUserID(r.Context(), &amp;gen.GetReviewsByUserIDRequest{UserId: uint32(userID), Limit: int32(limit), Offset: int32(offset)})
        if err != nil </span><span class="cov0" title="0">{
                response, status := ErrorCheck(err, "retrieve", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully got reviews by user ID", slog.Int("reviews_count", len(reviews.Reviews)))

        httpresponse.SendJSONResponse(w, reviews.Reviews, http.StatusOK, h.logger)</span>
}

// GetReviewHandler godoc
// @Summary Retrieve a review by ID
// @Description Get review details by review ID
// @Produce json
// @Param id path int true "Review ID"
// @Success 200 {object} models.GetReview "Review details"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid review ID"
// @Failure 404 {object} httpresponses.ErrorResponse "Review not found"
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to retrieve review"
// @Router /reviews/{id} [get]
func (h *ReviewHandler) GetReviewHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := r.Context()

        vars := mux.Vars(r)
        reviewIDStr := vars["reviewID"]

        logCtx = log.AppendCtx(logCtx, slog.String("reviewID", reviewIDStr))
        h.logger.DebugContext(logCtx, "Handling request for getting review by ID")

        reviewID, err := strconv.ParseUint(reviewIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WarnContext(logCtx, "Failed to parse review ID", slog.Any("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid review ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">review, err := h.client.GetReview(r.Context(), &amp;gen.GetReviewRequest{Id: uint32(reviewID)})
        if err != nil </span><span class="cov0" title="0">{
                response, status := ErrorCheck(err, "retrieve", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully got review by ID")

        httpresponse.SendJSONResponse(w, review.Review, http.StatusOK, h.logger)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package reviews

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/dblogger"
        "context"
        "database/sql"
        "fmt"

        _ "github.com/lib/pq"
)

type ReviewRepository struct {
        db *dblogger.DB
}

func NewReviewRepository(db *dblogger.DB) *ReviewRepository <span class="cov8" title="1">{
        return &amp;ReviewRepository{db: db}
}</span>

func (r *ReviewRepository) CreateReview(ctx context.Context, review models.Review) (models.GetReview, error) <span class="cov8" title="1">{
        query := `INSERT INTO review (user_id, place_id, rating, review_text, created_at, updated_at) 
              VALUES ($1, $2, $3, $4, NOW(), NOW()) RETURNING id`

        var reviewID int
        err := r.db.QueryRowContext(ctx, query, review.UserID, review.PlaceID, review.Rating, review.ReviewText).Scan(&amp;reviewID)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return models.GetReview{}, fmt.Errorf("no rows were created for the review: %w", models.ErrNotFound)
                }</span>
                <span class="cov8" title="1">return models.GetReview{}, fmt.Errorf("failed to create review: %w", models.ErrInternal)</span>
        }

        // Теперь, после успешного создания отзыва, мы можем использовать его ID, чтобы получить полные данные
        <span class="cov8" title="1">createdReview, err := r.GetReview(ctx, uint(reviewID))
        if err != nil </span><span class="cov8" title="1">{
                return models.GetReview{}, fmt.Errorf("failed to retrieve created review details: %w", err)
        }</span>

        <span class="cov8" title="1">return createdReview, nil</span>
}

func (r *ReviewRepository) UpdateReview(ctx context.Context, review models.Review) error <span class="cov8" title="1">{
        query := `UPDATE review 
              SET rating = $1, review_text = $2, updated_at = NOW() 
              WHERE id = $3`

        result, err := r.db.ExecContext(ctx, query, review.Rating, review.ReviewText, review.ID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to update review: %w", models.ErrInternal)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retrieve rows affected: %w", models.ErrInternal)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no rows were updated: %w", models.ErrNotFound)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *ReviewRepository) DeleteReview(ctx context.Context, reviewID uint) error <span class="cov8" title="1">{
        query := `DELETE FROM review WHERE id = $1`

        result, err := r.db.ExecContext(ctx, query, reviewID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete review: %w", models.ErrInternal)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retrieve rows affected: %w", models.ErrInternal)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("review not found: %w", models.ErrNotFound)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *ReviewRepository) GetReviewsByPlaceID(ctx context.Context, placeID uint, limit, offset int) ([]models.GetReview, error) <span class="cov0" title="0">{
        query := `SELECT r.id, u.login, u.avatar_path, r.rating, r.review_text 
              FROM review r
              JOIN "user" u ON r.user_id = u.id
              WHERE r.place_id = $1
              ORDER BY r.created_at DESC
              LIMIT $2 OFFSET $3`

        rows, err := r.db.QueryContext(ctx, query, placeID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to retrieve reviews: %w", models.ErrInternal)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reviews []models.GetReview
        for rows.Next() </span><span class="cov0" title="0">{
                var review models.GetReview
                if err := rows.Scan(&amp;review.ID, &amp;review.UserLogin, &amp;review.AvatarPath, &amp;review.Rating, &amp;review.ReviewText); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan review row: %w", models.ErrInternal)
                }</span>
                <span class="cov0" title="0">reviews = append(reviews, review)</span>
        }

        <span class="cov0" title="0">if len(reviews) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no reviews found for place with ID %d: %w", placeID, models.ErrNotFound)
        }</span>

        <span class="cov0" title="0">return reviews, nil</span>
}

func (r *ReviewRepository) GetReviewsByUserID(ctx context.Context, userID uint, limit, offset int) ([]models.GetReviewByUserID, error) <span class="cov8" title="1">{
        query := `SELECT r.id, r.rating, r.review_text, p.name 
              FROM review r
              JOIN "user" u ON r.user_id = u.id
              JOIN place p ON r.place_id = p.id
              WHERE r.user_id = $1
              ORDER BY r.created_at DESC
              LIMIT $2 OFFSET $3`

        rows, err := r.db.QueryContext(ctx, query, userID, limit, offset)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to retrieve reviews by user: %w", models.ErrInternal)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var reviews []models.GetReviewByUserID
        for rows.Next() </span><span class="cov8" title="1">{
                var review models.GetReviewByUserID
                if err := rows.Scan(&amp;review.ID, &amp;review.Rating, &amp;review.ReviewText, &amp;review.PlaceName); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan review row: %w", models.ErrInternal)
                }</span>
                <span class="cov8" title="1">reviews = append(reviews, review)</span>
        }

        <span class="cov8" title="1">if len(reviews) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no reviews found for user with ID %d: %w", userID, models.ErrNotFound)
        }</span>

        <span class="cov8" title="1">return reviews, nil</span>
}

func (r *ReviewRepository) GetReview(ctx context.Context, reviewID uint) (models.GetReview, error) <span class="cov8" title="1">{
        query := `SELECT r.id, u.login, u.avatar_path, r.rating, r.review_text 
              FROM review r
              JOIN "user" u ON r.user_id = u.id
              WHERE r.id = $1`

        row := r.db.QueryRowContext(ctx, query, reviewID)

        var review models.GetReview
        err := row.Scan(&amp;review.ID, &amp;review.UserLogin, &amp;review.AvatarPath, &amp;review.Rating, &amp;review.ReviewText)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return models.GetReview{}, fmt.Errorf("review with ID %d did not found: %w", reviewID, models.ErrNotFound)
                }</span>
                <span class="cov8" title="1">return models.GetReview{}, fmt.Errorf("failed to scan review: %w", models.ErrInternal)</span>
        }

        <span class="cov8" title="1">return review, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package reviews

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/reviews"
        "context"
        "errors"
        "fmt"
)

type reviewsUsecaseImpl struct {
        repo reviews.ReviewsRepo
}

func NewReviewsUsecase(repo reviews.ReviewsRepo) *reviewsUsecaseImpl <span class="cov8" title="1">{
        return &amp;reviewsUsecaseImpl{repo: repo}
}</span>

func (u *reviewsUsecaseImpl) CreateReview(ctx context.Context, review models.Review) (models.GetReview, error) <span class="cov8" title="1">{
        createdReview, err := u.repo.CreateReview(ctx, review)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return models.GetReview{}, fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov8" title="1">return models.GetReview{}, fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }

        <span class="cov8" title="1">return createdReview, nil</span>
}

func (u *reviewsUsecaseImpl) UpdateReview(ctx context.Context, review models.Review) error <span class="cov8" title="1">{
        err := u.repo.UpdateReview(ctx, review)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (u *reviewsUsecaseImpl) DeleteReview(ctx context.Context, reviewID uint) error <span class="cov8" title="1">{
        err := u.repo.DeleteReview(ctx, reviewID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (u *reviewsUsecaseImpl) GetReviewsByPlaceID(ctx context.Context, placeID uint, limit, offset int) ([]models.GetReview, error) <span class="cov8" title="1">{
        reviewsFound, err := u.repo.GetReviewsByPlaceID(ctx, placeID, limit, offset)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }

        <span class="cov8" title="1">return reviewsFound, nil</span>
}

func (u *reviewsUsecaseImpl) GetReviewsByUserID(ctx context.Context, userID uint, limit, offset int) ([]models.GetReviewByUserID, error) <span class="cov8" title="1">{
        reviewsFound, err := u.repo.GetReviewsByUserID(ctx, userID, limit, offset)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }

        <span class="cov8" title="1">return reviewsFound, nil</span>
}

func (u *reviewsUsecaseImpl) GetReview(ctx context.Context, reviewID uint) (models.GetReview, error) <span class="cov8" title="1">{
        reviewFound, err := u.repo.GetReview(ctx, reviewID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return models.GetReview{}, fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov8" title="1">return models.GetReview{}, fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }

        <span class="cov8" title="1">return reviewFound, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v3.12.4
// source: search.proto

package gen

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SearchRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        DecodedQuery string `protobuf:"bytes,1,opt,name=decoded_query,json=decodedQuery,proto3" json:"decoded_query,omitempty"`
}

func (x *SearchRequest) Reset() <span class="cov0" title="0">{
        *x = SearchRequest{}
        mi := &amp;file_search_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_search_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchRequest.ProtoReflect.Descriptor instead.
func (*SearchRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_search_proto_rawDescGZIP(), []int{0}
}</span>

func (x *SearchRequest) GetDecodedQuery() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DecodedQuery
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SearchResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SearchResult []*SearchResult `protobuf:"bytes,1,rep,name=search_result,json=searchResult,proto3" json:"search_result,omitempty"`
}

func (x *SearchResponse) Reset() <span class="cov0" title="0">{
        *x = SearchResponse{}
        mi := &amp;file_search_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_search_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchResponse.ProtoReflect.Descriptor instead.
func (*SearchResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_search_proto_rawDescGZIP(), []int{1}
}</span>

func (x *SearchResponse) GetSearchResult() []*SearchResult <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SearchResult
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SearchResult struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Id   uint32 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
        Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
}

func (x *SearchResult) Reset() <span class="cov0" title="0">{
        *x = SearchResult{}
        mi := &amp;file_search_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchResult) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchResult) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchResult) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_search_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchResult.ProtoReflect.Descriptor instead.
func (*SearchResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_search_proto_rawDescGZIP(), []int{2}
}</span>

func (x *SearchResult) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchResult) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SearchResult) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_search_proto protoreflect.FileDescriptor

var file_search_proto_rawDesc = []byte{
        0x0a, 0x0c, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06,
        0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x22, 0x34, 0x0a, 0x0d, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x64, 0x65, 0x63, 0x6f, 0x64,
        0x65, 0x64, 0x5f, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c,
        0x64, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x51, 0x75, 0x65, 0x72, 0x79, 0x22, 0x4b, 0x0a, 0x0e,
        0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x39,
        0x0a, 0x0d, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x5f, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18,
        0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x53,
        0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x52, 0x0c, 0x73, 0x65, 0x61,
        0x72, 0x63, 0x68, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x22, 0x46, 0x0a, 0x0c, 0x53, 0x65, 0x61,
        0x72, 0x63, 0x68, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x0e, 0x0a,
        0x02, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a,
        0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70,
        0x65, 0x32, 0x41, 0x0a, 0x06, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x12, 0x37, 0x0a, 0x06, 0x53,
        0x65, 0x61, 0x72, 0x63, 0x68, 0x12, 0x15, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x53,
        0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x73,
        0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x42, 0x2e, 0x5a, 0x2c, 0x2e, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e,
        0x61, 0x6c, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2f, 0x64, 0x65,
        0x6c, 0x69, 0x76, 0x65, 0x72, 0x79, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2f, 0x67, 0x65, 0x6e, 0x2f,
        0x3b, 0x67, 0x65, 0x6e, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_search_proto_rawDescOnce sync.Once
        file_search_proto_rawDescData = file_search_proto_rawDesc
)

func file_search_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_search_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_search_proto_rawDescData = protoimpl.X.CompressGZIP(file_search_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_search_proto_rawDescData</span>
}

var file_search_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_search_proto_goTypes = []any{
        (*SearchRequest)(nil),  // 0: search.SearchRequest
        (*SearchResponse)(nil), // 1: search.SearchResponse
        (*SearchResult)(nil),   // 2: search.SearchResult
}
var file_search_proto_depIdxs = []int32{
        2, // 0: search.SearchResponse.search_result:type_name -&gt; search.SearchResult
        0, // 1: search.Search.Search:input_type -&gt; search.SearchRequest
        1, // 2: search.Search.Search:output_type -&gt; search.SearchResponse
        2, // [2:3] is the sub-list for method output_type
        1, // [1:2] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_search_proto_init() }</span>
func file_search_proto_init() <span class="cov0" title="0">{
        if File_search_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_search_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_search_proto_goTypes,
                DependencyIndexes: file_search_proto_depIdxs,
                MessageInfos:      file_search_proto_msgTypes,
        }.Build()
        File_search_proto = out.File
        file_search_proto_rawDesc = nil
        file_search_proto_goTypes = nil
        file_search_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: search.proto

package gen

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Search_Search_FullMethodName = "/search.Search/Search"
)

// SearchClient is the client API for Search service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SearchClient interface {
        Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
}

type searchClient struct {
        cc grpc.ClientConnInterface
}

func NewSearchClient(cc grpc.ClientConnInterface) SearchClient <span class="cov0" title="0">{
        return &amp;searchClient{cc}
}</span>

func (c *searchClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SearchResponse)
        err := c.cc.Invoke(ctx, Search_Search_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// SearchServer is the server API for Search service.
// All implementations must embed UnimplementedSearchServer
// for forward compatibility.
type SearchServer interface {
        Search(context.Context, *SearchRequest) (*SearchResponse, error)
        mustEmbedUnimplementedSearchServer()
}

// UnimplementedSearchServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSearchServer struct{}

func (UnimplementedSearchServer) Search(context.Context, *SearchRequest) (*SearchResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}</span>
func (UnimplementedSearchServer) mustEmbedUnimplementedSearchServer() {<span class="cov0" title="0">}</span>
func (UnimplementedSearchServer) testEmbeddedByValue()                {<span class="cov0" title="0">}</span>

// UnsafeSearchServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SearchServer will
// result in compilation errors.
type UnsafeSearchServer interface {
        mustEmbedUnimplementedSearchServer()
}

func RegisterSearchServer(s grpc.ServiceRegistrar, srv SearchServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedSearchServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Search_ServiceDesc, srv)</span>
}

func _Search_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SearchRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(SearchServer).Search(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Search_Search_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(SearchServer).Search(ctx, req.(*SearchRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Search_ServiceDesc is the grpc.ServiceDesc for Search service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Search_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "search.Search",
        HandlerType: (*SearchServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Search",
                        Handler:    _Search_Search_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "search.proto",
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package grpc

import (
        "2024_2_ThereWillBeName/internal/pkg/search"
        searchGen "2024_2_ThereWillBeName/internal/pkg/search/delivery/grpc/gen"
        "context"
        "log/slog"
)

type GrpcSearchHandler struct {
        searchGen.SearchServer
        uc     search.SearchUsecase
        logger *slog.Logger
}

func NewGrpcSearchHandler(uc search.SearchUsecase, logger *slog.Logger) *GrpcSearchHandler <span class="cov0" title="0">{
        return &amp;GrpcSearchHandler{uc: uc, logger: logger}
}</span>

func (h *GrpcSearchHandler) Search(ctx context.Context, in *searchGen.SearchRequest) (*searchGen.SearchResponse, error) <span class="cov0" title="0">{
        results, err := h.uc.Search(context.Background(), in.DecodedQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">grpcResults := make([]*searchGen.SearchResult, len(results))
        for i, searchResult := range results </span><span class="cov0" title="0">{
                grpcResults[i] = &amp;searchGen.SearchResult{
                        Name: searchResult.Name,
                        Id:   uint32(searchResult.Id),
                        Type: searchResult.Type,
                }
        }</span>

        <span class="cov0" title="0">return &amp;searchGen.SearchResponse{SearchResult: grpcResults}, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package http

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/httpresponses"
        log "2024_2_ThereWillBeName/internal/pkg/logger"
        searchGen "2024_2_ThereWillBeName/internal/pkg/search/delivery/grpc/gen"
        "errors"
        "log/slog"
        "net/http"
        "net/url"
)

type SearchHandler struct {
        client searchGen.SearchClient
        logger *slog.Logger
}

func NewSearchHandler(client searchGen.SearchClient, logger *slog.Logger) *SearchHandler <span class="cov0" title="0">{
        return &amp;SearchHandler{client, logger}

}</span>

func (h *SearchHandler) Search(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for global searching places and cities")

        query := r.URL.Query().Get("query")
        if query == "" </span><span class="cov0" title="0">{
                h.logger.Warn("Query parameter can't be empty")
                httpresponses.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">decodedQuery, err := url.QueryUnescape(query)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Error decoding query", slog.String("error", err.Error()))
                httpresponses.SendJSONResponse(w, nil, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">results, err := h.client.Search(r.Context(), &amp;searchGen.SearchRequest{DecodedQuery: decodedQuery})
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        h.logger.WarnContext(logCtx, "No results found for query", slog.String("decodedQuery", decodedQuery))

                        httpresponses.SendJSONResponse(w, nil, http.StatusNotFound, h.logger)
                }</span>

                <span class="cov0" title="0">h.logger.ErrorContext(logCtx, "Failed to search", slog.String("decodedQuery", decodedQuery), slog.String("error", err.Error()))

                httpresponses.SendJSONResponse(w, nil, http.StatusInternalServerError, h.logger)
                return</span>
        }
        <span class="cov0" title="0">h.logger.InfoContext(logCtx, "Search completed successfully", slog.Int("resultCount", len(results.SearchResult)))

        httpresponses.SendJSONResponse(w, results.SearchResult, http.StatusOK, h.logger)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/pkg/search/interfaces.go

// Package mocks is a generated GoMock package.
package mocks

import (
        models "2024_2_ThereWillBeName/internal/models"
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockSearchUsecase is a mock of SearchUsecase interface.
type MockSearchUsecase struct {
        ctrl     *gomock.Controller
        recorder *MockSearchUsecaseMockRecorder
}

// MockSearchUsecaseMockRecorder is the mock recorder for MockSearchUsecase.
type MockSearchUsecaseMockRecorder struct {
        mock *MockSearchUsecase
}

// NewMockSearchUsecase creates a new mock instance.
func NewMockSearchUsecase(ctrl *gomock.Controller) *MockSearchUsecase <span class="cov0" title="0">{
        mock := &amp;MockSearchUsecase{ctrl: ctrl}
        mock.recorder = &amp;MockSearchUsecaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSearchUsecase) EXPECT() *MockSearchUsecaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Search mocks base method.
func (m *MockSearchUsecase) Search(ctx context.Context, query string) ([]models.SearchResult, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Search", ctx, query)
        ret0, _ := ret[0].([]models.SearchResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Search indicates an expected call of Search.
func (mr *MockSearchUsecaseMockRecorder) Search(ctx, query interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Search", reflect.TypeOf((*MockSearchUsecase)(nil).Search), ctx, query)
}</span>

// MockSearchRepo is a mock of SearchRepo interface.
type MockSearchRepo struct {
        ctrl     *gomock.Controller
        recorder *MockSearchRepoMockRecorder
}

// MockSearchRepoMockRecorder is the mock recorder for MockSearchRepo.
type MockSearchRepoMockRecorder struct {
        mock *MockSearchRepo
}

// NewMockSearchRepo creates a new mock instance.
func NewMockSearchRepo(ctrl *gomock.Controller) *MockSearchRepo <span class="cov0" title="0">{
        mock := &amp;MockSearchRepo{ctrl: ctrl}
        mock.recorder = &amp;MockSearchRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSearchRepo) EXPECT() *MockSearchRepoMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// SearchCitiesAndPlacesBySubString mocks base method.
func (m *MockSearchRepo) SearchCitiesAndPlacesBySubString(ctx context.Context, query string) ([]models.SearchResult, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchCitiesAndPlacesBySubString", ctx, query)
        ret0, _ := ret[0].([]models.SearchResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchCitiesAndPlacesBySubString indicates an expected call of SearchCitiesAndPlacesBySubString.
func (mr *MockSearchRepoMockRecorder) SearchCitiesAndPlacesBySubString(ctx, query interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchCitiesAndPlacesBySubString", reflect.TypeOf((*MockSearchRepo)(nil).SearchCitiesAndPlacesBySubString), ctx, query)
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package search

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/dblogger"
        "context"
        "fmt"
)

type SearchRepository struct {
        db *dblogger.DB
}

func NewSearchRepository(db *dblogger.DB) *SearchRepository <span class="cov8" title="1">{
        return &amp;SearchRepository{db}
}</span>

func (r *SearchRepository) SearchCitiesAndPlacesBySubString(ctx context.Context, query string) ([]models.SearchResult, error) <span class="cov8" title="1">{
        queryStr := `
        SELECT id, name, 'city' AS type
        FROM city
        WHERE name ILIKE '%' || $1 || '%'
        UNION ALL
        SELECT id, name, 'place' AS type
        FROM place
        WHERE name ILIKE '%' || $1 || '%'
    `

        rows, err := r.db.QueryContext(ctx, queryStr, query)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to execute search query: %w", models.ErrInternal)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var searchResults []models.SearchResult
        for rows.Next() </span><span class="cov8" title="1">{
                var item models.SearchResult
                if err := rows.Scan(&amp;item.Id, &amp;item.Name, &amp;item.Type); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan search row: %w", models.ErrInternal)
                }</span>
                <span class="cov8" title="1">searchResults = append(searchResults, item)</span>
        }

        <span class="cov8" title="1">if len(searchResults) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no results found matching query %q: %w", query, models.ErrNotFound)
        }</span>

        <span class="cov8" title="1">return searchResults, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package usecase

import (
        "2024_2_ThereWillBeName/internal/models"
        search "2024_2_ThereWillBeName/internal/pkg/search"
        "context"
)

type SearchUsecaseImpl struct {
        repo search.SearchRepo
}

func NewSearchUsecase(repo search.SearchRepo) *SearchUsecaseImpl <span class="cov0" title="0">{
        return &amp;SearchUsecaseImpl{repo: repo}
}</span>

func (uc *SearchUsecaseImpl) Search(ctx context.Context, query string) ([]models.SearchResult, error) <span class="cov0" title="0">{
        var results []models.SearchResult

        results, err := uc.repo.SearchCitiesAndPlacesBySubString(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v3.12.4
// source: proto/survey.proto

package gen

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GetSurveyByIdRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *GetSurveyByIdRequest) Reset() <span class="cov0" title="0">{
        *x = GetSurveyByIdRequest{}
        mi := &amp;file_proto_survey_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSurveyByIdRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSurveyByIdRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSurveyByIdRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_survey_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSurveyByIdRequest.ProtoReflect.Descriptor instead.
func (*GetSurveyByIdRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_survey_proto_rawDescGZIP(), []int{0}
}</span>

func (x *GetSurveyByIdRequest) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Survey struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id         uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        SurveyText string `protobuf:"bytes,2,opt,name=survey_text,json=surveyText,proto3" json:"survey_text,omitempty"`
        MaxRating  uint32 `protobuf:"varint,3,opt,name=max_rating,json=maxRating,proto3" json:"max_rating,omitempty"`
}

func (x *Survey) Reset() <span class="cov0" title="0">{
        *x = Survey{}
        mi := &amp;file_proto_survey_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Survey) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Survey) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Survey) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_survey_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Survey.ProtoReflect.Descriptor instead.
func (*Survey) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_survey_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Survey) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Survey) GetSurveyText() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SurveyText
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Survey) GetMaxRating() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxRating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type SurveyResponce struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SurveyId    uint32 `protobuf:"varint,1,opt,name=survey_id,json=surveyId,proto3" json:"survey_id,omitempty"`
        UserId      uint32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        Rating      uint32 `protobuf:"varint,4,opt,name=rating,proto3" json:"rating,omitempty"`
}

func (x *SurveyResponce) Reset() <span class="cov0" title="0">{
        *x = SurveyResponce{}
        mi := &amp;file_proto_survey_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SurveyResponce) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SurveyResponce) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SurveyResponce) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_survey_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SurveyResponce.ProtoReflect.Descriptor instead.
func (*SurveyResponce) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_survey_proto_rawDescGZIP(), []int{2}
}</span>

func (x *SurveyResponce) GetSurveyId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SurveyId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SurveyResponce) GetUserId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SurveyResponce) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SurveyResponce) GetRating() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetSurveyByIdResponce struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Survey *Survey `protobuf:"bytes,1,opt,name=survey,proto3" json:"survey,omitempty"`
}

func (x *GetSurveyByIdResponce) Reset() <span class="cov0" title="0">{
        *x = GetSurveyByIdResponce{}
        mi := &amp;file_proto_survey_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSurveyByIdResponce) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSurveyByIdResponce) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSurveyByIdResponce) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_survey_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSurveyByIdResponce.ProtoReflect.Descriptor instead.
func (*GetSurveyByIdResponce) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_survey_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetSurveyByIdResponce) GetSurvey() *Survey <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Survey
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateSurveyRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ServeyResponce *SurveyResponce `protobuf:"bytes,1,opt,name=serveyResponce,proto3" json:"serveyResponce,omitempty"`
}

func (x *CreateSurveyRequest) Reset() <span class="cov0" title="0">{
        *x = CreateSurveyRequest{}
        mi := &amp;file_proto_survey_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateSurveyRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateSurveyRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateSurveyRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_survey_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateSurveyRequest.ProtoReflect.Descriptor instead.
func (*CreateSurveyRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_survey_proto_rawDescGZIP(), []int{4}
}</span>

func (x *CreateSurveyRequest) GetServeyResponce() *SurveyResponce <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServeyResponce
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateSurveyResponce struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (x *CreateSurveyResponce) Reset() <span class="cov0" title="0">{
        *x = CreateSurveyResponce{}
        mi := &amp;file_proto_survey_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateSurveyResponce) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateSurveyResponce) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateSurveyResponce) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_survey_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateSurveyResponce.ProtoReflect.Descriptor instead.
func (*CreateSurveyResponce) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_survey_proto_rawDescGZIP(), []int{5}
}</span>

func (x *CreateSurveyResponce) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

type SurveyStatsBySurvey struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ServeyId     uint32          `protobuf:"varint,1,opt,name=servey_id,json=serveyId,proto3" json:"servey_id,omitempty"`
        ServeyText   string          `protobuf:"bytes,2,opt,name=servey_text,json=serveyText,proto3" json:"servey_text,omitempty"`
        AvgRating    float32         `protobuf:"fixed32,3,opt,name=avg_rating,json=avgRating,proto3" json:"avg_rating,omitempty"`
        RatingsCount map[int32]int32 `protobuf:"bytes,4,rep,name=ratings_count,json=ratingsCount,proto3" json:"ratings_count,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (x *SurveyStatsBySurvey) Reset() <span class="cov0" title="0">{
        *x = SurveyStatsBySurvey{}
        mi := &amp;file_proto_survey_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SurveyStatsBySurvey) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SurveyStatsBySurvey) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SurveyStatsBySurvey) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_survey_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SurveyStatsBySurvey.ProtoReflect.Descriptor instead.
func (*SurveyStatsBySurvey) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_survey_proto_rawDescGZIP(), []int{6}
}</span>

func (x *SurveyStatsBySurvey) GetServeyId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServeyId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SurveyStatsBySurvey) GetServeyText() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServeyText
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SurveyStatsBySurvey) GetAvgRating() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvgRating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SurveyStatsBySurvey) GetRatingsCount() map[int32]int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RatingsCount
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetSurveyStatsBySurveyIdRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *GetSurveyStatsBySurveyIdRequest) Reset() <span class="cov0" title="0">{
        *x = GetSurveyStatsBySurveyIdRequest{}
        mi := &amp;file_proto_survey_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSurveyStatsBySurveyIdRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSurveyStatsBySurveyIdRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSurveyStatsBySurveyIdRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_survey_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSurveyStatsBySurveyIdRequest.ProtoReflect.Descriptor instead.
func (*GetSurveyStatsBySurveyIdRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_survey_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetSurveyStatsBySurveyIdRequest) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetSurveyStatsBySurveyIdResponce struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SurveyStatsBySurvey *SurveyStatsBySurvey `protobuf:"bytes,1,opt,name=surveyStatsBySurvey,proto3" json:"surveyStatsBySurvey,omitempty"`
}

func (x *GetSurveyStatsBySurveyIdResponce) Reset() <span class="cov0" title="0">{
        *x = GetSurveyStatsBySurveyIdResponce{}
        mi := &amp;file_proto_survey_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSurveyStatsBySurveyIdResponce) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSurveyStatsBySurveyIdResponce) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSurveyStatsBySurveyIdResponce) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_survey_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSurveyStatsBySurveyIdResponce.ProtoReflect.Descriptor instead.
func (*GetSurveyStatsBySurveyIdResponce) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_survey_proto_rawDescGZIP(), []int{8}
}</span>

func (x *GetSurveyStatsBySurveyIdResponce) GetSurveyStatsBySurvey() *SurveyStatsBySurvey <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SurveyStatsBySurvey
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UserSurveyStats struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ServeyId   uint32 `protobuf:"varint,1,opt,name=servey_id,json=serveyId,proto3" json:"servey_id,omitempty"`
        ServeyText string `protobuf:"bytes,2,opt,name=servey_text,json=serveyText,proto3" json:"servey_text,omitempty"`
        Answered   bool   `protobuf:"varint,3,opt,name=answered,proto3" json:"answered,omitempty"`
}

func (x *UserSurveyStats) Reset() <span class="cov0" title="0">{
        *x = UserSurveyStats{}
        mi := &amp;file_proto_survey_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UserSurveyStats) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserSurveyStats) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserSurveyStats) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_survey_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserSurveyStats.ProtoReflect.Descriptor instead.
func (*UserSurveyStats) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_survey_proto_rawDescGZIP(), []int{9}
}</span>

func (x *UserSurveyStats) GetServeyId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServeyId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserSurveyStats) GetServeyText() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServeyText
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserSurveyStats) GetAnswered() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Answered
        }</span>
        <span class="cov0" title="0">return false</span>
}

type GetSurveyStatsByUserIdRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId uint32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (x *GetSurveyStatsByUserIdRequest) Reset() <span class="cov0" title="0">{
        *x = GetSurveyStatsByUserIdRequest{}
        mi := &amp;file_proto_survey_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSurveyStatsByUserIdRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSurveyStatsByUserIdRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSurveyStatsByUserIdRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_survey_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSurveyStatsByUserIdRequest.ProtoReflect.Descriptor instead.
func (*GetSurveyStatsByUserIdRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_survey_proto_rawDescGZIP(), []int{10}
}</span>

func (x *GetSurveyStatsByUserIdRequest) GetUserId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetSurveyStatsByUserIdResponce struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserServeyStats []*UserSurveyStats `protobuf:"bytes,1,rep,name=userServeyStats,proto3" json:"userServeyStats,omitempty"`
}

func (x *GetSurveyStatsByUserIdResponce) Reset() <span class="cov0" title="0">{
        *x = GetSurveyStatsByUserIdResponce{}
        mi := &amp;file_proto_survey_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSurveyStatsByUserIdResponce) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSurveyStatsByUserIdResponce) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSurveyStatsByUserIdResponce) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_survey_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSurveyStatsByUserIdResponce.ProtoReflect.Descriptor instead.
func (*GetSurveyStatsByUserIdResponce) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_survey_proto_rawDescGZIP(), []int{11}
}</span>

func (x *GetSurveyStatsByUserIdResponce) GetUserServeyStats() []*UserSurveyStats <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserServeyStats
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_proto_survey_proto protoreflect.FileDescriptor

var file_proto_survey_proto_rawDesc = []byte{
        0x0a, 0x12, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x22, 0x26, 0x0a, 0x14,
        0x47, 0x65, 0x74, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x42, 0x79, 0x49, 0x64, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
        0x52, 0x02, 0x69, 0x64, 0x22, 0x58, 0x0a, 0x06, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x12, 0x0e,
        0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1f,
        0x0a, 0x0b, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0a, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x54, 0x65, 0x78, 0x74, 0x12,
        0x1d, 0x0a, 0x0a, 0x6d, 0x61, 0x78, 0x5f, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x0d, 0x52, 0x09, 0x6d, 0x61, 0x78, 0x52, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x22, 0x80,
        0x01, 0x0a, 0x0e, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x63,
        0x65, 0x12, 0x1b, 0x0a, 0x09, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x49, 0x64, 0x12, 0x17,
        0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52,
        0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x61, 0x74,
        0x69, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x72, 0x61, 0x74, 0x69, 0x6e,
        0x67, 0x22, 0x3f, 0x0a, 0x15, 0x47, 0x65, 0x74, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x42, 0x79,
        0x49, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x63, 0x65, 0x12, 0x26, 0x0a, 0x06, 0x73, 0x75,
        0x72, 0x76, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x73, 0x75, 0x72,
        0x76, 0x65, 0x79, 0x2e, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x52, 0x06, 0x73, 0x75, 0x72, 0x76,
        0x65, 0x79, 0x22, 0x55, 0x0a, 0x13, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x75, 0x72, 0x76,
        0x65, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x3e, 0x0a, 0x0e, 0x73, 0x65, 0x72,
        0x76, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x16, 0x2e, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x2e, 0x53, 0x75, 0x72, 0x76, 0x65,
        0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x63, 0x65, 0x52, 0x0e, 0x73, 0x65, 0x72, 0x76, 0x65,
        0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x63, 0x65, 0x22, 0x30, 0x0a, 0x14, 0x43, 0x72, 0x65,
        0x61, 0x74, 0x65, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x63,
        0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x22, 0x87, 0x02, 0x0a, 0x13,
        0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x42, 0x79, 0x53, 0x75, 0x72,
        0x76, 0x65, 0x79, 0x12, 0x1b, 0x0a, 0x09, 0x73, 0x65, 0x72, 0x76, 0x65, 0x79, 0x5f, 0x69, 0x64,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x73, 0x65, 0x72, 0x76, 0x65, 0x79, 0x49, 0x64,
        0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x65, 0x79, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x73, 0x65, 0x72, 0x76, 0x65, 0x79, 0x54, 0x65, 0x78,
        0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x61, 0x76, 0x67, 0x5f, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x02, 0x52, 0x09, 0x61, 0x76, 0x67, 0x52, 0x61, 0x74, 0x69, 0x6e, 0x67,
        0x12, 0x52, 0x0a, 0x0d, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x5f, 0x63, 0x6f, 0x75, 0x6e,
        0x74, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79,
        0x2e, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x42, 0x79, 0x53, 0x75,
        0x72, 0x76, 0x65, 0x79, 0x2e, 0x52, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x43, 0x6f, 0x75, 0x6e,
        0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0c, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x43,
        0x6f, 0x75, 0x6e, 0x74, 0x1a, 0x3f, 0x0a, 0x11, 0x52, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x43,
        0x6f, 0x75, 0x6e, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x31, 0x0a, 0x1f, 0x47, 0x65, 0x74, 0x53, 0x75, 0x72, 0x76,
        0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x42, 0x79, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x49,
        0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x22, 0x71, 0x0a, 0x20, 0x47, 0x65, 0x74, 0x53,
        0x75, 0x72, 0x76, 0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x42, 0x79, 0x53, 0x75, 0x72, 0x76,
        0x65, 0x79, 0x49, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x63, 0x65, 0x12, 0x4d, 0x0a, 0x13,
        0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x42, 0x79, 0x53, 0x75, 0x72,
        0x76, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x73, 0x75, 0x72, 0x76,
        0x65, 0x79, 0x2e, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x42, 0x79,
        0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x52, 0x13, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x53, 0x74,
        0x61, 0x74, 0x73, 0x42, 0x79, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x22, 0x6b, 0x0a, 0x0f, 0x55,
        0x73, 0x65, 0x72, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x1b,
        0x0a, 0x09, 0x73, 0x65, 0x72, 0x76, 0x65, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x0d, 0x52, 0x08, 0x73, 0x65, 0x72, 0x76, 0x65, 0x79, 0x49, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x73,
        0x65, 0x72, 0x76, 0x65, 0x79, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0a, 0x73, 0x65, 0x72, 0x76, 0x65, 0x79, 0x54, 0x65, 0x78, 0x74, 0x12, 0x1a, 0x0a, 0x08,
        0x61, 0x6e, 0x73, 0x77, 0x65, 0x72, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08,
        0x61, 0x6e, 0x73, 0x77, 0x65, 0x72, 0x65, 0x64, 0x22, 0x37, 0x0a, 0x1d, 0x47, 0x65, 0x74, 0x53,
        0x75, 0x72, 0x76, 0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72,
        0x49, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x75, 0x73, 0x65,
        0x72, 0x49, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49,
        0x64, 0x22, 0x63, 0x0a, 0x1e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x53, 0x74,
        0x61, 0x74, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x63, 0x65, 0x12, 0x41, 0x0a, 0x0f, 0x75, 0x73, 0x65, 0x72, 0x53, 0x65, 0x72, 0x76, 0x65,
        0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x73,
        0x75, 0x72, 0x76, 0x65, 0x79, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79,
        0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x0f, 0x75, 0x73, 0x65, 0x72, 0x53, 0x65, 0x72, 0x76, 0x65,
        0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x32, 0x88, 0x03, 0x0a, 0x0d, 0x53, 0x75, 0x72, 0x76, 0x65,
        0x79, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x4e, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x53,
        0x75, 0x72, 0x76, 0x65, 0x79, 0x42, 0x79, 0x49, 0x64, 0x12, 0x1c, 0x2e, 0x73, 0x75, 0x72, 0x76,
        0x65, 0x79, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x42, 0x79, 0x49, 0x64,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79,
        0x2e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x42, 0x79, 0x49, 0x64, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x63, 0x65, 0x22, 0x00, 0x12, 0x4b, 0x0a, 0x0c, 0x43, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x12, 0x1b, 0x2e, 0x73, 0x75, 0x72, 0x76, 0x65,
        0x79, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x2e, 0x43,
        0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x63, 0x65, 0x22, 0x00, 0x12, 0x6f, 0x0a, 0x18, 0x47, 0x65, 0x74, 0x53, 0x75, 0x72, 0x76,
        0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x42, 0x79, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x49,
        0x64, 0x12, 0x27, 0x2e, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x75,
        0x72, 0x76, 0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x42, 0x79, 0x53, 0x75, 0x72, 0x76, 0x65,
        0x79, 0x49, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x28, 0x2e, 0x73, 0x75, 0x72,
        0x76, 0x65, 0x79, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x53, 0x74, 0x61,
        0x74, 0x73, 0x42, 0x79, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x49, 0x64, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x63, 0x65, 0x22, 0x00, 0x12, 0x69, 0x0a, 0x16, 0x47, 0x65, 0x74, 0x53, 0x75, 0x72,
        0x76, 0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64,
        0x12, 0x25, 0x2e, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x72,
        0x76, 0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79,
        0x2e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x72, 0x76, 0x65, 0x79, 0x53, 0x74, 0x61, 0x74, 0x73, 0x42,
        0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x63, 0x65, 0x22,
        0x00, 0x42, 0x07, 0x5a, 0x05, 0x2e, 0x3b, 0x67, 0x65, 0x6e, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x33,
}

var (
        file_proto_survey_proto_rawDescOnce sync.Once
        file_proto_survey_proto_rawDescData = file_proto_survey_proto_rawDesc
)

func file_proto_survey_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_survey_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_survey_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_survey_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_proto_survey_proto_rawDescData</span>
}

var file_proto_survey_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_proto_survey_proto_goTypes = []any{
        (*GetSurveyByIdRequest)(nil),             // 0: survey.GetSurveyByIdRequest
        (*Survey)(nil),                           // 1: survey.Survey
        (*SurveyResponce)(nil),                   // 2: survey.SurveyResponce
        (*GetSurveyByIdResponce)(nil),            // 3: survey.GetSurveyByIdResponce
        (*CreateSurveyRequest)(nil),              // 4: survey.CreateSurveyRequest
        (*CreateSurveyResponce)(nil),             // 5: survey.CreateSurveyResponce
        (*SurveyStatsBySurvey)(nil),              // 6: survey.SurveyStatsBySurvey
        (*GetSurveyStatsBySurveyIdRequest)(nil),  // 7: survey.GetSurveyStatsBySurveyIdRequest
        (*GetSurveyStatsBySurveyIdResponce)(nil), // 8: survey.GetSurveyStatsBySurveyIdResponce
        (*UserSurveyStats)(nil),                  // 9: survey.UserSurveyStats
        (*GetSurveyStatsByUserIdRequest)(nil),    // 10: survey.GetSurveyStatsByUserIdRequest
        (*GetSurveyStatsByUserIdResponce)(nil),   // 11: survey.GetSurveyStatsByUserIdResponce
        nil,                                      // 12: survey.SurveyStatsBySurvey.RatingsCountEntry
}
var file_proto_survey_proto_depIdxs = []int32{
        1,  // 0: survey.GetSurveyByIdResponce.survey:type_name -&gt; survey.Survey
        2,  // 1: survey.CreateSurveyRequest.serveyResponce:type_name -&gt; survey.SurveyResponce
        12, // 2: survey.SurveyStatsBySurvey.ratings_count:type_name -&gt; survey.SurveyStatsBySurvey.RatingsCountEntry
        6,  // 3: survey.GetSurveyStatsBySurveyIdResponce.surveyStatsBySurvey:type_name -&gt; survey.SurveyStatsBySurvey
        9,  // 4: survey.GetSurveyStatsByUserIdResponce.userServeyStats:type_name -&gt; survey.UserSurveyStats
        0,  // 5: survey.SurveyService.GetSurveyById:input_type -&gt; survey.GetSurveyByIdRequest
        4,  // 6: survey.SurveyService.CreateSurvey:input_type -&gt; survey.CreateSurveyRequest
        7,  // 7: survey.SurveyService.GetSurveyStatsBySurveyId:input_type -&gt; survey.GetSurveyStatsBySurveyIdRequest
        10, // 8: survey.SurveyService.GetSurveyStatsByUserId:input_type -&gt; survey.GetSurveyStatsByUserIdRequest
        3,  // 9: survey.SurveyService.GetSurveyById:output_type -&gt; survey.GetSurveyByIdResponce
        5,  // 10: survey.SurveyService.CreateSurvey:output_type -&gt; survey.CreateSurveyResponce
        8,  // 11: survey.SurveyService.GetSurveyStatsBySurveyId:output_type -&gt; survey.GetSurveyStatsBySurveyIdResponce
        11, // 12: survey.SurveyService.GetSurveyStatsByUserId:output_type -&gt; survey.GetSurveyStatsByUserIdResponce
        9,  // [9:13] is the sub-list for method output_type
        5,  // [5:9] is the sub-list for method input_type
        5,  // [5:5] is the sub-list for extension type_name
        5,  // [5:5] is the sub-list for extension extendee
        0,  // [0:5] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_proto_survey_proto_init() }</span>
func file_proto_survey_proto_init() <span class="cov0" title="0">{
        if File_proto_survey_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_proto_survey_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   13,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_survey_proto_goTypes,
                DependencyIndexes: file_proto_survey_proto_depIdxs,
                MessageInfos:      file_proto_survey_proto_msgTypes,
        }.Build()
        File_proto_survey_proto = out.File
        file_proto_survey_proto_rawDesc = nil
        file_proto_survey_proto_goTypes = nil
        file_proto_survey_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: proto/survey.proto

package gen

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        SurveyService_GetSurveyById_FullMethodName            = "/survey.SurveyService/GetSurveyById"
        SurveyService_CreateSurvey_FullMethodName             = "/survey.SurveyService/CreateSurvey"
        SurveyService_GetSurveyStatsBySurveyId_FullMethodName = "/survey.SurveyService/GetSurveyStatsBySurveyId"
        SurveyService_GetSurveyStatsByUserId_FullMethodName   = "/survey.SurveyService/GetSurveyStatsByUserId"
)

// SurveyServiceClient is the client API for SurveyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SurveyServiceClient interface {
        GetSurveyById(ctx context.Context, in *GetSurveyByIdRequest, opts ...grpc.CallOption) (*GetSurveyByIdResponce, error)
        CreateSurvey(ctx context.Context, in *CreateSurveyRequest, opts ...grpc.CallOption) (*CreateSurveyResponce, error)
        GetSurveyStatsBySurveyId(ctx context.Context, in *GetSurveyStatsBySurveyIdRequest, opts ...grpc.CallOption) (*GetSurveyStatsBySurveyIdResponce, error)
        GetSurveyStatsByUserId(ctx context.Context, in *GetSurveyStatsByUserIdRequest, opts ...grpc.CallOption) (*GetSurveyStatsByUserIdResponce, error)
}

type surveyServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewSurveyServiceClient(cc grpc.ClientConnInterface) SurveyServiceClient <span class="cov0" title="0">{
        return &amp;surveyServiceClient{cc}
}</span>

func (c *surveyServiceClient) GetSurveyById(ctx context.Context, in *GetSurveyByIdRequest, opts ...grpc.CallOption) (*GetSurveyByIdResponce, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetSurveyByIdResponce)
        err := c.cc.Invoke(ctx, SurveyService_GetSurveyById_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *surveyServiceClient) CreateSurvey(ctx context.Context, in *CreateSurveyRequest, opts ...grpc.CallOption) (*CreateSurveyResponce, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateSurveyResponce)
        err := c.cc.Invoke(ctx, SurveyService_CreateSurvey_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *surveyServiceClient) GetSurveyStatsBySurveyId(ctx context.Context, in *GetSurveyStatsBySurveyIdRequest, opts ...grpc.CallOption) (*GetSurveyStatsBySurveyIdResponce, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetSurveyStatsBySurveyIdResponce)
        err := c.cc.Invoke(ctx, SurveyService_GetSurveyStatsBySurveyId_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *surveyServiceClient) GetSurveyStatsByUserId(ctx context.Context, in *GetSurveyStatsByUserIdRequest, opts ...grpc.CallOption) (*GetSurveyStatsByUserIdResponce, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetSurveyStatsByUserIdResponce)
        err := c.cc.Invoke(ctx, SurveyService_GetSurveyStatsByUserId_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// SurveyServiceServer is the server API for SurveyService service.
// All implementations must embed UnimplementedSurveyServiceServer
// for forward compatibility.
type SurveyServiceServer interface {
        GetSurveyById(context.Context, *GetSurveyByIdRequest) (*GetSurveyByIdResponce, error)
        CreateSurvey(context.Context, *CreateSurveyRequest) (*CreateSurveyResponce, error)
        GetSurveyStatsBySurveyId(context.Context, *GetSurveyStatsBySurveyIdRequest) (*GetSurveyStatsBySurveyIdResponce, error)
        GetSurveyStatsByUserId(context.Context, *GetSurveyStatsByUserIdRequest) (*GetSurveyStatsByUserIdResponce, error)
        mustEmbedUnimplementedSurveyServiceServer()
}

// UnimplementedSurveyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSurveyServiceServer struct{}

func (UnimplementedSurveyServiceServer) GetSurveyById(context.Context, *GetSurveyByIdRequest) (*GetSurveyByIdResponce, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSurveyById not implemented")
}</span>
func (UnimplementedSurveyServiceServer) CreateSurvey(context.Context, *CreateSurveyRequest) (*CreateSurveyResponce, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateSurvey not implemented")
}</span>
func (UnimplementedSurveyServiceServer) GetSurveyStatsBySurveyId(context.Context, *GetSurveyStatsBySurveyIdRequest) (*GetSurveyStatsBySurveyIdResponce, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSurveyStatsBySurveyId not implemented")
}</span>
func (UnimplementedSurveyServiceServer) GetSurveyStatsByUserId(context.Context, *GetSurveyStatsByUserIdRequest) (*GetSurveyStatsByUserIdResponce, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSurveyStatsByUserId not implemented")
}</span>
func (UnimplementedSurveyServiceServer) mustEmbedUnimplementedSurveyServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedSurveyServiceServer) testEmbeddedByValue()                       {<span class="cov0" title="0">}</span>

// UnsafeSurveyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SurveyServiceServer will
// result in compilation errors.
type UnsafeSurveyServiceServer interface {
        mustEmbedUnimplementedSurveyServiceServer()
}

func RegisterSurveyServiceServer(s grpc.ServiceRegistrar, srv SurveyServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedSurveyServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;SurveyService_ServiceDesc, srv)</span>
}

func _SurveyService_GetSurveyById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetSurveyByIdRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(SurveyServiceServer).GetSurveyById(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: SurveyService_GetSurveyById_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(SurveyServiceServer).GetSurveyById(ctx, req.(*GetSurveyByIdRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _SurveyService_CreateSurvey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateSurveyRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(SurveyServiceServer).CreateSurvey(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: SurveyService_CreateSurvey_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(SurveyServiceServer).CreateSurvey(ctx, req.(*CreateSurveyRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _SurveyService_GetSurveyStatsBySurveyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetSurveyStatsBySurveyIdRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(SurveyServiceServer).GetSurveyStatsBySurveyId(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: SurveyService_GetSurveyStatsBySurveyId_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(SurveyServiceServer).GetSurveyStatsBySurveyId(ctx, req.(*GetSurveyStatsBySurveyIdRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _SurveyService_GetSurveyStatsByUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetSurveyStatsByUserIdRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(SurveyServiceServer).GetSurveyStatsByUserId(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: SurveyService_GetSurveyStatsByUserId_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(SurveyServiceServer).GetSurveyStatsByUserId(ctx, req.(*GetSurveyStatsByUserIdRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// SurveyService_ServiceDesc is the grpc.ServiceDesc for SurveyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SurveyService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "survey.SurveyService",
        HandlerType: (*SurveyServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetSurveyById",
                        Handler:    _SurveyService_GetSurveyById_Handler,
                },
                {
                        MethodName: "CreateSurvey",
                        Handler:    _SurveyService_CreateSurvey_Handler,
                },
                {
                        MethodName: "GetSurveyStatsBySurveyId",
                        Handler:    _SurveyService_GetSurveyStatsBySurveyId_Handler,
                },
                {
                        MethodName: "GetSurveyStatsByUserId",
                        Handler:    _SurveyService_GetSurveyStatsByUserId_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/survey.proto",
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package grpc

import (
        "2024_2_ThereWillBeName/internal/models"
        surveyPkg "2024_2_ThereWillBeName/internal/pkg/survey"
        "2024_2_ThereWillBeName/internal/pkg/survey/delivery/grpc/gen"
        "context"
        "log/slog"
)

//go:generate protoc -I . proto/survey.proto --go_out=./gen --go-grpc_out=./gen

type GrpcSurveyHandler struct {
        gen.UnimplementedSurveyServiceServer
        uc     surveyPkg.SurveysUsecase
        logger *slog.Logger
}

func NewGrpcSurveyHandler(uc surveyPkg.SurveysUsecase, logger *slog.Logger) *GrpcSurveyHandler <span class="cov0" title="0">{
        return &amp;GrpcSurveyHandler{uc: uc, logger: logger}
}</span>

func (s *GrpcSurveyHandler) GetSurveyById(ctx context.Context, req *gen.GetSurveyByIdRequest) (*gen.GetSurveyByIdResponce, error) <span class="cov0" title="0">{
        survey, err := s.uc.GetSurveyById(ctx, uint(req.Id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">surveyResponce := &amp;gen.Survey{
                Id:         uint32(survey.Id),
                SurveyText: survey.SurveyText,
                MaxRating:  uint32(survey.MaxRating),
        }
        return &amp;gen.GetSurveyByIdResponce{Survey: surveyResponce}, nil</span>
}

func (s *GrpcSurveyHandler) CreateSurvey(ctx context.Context, req *gen.CreateSurveyRequest) (*gen.CreateSurveyResponce, error) <span class="cov0" title="0">{
        survey := models.SurveyResponse{
                SurveyId: uint(req.ServeyResponce.SurveyId),
                UserId:   uint(req.ServeyResponce.UserId),
                Rating:   int(req.ServeyResponce.Rating),
        }
        err := s.uc.CreateSurveyResponse(ctx, survey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;gen.CreateSurveyResponce{Success: true}, nil</span>
}

func (s *GrpcSurveyHandler) GetSurveyStatsBySurveyId(ctx context.Context, req *gen.GetSurveyStatsBySurveyIdRequest) (*gen.GetSurveyStatsBySurveyIdResponce, error) <span class="cov0" title="0">{
        res, err := s.uc.GetSurveyStatsBySurveyId(ctx, uint(req.Id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ratingsCount := make(map[int32]int32)
        for k, v := range res.RatingsCount </span><span class="cov0" title="0">{
                ratingsCount[int32(k)] = int32(v)
        }</span>
        <span class="cov0" title="0">statsResponce := &amp;gen.SurveyStatsBySurvey{
                ServeyId:     uint32(res.SurveyId),
                ServeyText:   res.SurveyText,
                AvgRating:    float32(res.AvgRating),
                RatingsCount: ratingsCount,
        }
        return &amp;gen.GetSurveyStatsBySurveyIdResponce{SurveyStatsBySurvey: statsResponce}, nil</span>
}

func (s *GrpcSurveyHandler) GetSurveyStatsByUserId(ctx context.Context, req *gen.GetSurveyStatsByUserIdRequest) (*gen.GetSurveyStatsByUserIdResponce, error) <span class="cov0" title="0">{
        res, err := s.uc.GetSurveyStatsByUserId(ctx, uint(req.UserId))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">serveyStatsResponce := make([]*gen.UserSurveyStats, len(res))
        for k, v := range res </span><span class="cov0" title="0">{
                serveyStatsResponce[k] = &amp;gen.UserSurveyStats{
                        ServeyId:   uint32(v.SurveyId),
                        ServeyText: v.SurveyText,
                        Answered:   v.Answered,
                }
        }</span>
        <span class="cov0" title="0">return &amp;gen.GetSurveyStatsByUserIdResponce{UserServeyStats: serveyStatsResponce}, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package http

import (
        "2024_2_ThereWillBeName/internal/models"
        httpresponse "2024_2_ThereWillBeName/internal/pkg/httpresponses"
        log "2024_2_ThereWillBeName/internal/pkg/logger"
        "2024_2_ThereWillBeName/internal/pkg/middleware"
        surveysGen "2024_2_ThereWillBeName/internal/pkg/survey/delivery/grpc/gen"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
)

type SurveyHandler struct {
        client surveysGen.SurveyServiceClient
        logger *slog.Logger
}

func NewSurveyHandler(client surveysGen.SurveyServiceClient, logger *slog.Logger) *SurveyHandler <span class="cov0" title="0">{
        return &amp;SurveyHandler{
                client: client,
                logger: logger,
        }
}</span>

func ErrorCheck(err error, action string, logger *slog.Logger, ctx context.Context) (httpresponse.ErrorResponse, int) <span class="cov0" title="0">{
        if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{

                logContext := log.AppendCtx(ctx, slog.String("action", action))
                logger.ErrorContext(logContext, fmt.Sprintf("Error during %s operation", action), slog.Any("error", err.Error()))

                response := httpresponse.ErrorResponse{
                        Message: "Invalid request",
                }
                return response, http.StatusNotFound
        }</span>
        <span class="cov0" title="0">logContext := log.AppendCtx(ctx, slog.String("action", action))
        logger.ErrorContext(logContext, fmt.Sprintf("Failed to %s survey", action), slog.Any("error", err.Error()))
        response := httpresponse.ErrorResponse{
                Message: fmt.Sprintf("Failed to %s survey", action),
        }
        return response, http.StatusInternalServerError</span>
}

func (h *SurveyHandler) GetSurveyById(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for getting a survey")

        _, ok := r.Context().Value(middleware.IdKey).(uint)

        if !ok </span><span class="cov0" title="0">{
                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">vars := mux.Vars(r)
        surveyIdStr := vars["id"]

        surveyId, err := strconv.ParseUint(surveyIdStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Failed to parse survey ID", slog.String("surveyID", surveyIdStr), slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid survey ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">survey, err := h.client.GetSurveyById(r.Context(), &amp;surveysGen.GetSurveyByIdRequest{Id: uint32(surveyId)})
        if err != nil </span><span class="cov0" title="0">{
                logCtx := log.AppendCtx(r.Context(), slog.String("surveyId", surveyIdStr))
                response, status := ErrorCheck(err, "retrieve", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully got survey by ID")

        httpresponse.SendJSONResponse(w, survey, http.StatusOK, h.logger)</span>
}

func (h *SurveyHandler) CreateSurveyResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request to  create survey response")

        _, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{
                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">var surveyResponse models.SurveyResponse
        err := json.NewDecoder(r.Body).Decode(&amp;surveyResponse)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Failed to decode survey response", slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid request body",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">_, err = h.client.CreateSurvey(r.Context(), &amp;surveysGen.CreateSurveyRequest{ServeyResponce: &amp;surveysGen.SurveyResponce{
                SurveyId: uint32(surveyResponse.SurveyId),
                UserId:   uint32(surveyResponse.UserId),
                Rating:   uint32(surveyResponse.Rating),
        }})
        if err != nil </span><span class="cov0" title="0">{
                logCtx := log.AppendCtx(r.Context(), slog.String("surveyID", fmt.Sprint(surveyResponse.SurveyId)))
                response, status := ErrorCheck(err, "submit", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully submitted survey response")

        httpresponse.SendJSONResponse(w, nil, http.StatusOK, h.logger)</span>
}

func (h *SurveyHandler) GetSurveyStatsBySurveyId(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for survey statistics by survey ID")

        _, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{
                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">vars := mux.Vars(r)
        surveyIdStr := vars["id"]

        surveyId, err := strconv.ParseUint(surveyIdStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Failed to parse survey ID", slog.String("surveyID", surveyIdStr), slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid survey ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.client.GetSurveyStatsBySurveyId(r.Context(), &amp;surveysGen.GetSurveyStatsBySurveyIdRequest{
                Id: uint32(surveyId),
        })
        if err != nil </span><span class="cov0" title="0">{
                logCtx := log.AppendCtx(r.Context(), slog.String("surveyId", surveyIdStr))
                response, status := ErrorCheck(err, "retrieve survey statistics", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully retrieved survey statistics by ID")

        httpresponse.SendJSONResponse(w, stats, http.StatusOK, h.logger)</span>
}

func (h *SurveyHandler) GetSurveyStatsByUserId(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for survey statistics by survey ID")

        _, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{
                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">vars := mux.Vars(r)
        userIdStr := vars["id"]

        userId, err := strconv.ParseUint(userIdStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Failed to parse user ID", slog.String("userID", userIdStr), slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid user ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.client.GetSurveyStatsByUserId(r.Context(), &amp;surveysGen.GetSurveyStatsByUserIdRequest{
                UserId: uint32(userId),
        })
        if err != nil </span><span class="cov0" title="0">{
                logCtx := log.AppendCtx(r.Context(), slog.String("userId", userIdStr))
                response, status := ErrorCheck(err, "retrieve survey statistics by user", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "Successfully retrieved survey statistics by user ID")

        httpresponse.SendJSONResponse(w, stats, http.StatusOK, h.logger)</span>

}
</pre>
		
		<pre class="file" id="file55" style="display: none">package repo

import (
        "2024_2_ThereWillBeName/internal/models"
        "context"
        "database/sql"
        _ "embed"
        "fmt"
        "log"
)

type SurveyRepository struct {
        db *sql.DB
}

func NewPLaceRepository(db *sql.DB) *SurveyRepository <span class="cov0" title="0">{
        return &amp;SurveyRepository{db: db}
}</span>

func (r *SurveyRepository) GetSurveyById(ctx context.Context, surveyId uint) (models.Survey, error) <span class="cov0" title="0">{
        query := `SELECT id, survey_text, max_rating FROM survey WHERE id=$1`
        row := r.db.QueryRowContext(ctx, query, surveyId)

        var survey models.Survey
        err := row.Scan(&amp;survey.Id, &amp;survey.SurveyText, &amp;survey.MaxRating)
        if err != nil </span><span class="cov0" title="0">{
                return models.Survey{}, fmt.Errorf("could not retrieve survey: %w", err)
        }</span>
        <span class="cov0" title="0">return survey, nil</span>
}

func (r *SurveyRepository) CreateSurveyResponse(ctx context.Context, response models.SurveyResponse) error <span class="cov0" title="0">{
        query := `INSERT INTO user_survey (survey_id, user_id, rating) VALUES  ($1, $2, $3)`
        log.Println(response.SurveyId, response.UserId, response.Rating)
        _, err := r.db.ExecContext(ctx, query, response.SurveyId, response.UserId, response.Rating)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create survey: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *SurveyRepository) GetSurveyStatsBySurveyId(ctx context.Context, surveyId uint) (models.SurveyStatsBySurvey, error) <span class="cov0" title="0">{
        query := `SELECT 
            s.id AS survey_id,
            s.survey_text,
            us.rating,
            COUNT(us.user_id) AS count_of_users
        FROM 
            survey s
        LEFT JOIN 
            user_survey us ON s.id = us.survey_id
        WHERE 
                s.id = $1
        GROUP BY 
                s.id, s.survey_text, us.rating
        ORDER BY 
                s.id, us.rating;`

        rows, err := r.db.QueryContext(ctx, query, surveyId)
        if err != nil </span><span class="cov0" title="0">{
                return models.SurveyStatsBySurvey{}, fmt.Errorf("failed to retrieve survey stats: %w", models.ErrInternal)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var surveyStats models.SurveyStatsBySurvey
        surveyStats.RatingsCount = make(map[int]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var rating int
                var count int
                err := rows.Scan(&amp;surveyStats.SurveyId, &amp;surveyStats.SurveyText, &amp;rating, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return models.SurveyStatsBySurvey{}, fmt.Errorf("failed to scan survey stats row: %w", models.ErrInternal)
                }</span>
                <span class="cov0" title="0">surveyStats.RatingsCount[rating] = count</span>
        }

        <span class="cov0" title="0">if len(surveyStats.RatingsCount) == 0 </span><span class="cov0" title="0">{
                return models.SurveyStatsBySurvey{}, fmt.Errorf("no survey stats found: %w", models.ErrNotFound)
        }</span>

        // Вычисление среднего рейтинга
        <span class="cov0" title="0">totalRatings := 0
        totalCount := 0
        for rating, count := range surveyStats.RatingsCount </span><span class="cov0" title="0">{
                totalRatings += rating * count
                totalCount += count
        }</span>
        <span class="cov0" title="0">if totalCount &gt; 0 </span><span class="cov0" title="0">{
                surveyStats.AvgRating = float64(totalRatings) / float64(totalCount)
        }</span>

        <span class="cov0" title="0">return surveyStats, nil</span>
}

func (r *SurveyRepository) GetSurveyStatsByUserId(ctx context.Context, userId uint) ([]models.UserSurveyStats, error) <span class="cov0" title="0">{
        query := `SELECT 
    s.id AS survey_id,
    s.survey_text,
    CASE 
        WHEN us.user_id IS NOT NULL THEN TRUE
        ELSE FALSE
    END AS participated
FROM 
    survey s
LEFT JOIN 
    user_survey us ON s.id = us.survey_id AND us.user_id = $1        
ORDER BY 
    s.id;`
        rows, err := r.db.QueryContext(ctx, query, userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to retrieve user stats: %w", models.ErrInternal)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var userStats []models.UserSurveyStats
        for rows.Next() </span><span class="cov0" title="0">{
                var userStat models.UserSurveyStats
                if err := rows.Scan(&amp;userStat.SurveyId, &amp;userStat.SurveyText, &amp;userStat.Answered); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user stat row: %w", models.ErrInternal)
                }</span>
                <span class="cov0" title="0">userStats = append(userStats, userStat)</span>
        }
        <span class="cov0" title="0">if len(userStats) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no user stats found: %w", models.ErrNotFound)
        }</span>

        <span class="cov0" title="0">return userStats, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package usecase

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/survey"
        "context"
        "errors"
        "fmt"
        "log"
)

type SurveysUseCaseImpl struct {
        surveyRepo survey.SurveysRepo
}

func NewSurveysUsecase(repo survey.SurveysRepo) *SurveysUseCaseImpl <span class="cov0" title="0">{
        return &amp;SurveysUseCaseImpl{
                surveyRepo: repo,
        }
}</span>

func (u *SurveysUseCaseImpl) GetSurveyById(ctx context.Context, surveyId uint) (models.Survey, error) <span class="cov0" title="0">{
        survey, err := u.surveyRepo.GetSurveyById(ctx, surveyId)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        return models.Survey{}, fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return models.Survey{}, fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }
        <span class="cov0" title="0">return survey, nil</span>
}

func (u *SurveysUseCaseImpl) CreateSurveyResponse(ctx context.Context, response models.SurveyResponse) error <span class="cov0" title="0">{
        survey, err := u.surveyRepo.GetSurveyById(ctx, response.SurveyId)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        log.Println(err)
                        return fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov0" title="0">log.Println(err)
                return fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }

        <span class="cov0" title="0">if response.Rating &gt; survey.MaxRating </span><span class="cov0" title="0">{
                log.Println(err)
                return fmt.Errorf("invalid rating: cannot be higher than the maximum rating of %d", survey.MaxRating)
        }</span>

        <span class="cov0" title="0">err = u.surveyRepo.CreateSurveyResponse(ctx, response)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        log.Println(err)
                        return fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov0" title="0">log.Println(err)
                return fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (u *SurveysUseCaseImpl) GetSurveyStatsBySurveyId(ctx context.Context, surveyId uint) (models.SurveyStatsBySurvey, error) <span class="cov0" title="0">{
        survey, err := u.surveyRepo.GetSurveyStatsBySurveyId(ctx, surveyId)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        log.Println(err)
                        return models.SurveyStatsBySurvey{}, fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov0" title="0">log.Println(err)
                return models.SurveyStatsBySurvey{}, fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }
        <span class="cov0" title="0">return survey, nil</span>
}

func (u *SurveysUseCaseImpl) GetSurveyStatsByUserId(ctx context.Context, userId uint) ([]models.UserSurveyStats, error) <span class="cov0" title="0">{
        stats, err := u.surveyRepo.GetSurveyStatsByUserId(ctx, userId)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }
        <span class="cov0" title="0">return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v4.25.1
// source: proto/trips.proto

package gen

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CreateTripRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Trip *Trip `protobuf:"bytes,1,opt,name=trip,proto3" json:"trip,omitempty"`
}

func (x *CreateTripRequest) Reset() <span class="cov0" title="0">{
        *x = CreateTripRequest{}
        mi := &amp;file_proto_trips_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateTripRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateTripRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateTripRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateTripRequest.ProtoReflect.Descriptor instead.
func (*CreateTripRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CreateTripRequest) GetTrip() *Trip <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trip
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateTripRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Trip *Trip `protobuf:"bytes,1,opt,name=trip,proto3" json:"trip,omitempty"`
}

func (x *UpdateTripRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateTripRequest{}
        mi := &amp;file_proto_trips_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateTripRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateTripRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateTripRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateTripRequest.ProtoReflect.Descriptor instead.
func (*UpdateTripRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{1}
}</span>

func (x *UpdateTripRequest) GetTrip() *Trip <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trip
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteTripRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *DeleteTripRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteTripRequest{}
        mi := &amp;file_proto_trips_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteTripRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteTripRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteTripRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteTripRequest.ProtoReflect.Descriptor instead.
func (*DeleteTripRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{2}
}</span>

func (x *DeleteTripRequest) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetTripsByUserIDRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId uint32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Limit  int32  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset int32  `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *GetTripsByUserIDRequest) Reset() <span class="cov0" title="0">{
        *x = GetTripsByUserIDRequest{}
        mi := &amp;file_proto_trips_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTripsByUserIDRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTripsByUserIDRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTripsByUserIDRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTripsByUserIDRequest.ProtoReflect.Descriptor instead.
func (*GetTripsByUserIDRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetTripsByUserIDRequest) GetUserId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetTripsByUserIDRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetTripsByUserIDRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetTripsByUserIDResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Trips []*Trip `protobuf:"bytes,1,rep,name=trips,proto3" json:"trips,omitempty"`
}

func (x *GetTripsByUserIDResponse) Reset() <span class="cov0" title="0">{
        *x = GetTripsByUserIDResponse{}
        mi := &amp;file_proto_trips_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTripsByUserIDResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTripsByUserIDResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTripsByUserIDResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTripsByUserIDResponse.ProtoReflect.Descriptor instead.
func (*GetTripsByUserIDResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{4}
}</span>

func (x *GetTripsByUserIDResponse) GetTrips() []*Trip <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trips
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetTripRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TripId uint32 `protobuf:"varint,1,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
}

func (x *GetTripRequest) Reset() <span class="cov0" title="0">{
        *x = GetTripRequest{}
        mi := &amp;file_proto_trips_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTripRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTripRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTripRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTripRequest.ProtoReflect.Descriptor instead.
func (*GetTripRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{5}
}</span>

func (x *GetTripRequest) GetTripId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetTripResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Trip *Trip `protobuf:"bytes,1,opt,name=trip,proto3" json:"trip,omitempty"`
}

func (x *GetTripResponse) Reset() <span class="cov0" title="0">{
        *x = GetTripResponse{}
        mi := &amp;file_proto_trips_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTripResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTripResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTripResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTripResponse.ProtoReflect.Descriptor instead.
func (*GetTripResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetTripResponse) GetTrip() *Trip <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trip
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddPlaceToTripRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TripId  uint32 `protobuf:"varint,1,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
        PlaceId uint32 `protobuf:"varint,2,opt,name=place_id,json=placeId,proto3" json:"place_id,omitempty"`
}

func (x *AddPlaceToTripRequest) Reset() <span class="cov0" title="0">{
        *x = AddPlaceToTripRequest{}
        mi := &amp;file_proto_trips_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddPlaceToTripRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddPlaceToTripRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddPlaceToTripRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddPlaceToTripRequest.ProtoReflect.Descriptor instead.
func (*AddPlaceToTripRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{7}
}</span>

func (x *AddPlaceToTripRequest) GetTripId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AddPlaceToTripRequest) GetPlaceId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlaceId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type AddPhotosToTripRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TripId uint32   `protobuf:"varint,1,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
        Photos []string `protobuf:"bytes,2,rep,name=photos,proto3" json:"photos,omitempty"`
}

func (x *AddPhotosToTripRequest) Reset() <span class="cov0" title="0">{
        *x = AddPhotosToTripRequest{}
        mi := &amp;file_proto_trips_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddPhotosToTripRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddPhotosToTripRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddPhotosToTripRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddPhotosToTripRequest.ProtoReflect.Descriptor instead.
func (*AddPhotosToTripRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{8}
}</span>

func (x *AddPhotosToTripRequest) GetTripId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AddPhotosToTripRequest) GetPhotos() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Photos
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddPhotosToTripResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Photos []*Photo `protobuf:"bytes,2,rep,name=photos,proto3" json:"photos,omitempty"`
}

func (x *AddPhotosToTripResponse) Reset() <span class="cov0" title="0">{
        *x = AddPhotosToTripResponse{}
        mi := &amp;file_proto_trips_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddPhotosToTripResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddPhotosToTripResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddPhotosToTripResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddPhotosToTripResponse.ProtoReflect.Descriptor instead.
func (*AddPhotosToTripResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{9}
}</span>

func (x *AddPhotosToTripResponse) GetPhotos() []*Photo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Photos
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Photo struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        PhotoPath string `protobuf:"bytes,1,opt,name=photoPath,proto3" json:"photoPath,omitempty"`
}

func (x *Photo) Reset() <span class="cov0" title="0">{
        *x = Photo{}
        mi := &amp;file_proto_trips_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Photo) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Photo) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Photo) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Photo.ProtoReflect.Descriptor instead.
func (*Photo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{10}
}</span>

func (x *Photo) GetPhotoPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PhotoPath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeletePhotoRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TripId    uint32 `protobuf:"varint,1,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
        PhotoPath string `protobuf:"bytes,2,opt,name=photo_path,json=photoPath,proto3" json:"photo_path,omitempty"`
}

func (x *DeletePhotoRequest) Reset() <span class="cov0" title="0">{
        *x = DeletePhotoRequest{}
        mi := &amp;file_proto_trips_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeletePhotoRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeletePhotoRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeletePhotoRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeletePhotoRequest.ProtoReflect.Descriptor instead.
func (*DeletePhotoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{11}
}</span>

func (x *DeletePhotoRequest) GetTripId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DeletePhotoRequest) GetPhotoPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PhotoPath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type EmptyResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *EmptyResponse) Reset() <span class="cov0" title="0">{
        *x = EmptyResponse{}
        mi := &amp;file_proto_trips_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *EmptyResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EmptyResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EmptyResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EmptyResponse.ProtoReflect.Descriptor instead.
func (*EmptyResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{12}
}</span>

type Trip struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id          uint32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        UserId      uint32                 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Name        string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
        Description string                 `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
        CityId      uint32                 `protobuf:"varint,5,opt,name=city_id,json=cityId,proto3" json:"city_id,omitempty"`
        StartDate   string                 `protobuf:"bytes,6,opt,name=start_date,json=startDate,proto3" json:"start_date,omitempty"`
        EndDate     string                 `protobuf:"bytes,7,opt,name=end_date,json=endDate,proto3" json:"end_date,omitempty"`
        Private     bool                   `protobuf:"varint,8,opt,name=private,proto3" json:"private,omitempty"`
        Photos      []string               `protobuf:"bytes,9,rep,name=photos,proto3" json:"photos,omitempty"`
        CreatedAt   *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (x *Trip) Reset() <span class="cov0" title="0">{
        *x = Trip{}
        mi := &amp;file_proto_trips_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Trip) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Trip) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Trip) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_trips_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Trip.ProtoReflect.Descriptor instead.
func (*Trip) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_trips_proto_rawDescGZIP(), []int{13}
}</span>

func (x *Trip) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Trip) GetUserId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Trip) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Trip) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Trip) GetCityId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CityId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Trip) GetStartDate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StartDate
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Trip) GetEndDate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EndDate
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Trip) GetPrivate() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Private
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Trip) GetPhotos() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Photos
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Trip) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_proto_trips_proto protoreflect.FileDescriptor

var file_proto_trips_proto_rawDesc = []byte{
        0x0a, 0x11, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x12, 0x05, 0x74, 0x72, 0x69, 0x70, 0x73, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65,
        0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x34, 0x0a, 0x11, 0x43,
        0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x1f, 0x0a, 0x04, 0x74, 0x72, 0x69, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b,
        0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x54, 0x72, 0x69, 0x70, 0x52, 0x04, 0x74, 0x72, 0x69,
        0x70, 0x22, 0x34, 0x0a, 0x11, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x72, 0x69, 0x70, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1f, 0x0a, 0x04, 0x74, 0x72, 0x69, 0x70, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x54, 0x72, 0x69,
        0x70, 0x52, 0x04, 0x74, 0x72, 0x69, 0x70, 0x22, 0x23, 0x0a, 0x11, 0x44, 0x65, 0x6c, 0x65, 0x74,
        0x65, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02,
        0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x22, 0x60, 0x0a, 0x17,
        0x47, 0x65, 0x74, 0x54, 0x72, 0x69, 0x70, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f,
        0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64,
        0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22, 0x3d,
        0x0a, 0x18, 0x47, 0x65, 0x74, 0x54, 0x72, 0x69, 0x70, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72,
        0x49, 0x44, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x21, 0x0a, 0x05, 0x74, 0x72,
        0x69, 0x70, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x74, 0x72, 0x69, 0x70,
        0x73, 0x2e, 0x54, 0x72, 0x69, 0x70, 0x52, 0x05, 0x74, 0x72, 0x69, 0x70, 0x73, 0x22, 0x29, 0x0a,
        0x0e, 0x47, 0x65, 0x74, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x17, 0x0a, 0x07, 0x74, 0x72, 0x69, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
        0x52, 0x06, 0x74, 0x72, 0x69, 0x70, 0x49, 0x64, 0x22, 0x32, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x54,
        0x72, 0x69, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1f, 0x0a, 0x04, 0x74,
        0x72, 0x69, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x74, 0x72, 0x69, 0x70,
        0x73, 0x2e, 0x54, 0x72, 0x69, 0x70, 0x52, 0x04, 0x74, 0x72, 0x69, 0x70, 0x22, 0x4b, 0x0a, 0x15,
        0x41, 0x64, 0x64, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x54, 0x6f, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x74, 0x72, 0x69, 0x70, 0x5f, 0x69, 0x64,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x74, 0x72, 0x69, 0x70, 0x49, 0x64, 0x12, 0x19,
        0x0a, 0x08, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
        0x52, 0x07, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x49, 0x64, 0x22, 0x49, 0x0a, 0x16, 0x41, 0x64, 0x64,
        0x50, 0x68, 0x6f, 0x74, 0x6f, 0x73, 0x54, 0x6f, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x74, 0x72, 0x69, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x74, 0x72, 0x69, 0x70, 0x49, 0x64, 0x12, 0x16, 0x0a, 0x06,
        0x70, 0x68, 0x6f, 0x74, 0x6f, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x06, 0x70, 0x68,
        0x6f, 0x74, 0x6f, 0x73, 0x22, 0x3f, 0x0a, 0x17, 0x41, 0x64, 0x64, 0x50, 0x68, 0x6f, 0x74, 0x6f,
        0x73, 0x54, 0x6f, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x24, 0x0a, 0x06, 0x70, 0x68, 0x6f, 0x74, 0x6f, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x0c, 0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x74, 0x6f, 0x52, 0x06, 0x70,
        0x68, 0x6f, 0x74, 0x6f, 0x73, 0x22, 0x25, 0x0a, 0x05, 0x50, 0x68, 0x6f, 0x74, 0x6f, 0x12, 0x1c,
        0x0a, 0x09, 0x70, 0x68, 0x6f, 0x74, 0x6f, 0x50, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x09, 0x70, 0x68, 0x6f, 0x74, 0x6f, 0x50, 0x61, 0x74, 0x68, 0x22, 0x4c, 0x0a, 0x12,
        0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x50, 0x68, 0x6f, 0x74, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x74, 0x72, 0x69, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x0d, 0x52, 0x06, 0x74, 0x72, 0x69, 0x70, 0x49, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x70,
        0x68, 0x6f, 0x74, 0x6f, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x09, 0x70, 0x68, 0x6f, 0x74, 0x6f, 0x50, 0x61, 0x74, 0x68, 0x22, 0x0f, 0x0a, 0x0d, 0x45, 0x6d,
        0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0xa5, 0x02, 0x0a, 0x04,
        0x54, 0x72, 0x69, 0x70, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
        0x52, 0x02, 0x69, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x12, 0x0a,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x12, 0x17, 0x0a, 0x07, 0x63, 0x69, 0x74, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x63, 0x69, 0x74, 0x79, 0x49, 0x64, 0x12, 0x1d, 0x0a, 0x0a,
        0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x64, 0x61, 0x74, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74, 0x44, 0x61, 0x74, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x65,
        0x6e, 0x64, 0x5f, 0x64, 0x61, 0x74, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x65,
        0x6e, 0x64, 0x44, 0x61, 0x74, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74,
        0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65,
        0x12, 0x16, 0x0a, 0x06, 0x70, 0x68, 0x6f, 0x74, 0x6f, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x09,
        0x52, 0x06, 0x70, 0x68, 0x6f, 0x74, 0x6f, 0x73, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54,
        0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x64, 0x41, 0x74, 0x32, 0xb0, 0x04, 0x0a, 0x05, 0x54, 0x72, 0x69, 0x70, 0x73, 0x12, 0x3c, 0x0a,
        0x0a, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x72, 0x69, 0x70, 0x12, 0x18, 0x2e, 0x74, 0x72,
        0x69, 0x70, 0x73, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x14, 0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x45, 0x6d,
        0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3c, 0x0a, 0x0a, 0x55,
        0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x72, 0x69, 0x70, 0x12, 0x18, 0x2e, 0x74, 0x72, 0x69, 0x70,
        0x73, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x14, 0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x45, 0x6d, 0x70, 0x74,
        0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3c, 0x0a, 0x0a, 0x44, 0x65, 0x6c,
        0x65, 0x74, 0x65, 0x54, 0x72, 0x69, 0x70, 0x12, 0x18, 0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e,
        0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x14, 0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x53, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x54, 0x72,
        0x69, 0x70, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x12, 0x1e, 0x2e, 0x74, 0x72,
        0x69, 0x70, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x54, 0x72, 0x69, 0x70, 0x73, 0x42, 0x79, 0x55, 0x73,
        0x65, 0x72, 0x49, 0x44, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x74, 0x72,
        0x69, 0x70, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x54, 0x72, 0x69, 0x70, 0x73, 0x42, 0x79, 0x55, 0x73,
        0x65, 0x72, 0x49, 0x44, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x38, 0x0a, 0x07,
        0x47, 0x65, 0x74, 0x54, 0x72, 0x69, 0x70, 0x12, 0x15, 0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e,
        0x47, 0x65, 0x74, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16,
        0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x47, 0x65, 0x74, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x44, 0x0a, 0x0e, 0x41, 0x64, 0x64, 0x50, 0x6c, 0x61,
        0x63, 0x65, 0x54, 0x6f, 0x54, 0x72, 0x69, 0x70, 0x12, 0x1c, 0x2e, 0x74, 0x72, 0x69, 0x70, 0x73,
        0x2e, 0x41, 0x64, 0x64, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x54, 0x6f, 0x54, 0x72, 0x69, 0x70, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x14, 0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x45,
        0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x50, 0x0a, 0x0f,
        0x41, 0x64, 0x64, 0x50, 0x68, 0x6f, 0x74, 0x6f, 0x73, 0x54, 0x6f, 0x54, 0x72, 0x69, 0x70, 0x12,
        0x1d, 0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x50, 0x68, 0x6f, 0x74, 0x6f,
        0x73, 0x54, 0x6f, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e,
        0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x50, 0x68, 0x6f, 0x74, 0x6f, 0x73,
        0x54, 0x6f, 0x54, 0x72, 0x69, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x46,
        0x0a, 0x13, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x50, 0x68, 0x6f, 0x74, 0x6f, 0x46, 0x72, 0x6f,
        0x6d, 0x54, 0x72, 0x69, 0x70, 0x12, 0x19, 0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x44, 0x65,
        0x6c, 0x65, 0x74, 0x65, 0x50, 0x68, 0x6f, 0x74, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x14, 0x2e, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x2d, 0x5a, 0x2b, 0x2e, 0x2f, 0x69, 0x6e, 0x74, 0x65,
        0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x74, 0x72, 0x69, 0x70, 0x73, 0x2f, 0x64,
        0x65, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x79, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2f, 0x67, 0x65, 0x6e,
        0x2f, 0x3b, 0x67, 0x65, 0x6e, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_proto_trips_proto_rawDescOnce sync.Once
        file_proto_trips_proto_rawDescData = file_proto_trips_proto_rawDesc
)

func file_proto_trips_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_trips_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_trips_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_trips_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_proto_trips_proto_rawDescData</span>
}

var file_proto_trips_proto_msgTypes = make([]protoimpl.MessageInfo, 14)
var file_proto_trips_proto_goTypes = []any{
        (*CreateTripRequest)(nil),        // 0: trips.CreateTripRequest
        (*UpdateTripRequest)(nil),        // 1: trips.UpdateTripRequest
        (*DeleteTripRequest)(nil),        // 2: trips.DeleteTripRequest
        (*GetTripsByUserIDRequest)(nil),  // 3: trips.GetTripsByUserIDRequest
        (*GetTripsByUserIDResponse)(nil), // 4: trips.GetTripsByUserIDResponse
        (*GetTripRequest)(nil),           // 5: trips.GetTripRequest
        (*GetTripResponse)(nil),          // 6: trips.GetTripResponse
        (*AddPlaceToTripRequest)(nil),    // 7: trips.AddPlaceToTripRequest
        (*AddPhotosToTripRequest)(nil),   // 8: trips.AddPhotosToTripRequest
        (*AddPhotosToTripResponse)(nil),  // 9: trips.AddPhotosToTripResponse
        (*Photo)(nil),                    // 10: trips.Photo
        (*DeletePhotoRequest)(nil),       // 11: trips.DeletePhotoRequest
        (*EmptyResponse)(nil),            // 12: trips.EmptyResponse
        (*Trip)(nil),                     // 13: trips.Trip
        (*timestamppb.Timestamp)(nil),    // 14: google.protobuf.Timestamp
}
var file_proto_trips_proto_depIdxs = []int32{
        13, // 0: trips.CreateTripRequest.trip:type_name -&gt; trips.Trip
        13, // 1: trips.UpdateTripRequest.trip:type_name -&gt; trips.Trip
        13, // 2: trips.GetTripsByUserIDResponse.trips:type_name -&gt; trips.Trip
        13, // 3: trips.GetTripResponse.trip:type_name -&gt; trips.Trip
        10, // 4: trips.AddPhotosToTripResponse.photos:type_name -&gt; trips.Photo
        14, // 5: trips.Trip.created_at:type_name -&gt; google.protobuf.Timestamp
        0,  // 6: trips.Trips.CreateTrip:input_type -&gt; trips.CreateTripRequest
        1,  // 7: trips.Trips.UpdateTrip:input_type -&gt; trips.UpdateTripRequest
        2,  // 8: trips.Trips.DeleteTrip:input_type -&gt; trips.DeleteTripRequest
        3,  // 9: trips.Trips.GetTripsByUserID:input_type -&gt; trips.GetTripsByUserIDRequest
        5,  // 10: trips.Trips.GetTrip:input_type -&gt; trips.GetTripRequest
        7,  // 11: trips.Trips.AddPlaceToTrip:input_type -&gt; trips.AddPlaceToTripRequest
        8,  // 12: trips.Trips.AddPhotosToTrip:input_type -&gt; trips.AddPhotosToTripRequest
        11, // 13: trips.Trips.DeletePhotoFromTrip:input_type -&gt; trips.DeletePhotoRequest
        12, // 14: trips.Trips.CreateTrip:output_type -&gt; trips.EmptyResponse
        12, // 15: trips.Trips.UpdateTrip:output_type -&gt; trips.EmptyResponse
        12, // 16: trips.Trips.DeleteTrip:output_type -&gt; trips.EmptyResponse
        4,  // 17: trips.Trips.GetTripsByUserID:output_type -&gt; trips.GetTripsByUserIDResponse
        6,  // 18: trips.Trips.GetTrip:output_type -&gt; trips.GetTripResponse
        12, // 19: trips.Trips.AddPlaceToTrip:output_type -&gt; trips.EmptyResponse
        9,  // 20: trips.Trips.AddPhotosToTrip:output_type -&gt; trips.AddPhotosToTripResponse
        12, // 21: trips.Trips.DeletePhotoFromTrip:output_type -&gt; trips.EmptyResponse
        14, // [14:22] is the sub-list for method output_type
        6,  // [6:14] is the sub-list for method input_type
        6,  // [6:6] is the sub-list for extension type_name
        6,  // [6:6] is the sub-list for extension extendee
        0,  // [0:6] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_proto_trips_proto_init() }</span>
func file_proto_trips_proto_init() <span class="cov8" title="1">{
        if File_proto_trips_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_proto_trips_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   14,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_trips_proto_goTypes,
                DependencyIndexes: file_proto_trips_proto_depIdxs,
                MessageInfos:      file_proto_trips_proto_msgTypes,
        }.Build()
        File_proto_trips_proto = out.File
        file_proto_trips_proto_rawDesc = nil
        file_proto_trips_proto_goTypes = nil
        file_proto_trips_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.1
// source: proto/trips.proto

package gen

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Trips_CreateTrip_FullMethodName          = "/trips.Trips/CreateTrip"
        Trips_UpdateTrip_FullMethodName          = "/trips.Trips/UpdateTrip"
        Trips_DeleteTrip_FullMethodName          = "/trips.Trips/DeleteTrip"
        Trips_GetTripsByUserID_FullMethodName    = "/trips.Trips/GetTripsByUserID"
        Trips_GetTrip_FullMethodName             = "/trips.Trips/GetTrip"
        Trips_AddPlaceToTrip_FullMethodName      = "/trips.Trips/AddPlaceToTrip"
        Trips_AddPhotosToTrip_FullMethodName     = "/trips.Trips/AddPhotosToTrip"
        Trips_DeletePhotoFromTrip_FullMethodName = "/trips.Trips/DeletePhotoFromTrip"
)

// TripsClient is the client API for Trips service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TripsClient interface {
        CreateTrip(ctx context.Context, in *CreateTripRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
        UpdateTrip(ctx context.Context, in *UpdateTripRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
        DeleteTrip(ctx context.Context, in *DeleteTripRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
        GetTripsByUserID(ctx context.Context, in *GetTripsByUserIDRequest, opts ...grpc.CallOption) (*GetTripsByUserIDResponse, error)
        GetTrip(ctx context.Context, in *GetTripRequest, opts ...grpc.CallOption) (*GetTripResponse, error)
        AddPlaceToTrip(ctx context.Context, in *AddPlaceToTripRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
        AddPhotosToTrip(ctx context.Context, in *AddPhotosToTripRequest, opts ...grpc.CallOption) (*AddPhotosToTripResponse, error)
        DeletePhotoFromTrip(ctx context.Context, in *DeletePhotoRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
}

type tripsClient struct {
        cc grpc.ClientConnInterface
}

func NewTripsClient(cc grpc.ClientConnInterface) TripsClient <span class="cov0" title="0">{
        return &amp;tripsClient{cc}
}</span>

func (c *tripsClient) CreateTrip(ctx context.Context, in *CreateTripRequest, opts ...grpc.CallOption) (*EmptyResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EmptyResponse)
        err := c.cc.Invoke(ctx, Trips_CreateTrip_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tripsClient) UpdateTrip(ctx context.Context, in *UpdateTripRequest, opts ...grpc.CallOption) (*EmptyResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EmptyResponse)
        err := c.cc.Invoke(ctx, Trips_UpdateTrip_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tripsClient) DeleteTrip(ctx context.Context, in *DeleteTripRequest, opts ...grpc.CallOption) (*EmptyResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EmptyResponse)
        err := c.cc.Invoke(ctx, Trips_DeleteTrip_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tripsClient) GetTripsByUserID(ctx context.Context, in *GetTripsByUserIDRequest, opts ...grpc.CallOption) (*GetTripsByUserIDResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetTripsByUserIDResponse)
        err := c.cc.Invoke(ctx, Trips_GetTripsByUserID_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tripsClient) GetTrip(ctx context.Context, in *GetTripRequest, opts ...grpc.CallOption) (*GetTripResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetTripResponse)
        err := c.cc.Invoke(ctx, Trips_GetTrip_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tripsClient) AddPlaceToTrip(ctx context.Context, in *AddPlaceToTripRequest, opts ...grpc.CallOption) (*EmptyResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EmptyResponse)
        err := c.cc.Invoke(ctx, Trips_AddPlaceToTrip_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tripsClient) AddPhotosToTrip(ctx context.Context, in *AddPhotosToTripRequest, opts ...grpc.CallOption) (*AddPhotosToTripResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AddPhotosToTripResponse)
        err := c.cc.Invoke(ctx, Trips_AddPhotosToTrip_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tripsClient) DeletePhotoFromTrip(ctx context.Context, in *DeletePhotoRequest, opts ...grpc.CallOption) (*EmptyResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EmptyResponse)
        err := c.cc.Invoke(ctx, Trips_DeletePhotoFromTrip_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// TripsServer is the server API for Trips service.
// All implementations must embed UnimplementedTripsServer
// for forward compatibility.
type TripsServer interface {
        CreateTrip(context.Context, *CreateTripRequest) (*EmptyResponse, error)
        UpdateTrip(context.Context, *UpdateTripRequest) (*EmptyResponse, error)
        DeleteTrip(context.Context, *DeleteTripRequest) (*EmptyResponse, error)
        GetTripsByUserID(context.Context, *GetTripsByUserIDRequest) (*GetTripsByUserIDResponse, error)
        GetTrip(context.Context, *GetTripRequest) (*GetTripResponse, error)
        AddPlaceToTrip(context.Context, *AddPlaceToTripRequest) (*EmptyResponse, error)
        AddPhotosToTrip(context.Context, *AddPhotosToTripRequest) (*AddPhotosToTripResponse, error)
        DeletePhotoFromTrip(context.Context, *DeletePhotoRequest) (*EmptyResponse, error)
        mustEmbedUnimplementedTripsServer()
}

// UnimplementedTripsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTripsServer struct{}

func (UnimplementedTripsServer) CreateTrip(context.Context, *CreateTripRequest) (*EmptyResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateTrip not implemented")
}</span>
func (UnimplementedTripsServer) UpdateTrip(context.Context, *UpdateTripRequest) (*EmptyResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateTrip not implemented")
}</span>
func (UnimplementedTripsServer) DeleteTrip(context.Context, *DeleteTripRequest) (*EmptyResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteTrip not implemented")
}</span>
func (UnimplementedTripsServer) GetTripsByUserID(context.Context, *GetTripsByUserIDRequest) (*GetTripsByUserIDResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTripsByUserID not implemented")
}</span>
func (UnimplementedTripsServer) GetTrip(context.Context, *GetTripRequest) (*GetTripResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTrip not implemented")
}</span>
func (UnimplementedTripsServer) AddPlaceToTrip(context.Context, *AddPlaceToTripRequest) (*EmptyResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddPlaceToTrip not implemented")
}</span>
func (UnimplementedTripsServer) AddPhotosToTrip(context.Context, *AddPhotosToTripRequest) (*AddPhotosToTripResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddPhotosToTrip not implemented")
}</span>
func (UnimplementedTripsServer) DeletePhotoFromTrip(context.Context, *DeletePhotoRequest) (*EmptyResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeletePhotoFromTrip not implemented")
}</span>
func (UnimplementedTripsServer) mustEmbedUnimplementedTripsServer() {<span class="cov0" title="0">}</span>
func (UnimplementedTripsServer) testEmbeddedByValue()               {<span class="cov0" title="0">}</span>

// UnsafeTripsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TripsServer will
// result in compilation errors.
type UnsafeTripsServer interface {
        mustEmbedUnimplementedTripsServer()
}

func RegisterTripsServer(s grpc.ServiceRegistrar, srv TripsServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedTripsServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Trips_ServiceDesc, srv)</span>
}

func _Trips_CreateTrip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateTripRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripsServer).CreateTrip(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Trips_CreateTrip_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripsServer).CreateTrip(ctx, req.(*CreateTripRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Trips_UpdateTrip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateTripRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripsServer).UpdateTrip(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Trips_UpdateTrip_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripsServer).UpdateTrip(ctx, req.(*UpdateTripRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Trips_DeleteTrip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteTripRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripsServer).DeleteTrip(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Trips_DeleteTrip_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripsServer).DeleteTrip(ctx, req.(*DeleteTripRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Trips_GetTripsByUserID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTripsByUserIDRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripsServer).GetTripsByUserID(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Trips_GetTripsByUserID_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripsServer).GetTripsByUserID(ctx, req.(*GetTripsByUserIDRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Trips_GetTrip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTripRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripsServer).GetTrip(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Trips_GetTrip_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripsServer).GetTrip(ctx, req.(*GetTripRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Trips_AddPlaceToTrip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddPlaceToTripRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripsServer).AddPlaceToTrip(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Trips_AddPlaceToTrip_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripsServer).AddPlaceToTrip(ctx, req.(*AddPlaceToTripRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Trips_AddPhotosToTrip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddPhotosToTripRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripsServer).AddPhotosToTrip(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Trips_AddPhotosToTrip_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripsServer).AddPhotosToTrip(ctx, req.(*AddPhotosToTripRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Trips_DeletePhotoFromTrip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeletePhotoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripsServer).DeletePhotoFromTrip(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Trips_DeletePhotoFromTrip_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripsServer).DeletePhotoFromTrip(ctx, req.(*DeletePhotoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Trips_ServiceDesc is the grpc.ServiceDesc for Trips service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Trips_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "trips.Trips",
        HandlerType: (*TripsServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateTrip",
                        Handler:    _Trips_CreateTrip_Handler,
                },
                {
                        MethodName: "UpdateTrip",
                        Handler:    _Trips_UpdateTrip_Handler,
                },
                {
                        MethodName: "DeleteTrip",
                        Handler:    _Trips_DeleteTrip_Handler,
                },
                {
                        MethodName: "GetTripsByUserID",
                        Handler:    _Trips_GetTripsByUserID_Handler,
                },
                {
                        MethodName: "GetTrip",
                        Handler:    _Trips_GetTrip_Handler,
                },
                {
                        MethodName: "AddPlaceToTrip",
                        Handler:    _Trips_AddPlaceToTrip_Handler,
                },
                {
                        MethodName: "AddPhotosToTrip",
                        Handler:    _Trips_AddPhotosToTrip_Handler,
                },
                {
                        MethodName: "DeletePhotoFromTrip",
                        Handler:    _Trips_DeletePhotoFromTrip_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/trips.proto",
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package grpc

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/trips"
        tripsGen "2024_2_ThereWillBeName/internal/pkg/trips/delivery/grpc/gen"
        "context"
        "encoding/base64"
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strings"
        "time"
)

type GrpcTripsHandler struct {
        tripsGen.TripsServer
        uc     trips.TripsUsecase
        logger *slog.Logger
}

func NewGrpcTripHandler(uc trips.TripsUsecase, logger *slog.Logger) *GrpcTripsHandler <span class="cov8" title="1">{
        return &amp;GrpcTripsHandler{uc: uc, logger: logger}
}</span>

func (h *GrpcTripsHandler) CreateTrip(ctx context.Context, in *tripsGen.CreateTripRequest) (*tripsGen.EmptyResponse, error) <span class="cov8" title="1">{

        trip := models.Trip{
                UserID:      uint(in.Trip.UserId),
                Name:        in.Trip.Name,
                Description: in.Trip.Description,
                CityID:      uint(in.Trip.CityId),
                StartDate:   in.Trip.StartDate,
                EndDate:     in.Trip.EndDate,
                Private:     in.Trip.Private,
        }

        err := h.uc.CreateTrip(context.Background(), trip)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;tripsGen.EmptyResponse{}, nil</span>
}

func (h *GrpcTripsHandler) UpdateTrip(ctx context.Context, in *tripsGen.UpdateTripRequest) (*tripsGen.EmptyResponse, error) <span class="cov8" title="1">{

        trip := models.Trip{
                UserID:      uint(in.Trip.UserId),
                Name:        in.Trip.Name,
                Description: in.Trip.Description,
                CityID:      uint(in.Trip.CityId),
                StartDate:   in.Trip.StartDate,
                EndDate:     in.Trip.EndDate,
                Private:     in.Trip.Private,
        }

        err := h.uc.UpdateTrip(context.Background(), trip)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;tripsGen.EmptyResponse{}, nil</span>
}

func (h *GrpcTripsHandler) DeleteTrip(ctx context.Context, in *tripsGen.DeleteTripRequest) (*tripsGen.EmptyResponse, error) <span class="cov8" title="1">{
        err := h.uc.DeleteTrip(context.Background(), uint(in.Id))

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;tripsGen.EmptyResponse{}, nil</span>
}

func (h *GrpcTripsHandler) GetTripsByUserID(ctx context.Context, in *tripsGen.GetTripsByUserIDRequest) (*tripsGen.GetTripsByUserIDResponse, error) <span class="cov8" title="1">{
        trips, err := h.uc.GetTripsByUserID(context.Background(), uint(in.UserId), int(in.Limit), int(in.Offset))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">grpcTrips := make([]*tripsGen.Trip, 0, len(trips))
        for _, trip := range trips </span><span class="cov8" title="1">{
                grpcTrips = append(grpcTrips, &amp;tripsGen.Trip{
                        Id:          uint32(trip.ID),
                        UserId:      uint32(trip.UserID),
                        Name:        trip.Name,
                        Description: trip.Description,
                        CityId:      uint32(trip.CityID),
                        StartDate:   trip.StartDate,
                        EndDate:     trip.EndDate,
                        Photos:      trip.Photos,
                        Private:     trip.Private,
                })
        }</span>
        <span class="cov8" title="1">return &amp;tripsGen.GetTripsByUserIDResponse{Trips: grpcTrips}, nil</span>
}

func (h *GrpcTripsHandler) GetTrip(ctx context.Context, in *tripsGen.GetTripRequest) (*tripsGen.GetTripResponse, error) <span class="cov8" title="1">{
        trip, err := h.uc.GetTrip(context.Background(), uint(in.TripId))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;tripsGen.GetTripResponse{
                Trip: &amp;tripsGen.Trip{
                        Id:          uint32(trip.ID),
                        UserId:      uint32(trip.UserID),
                        Name:        trip.Name,
                        Description: trip.Description,
                        CityId:      uint32(trip.CityID),
                        StartDate:   trip.StartDate,
                        EndDate:     trip.EndDate,
                        Private:     trip.Private,
                        Photos:      trip.Photos,
                },
        }, nil</span>
}

func (h *GrpcTripsHandler) AddPlaceToTrip(ctx context.Context, in *tripsGen.AddPlaceToTripRequest) (*tripsGen.EmptyResponse, error) <span class="cov8" title="1">{
        tripID := uint(in.TripId)
        placeID := uint(in.PlaceId)
        err := h.uc.AddPlaceToTrip(ctx, tripID, placeID)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("Failed to add place to trip", slog.Any("error", err))
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;tripsGen.EmptyResponse{}, nil</span>
}

func (h *GrpcTripsHandler) AddPhotosToTrip(ctx context.Context, in *tripsGen.AddPhotosToTripRequest) (*tripsGen.AddPhotosToTripResponse, error) <span class="cov8" title="1">{
        var savedPhotoPaths []string
        for _, base64Photo := range in.Photos </span><span class="cov8" title="1">{
                if strings.HasPrefix(base64Photo, "data:image/") </span><span class="cov8" title="1">{
                        index := strings.Index(base64Photo, ",")
                        if index != -1 </span><span class="cov8" title="1">{
                                base64Photo = base64Photo[index+1:]
                        }</span> else<span class="cov0" title="0"> {
                                h.logger.Error("Invalid base64 photo format: missing ',' separator")
                                return nil, fmt.Errorf("invalid base64 photo format: missing ',' separator")
                        }</span>
                }

                <span class="cov8" title="1">photoBytes, err := base64.StdEncoding.DecodeString(base64Photo)
                if err != nil </span><span class="cov8" title="1">{
                        h.logger.Error("Failed to decode base64 photo", slog.Any("error", err))
                        return nil, fmt.Errorf("invalid base64 data: %w", err)
                }</span>

                <span class="cov8" title="1">photoName := fmt.Sprintf("trip_%d_%d.jpg", in.TripId, time.Now().UnixNano())
                photoPath := filepath.Join(os.Getenv("PHOTO_STORAGE_PATH"), photoName)
                if _, err := os.Stat(os.Getenv("PHOTO_STORAGE_PATH")); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        err := os.MkdirAll(os.Getenv("PHOTO_STORAGE_PATH"), 0755)
                        if err != nil </span><span class="cov0" title="0">{
                                h.logger.Error("Failed to create photo storage directory", slog.Any("error", err))
                                return nil, fmt.Errorf("failed to create photo storage directory: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">err = os.WriteFile(photoPath, photoBytes, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to save photo to disk", slog.String("path", photoPath), slog.Any("error", err))
                        return nil, fmt.Errorf("failed to save photo: %w", err)
                }</span>

                <span class="cov8" title="1">savedPhotoPaths = append(savedPhotoPaths, photoPath)</span>
        }

        <span class="cov8" title="1">err := h.uc.AddPhotosToTrip(ctx, uint(in.TripId), savedPhotoPaths)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to save photo paths in database", slog.Any("error", err))
                return nil, fmt.Errorf("failed to save photo paths: %w", err)
        }</span>

        <span class="cov8" title="1">var grpcPhotos []*tripsGen.Photo
        for _, path := range savedPhotoPaths </span><span class="cov8" title="1">{
                grpcPhotos = append(grpcPhotos, &amp;tripsGen.Photo{PhotoPath: path})
        }</span>

        <span class="cov8" title="1">return &amp;tripsGen.AddPhotosToTripResponse{Photos: grpcPhotos}, nil</span>
}

func (h *GrpcTripsHandler) DeletePhotoFromTrip(ctx context.Context, in *tripsGen.DeletePhotoRequest) (*tripsGen.EmptyResponse, error) <span class="cov0" title="0">{
        photoPath := in.PhotoPath
        err := h.uc.DeletePhotoFromTrip(ctx, uint(in.TripId), photoPath)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to delete photo path from database", slog.Any("error", err))
                return nil, fmt.Errorf("failed to delete photo path: %w", err)
        }</span>

        <span class="cov0" title="0">err = os.Remove(photoPath)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                h.logger.Error("Failed to delete photo file", slog.String("path", photoPath), slog.Any("error", err))
                return nil, fmt.Errorf("failed to delete photo file: %w", err)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Photo successfully deleted", slog.String("path", photoPath))
        return &amp;tripsGen.EmptyResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package http

import (
        "2024_2_ThereWillBeName/internal/models"
        httpresponse "2024_2_ThereWillBeName/internal/pkg/httpresponses"
        log "2024_2_ThereWillBeName/internal/pkg/logger"
        "2024_2_ThereWillBeName/internal/pkg/middleware"
        tripsGen "2024_2_ThereWillBeName/internal/pkg/trips/delivery/grpc/gen"
        "2024_2_ThereWillBeName/internal/validator"

        "context"
        "encoding/json"
        "errors"
        "fmt"
        "html/template"
        "log/slog"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
)

type AddPlaceRequest struct {
        PlaceID uint `json:"place_id"`
}

type TripData struct {
        UserID      uint   `json:"user_id"`
        Name        string `json:"name"`
        CityID      uint   `json:"city_id"`
        Description string `json:"description"`
        StartDate   string `json:"start_date"`
        EndDate     string `json:"end_date"`
        Private     bool   `json:"private_trip"`
}

type TripHandler struct {
        client tripsGen.TripsClient
        logger *slog.Logger
}

func NewTripHandler(client tripsGen.TripsClient, logger *slog.Logger) *TripHandler <span class="cov8" title="1">{
        return &amp;TripHandler{client, logger}
}</span>

func ErrorCheck(err error, action string, logger *slog.Logger, ctx context.Context) (httpresponse.ErrorResponse, int) <span class="cov8" title="1">{
        if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{

                logContext := log.AppendCtx(ctx, slog.String("action", action))
                logger.ErrorContext(logContext, fmt.Sprintf("Error during %s operation", action), slog.Any("error", err.Error()))

                response := httpresponse.ErrorResponse{
                        Message: "Invalid request",
                }
                return response, http.StatusNotFound
        }</span>
        <span class="cov8" title="1">logContext := log.AppendCtx(ctx, slog.String("action", action))
        logger.ErrorContext(logContext, fmt.Sprintf("Failed to %s trips", action), slog.Any("error", err.Error()))
        response := httpresponse.ErrorResponse{
                Message: fmt.Sprintf("Failed to %s trip", action),
        }
        return response, http.StatusInternalServerError</span>
}

// CreateTripHandler godoc
// @Summary Create a new trip
// @Description Create a new trip with given fields
// @Accept json
// @Produce json
// @Param tripData body TripData true "Trip details"
// @Success 201 {object} models.Trip "Trip created successfully"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid request"
// @Failure 403 {object} httpresponses.ErrorResponse "Token is missing"
// @Failure 403 {object} httpresponses.ErrorResponse "Invalid token"
// @Failure 404 {object} httpresponses.ErrorResponse "Invalid request"
// @Failure 422 {object} httpresponses.ErrorResponse
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to create trip"
// @Router /trips [post]
func (h *TripHandler) CreateTripHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'; style-src 'self';")
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for creating a trip")

        _, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{

                h.logger.Warn("Failed to retrieve user ID from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov8" title="1">var tripData TripData
        err := json.NewDecoder(r.Body).Decode(&amp;tripData)

        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("Failed to decode trip data",
                        slog.String("error", err.Error()),
                        slog.String("trip_data", fmt.Sprintf("%+v", tripData)))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid request",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>
        <span class="cov8" title="1">trip := models.Trip{
                UserID:      tripData.UserID,
                Name:        tripData.Name,
                Description: tripData.Description,
                CityID:      tripData.CityID,
                StartDate:   tripData.StartDate,
                EndDate:     tripData.EndDate,
                Private:     tripData.Private,
        }

        v := validator.New()
        if models.ValidateTrip(v, &amp;trip); !v.Valid() </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusUnprocessableEntity, h.logger)
                return
        }</span>

        <span class="cov8" title="1">trip.Name = template.HTMLEscapeString(trip.Name)
        trip.Description = template.HTMLEscapeString(trip.Description)

        // err = h.uc.CreateTrip(context.Background(), trip)
        _, err = h.client.CreateTrip(r.Context(), &amp;tripsGen.CreateTripRequest{Trip: &amp;tripsGen.Trip{
                Id:          uint32(trip.ID),
                UserId:      uint32(trip.UserID),
                Name:        trip.Name,
                Description: trip.Description,
                CityId:      uint32(trip.CityID),
                StartDate:   trip.StartDate,
                EndDate:     trip.EndDate,
                Private:     trip.Private,
        }})
        if err != nil </span><span class="cov8" title="1">{
                response, status := ErrorCheck(err, "create", h.logger, context.Background())
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov8" title="1">h.logger.DebugContext(logCtx, "Successfully created a trip")

        httpresponse.SendJSONResponse(w, "Trip created successfully", http.StatusCreated, h.logger)</span>
}

// UpdateTripHandler godoc
// @Summary Update an existing trip
// @Description Update trip details by trip ID
// @Accept json
// @Produce json
// @Param id path int true "Trip ID"
// @Param tripData body TripData true "Updated trip details"
// @Success 200 {object} models.Trip "Trip updated successfully"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid trip ID"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid trip data"
// @Failure 403 {object} httpresponses.ErrorResponse "Token is missing"
// @Failure 403 {object} httpresponses.ErrorResponse "Invalid token"
// @Failure 404 {object} httpresponses.ErrorResponse "Trip not found"
// @Failure 422 {object} httpresponses.ErrorResponse
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to update trip"
// @Router /trips/{id} [put]
func (h *TripHandler) UpdateTripHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'; style-src 'self';")
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for updating a trip")

        _, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{

                h.logger.Warn("Failed to retrieve user ID from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov8" title="1">var tripData TripData

        vars := mux.Vars(r)
        tripID, err := strconv.Atoi(vars["id"])
        if err != nil || tripID &lt; 0 </span><span class="cov8" title="1">{
                h.logger.Warn("Failed to parse trip ID", slog.Int("tripID", tripID), slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid trip ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>
        <span class="cov8" title="1">err = json.NewDecoder(r.Body).Decode(&amp;tripData)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("Failed to decode trip data", slog.String("trip_data", fmt.Sprintf("%+v", tripData)), slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid trip data",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>
        <span class="cov8" title="1">trip := models.Trip{
                ID:          uint(tripID),
                UserID:      tripData.UserID,
                Name:        tripData.Name,
                Description: tripData.Description,
                CityID:      tripData.CityID,
                StartDate:   tripData.StartDate,
                EndDate:     tripData.EndDate,
                Private:     tripData.Private,
        }

        v := validator.New()
        if models.ValidateTrip(v, &amp;trip); !v.Valid() </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusUnprocessableEntity, h.logger)
                return
        }</span>

        <span class="cov8" title="1">trip.Name = template.HTMLEscapeString(trip.Name)
        trip.Description = template.HTMLEscapeString(trip.Description)

        // err = h.uc.UpdateTrip(context.Background(), trip)
        _, err = h.client.UpdateTrip(r.Context(), &amp;tripsGen.UpdateTripRequest{Trip: &amp;tripsGen.Trip{
                Id:          uint32(trip.ID),
                UserId:      uint32(trip.UserID),
                Name:        trip.Name,
                Description: trip.Description,
                CityId:      uint32(trip.CityID),
                StartDate:   trip.StartDate,
                EndDate:     trip.EndDate,
                Private:     trip.Private,
        }})
        if err != nil </span><span class="cov0" title="0">{
                logCtx := log.AppendCtx(context.Background(), slog.Int("tripID", tripID))
                response, status := ErrorCheck(err, "update", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>
        <span class="cov8" title="1">h.logger.DebugContext(logCtx, "Successfully updated a trip")

        httpresponse.SendJSONResponse(w, "Trip updated successfully", http.StatusOK, h.logger)</span>
}

// DeleteTripHandler godoc
// @Summary Delete a trip
// @Description Delete a trip by trip ID
// @Produce json
// @Param id path int true "Trip ID"
// @Success 204 "Trip deleted successfully"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid trip ID"
// @Failure 403 {object} httpresponses.ErrorResponse "Token is missing"
// @Failure 403 {object} httpresponses.ErrorResponse "Invalid token"
// @Failure 404 {object} httpresponses.ErrorResponse "Trip not found"
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to delete trip"
// @Router /trips/{id} [delete]
func (h *TripHandler) DeleteTripHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        idStr := vars["id"]

        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for deleting a trip", slog.String("tripID", idStr))

        _, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov8" title="1">{

                h.logger.Warn("Failed to retrieve user ID from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov8" title="1">id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("Failed to parse trip ID", slog.String("tripID", idStr), slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid trip ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        // err = h.uc.DeleteTrip(context.Background(), uint(id))
        <span class="cov8" title="1">_, err = h.client.DeleteTrip(r.Context(), &amp;tripsGen.DeleteTripRequest{Id: uint32(id)})
        if err != nil </span><span class="cov8" title="1">{
                logCtx := log.AppendCtx(context.Background(), slog.String("tripID", idStr))
                response, status := ErrorCheck(err, "delete", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>
        <span class="cov8" title="1">h.logger.DebugContext(logCtx, "Successfully deleted a trip")

        httpresponse.SendJSONResponse(w, "Trip deleted successfully", http.StatusNoContent, h.logger)</span>
}

// GetTripsByUserIDHandler godoc
// @Summary Retrieve trips by user ID
// @Description Get all trips for a specific user
// @Produce json
// @Param userID path int true "User ID"
// @Success 200 {array} models.Trip "List of trips"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid user ID"
// @Failure 403 {object} httpresponses.ErrorResponse "Token is missing"
// @Failure 403 {object} httpresponses.ErrorResponse "Invalid token"
// @Failure 404 {object} httpresponses.ErrorResponse "Invalid user ID"
// @Failure 404 {object} httpresponses.ErrorResponse "Trips not found"
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to retrieve trips"
// @Router /users/{userID}/trips [get]
func (h *TripHandler) GetTripsByUserIDHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{

        userID, ok := r.Context().Value(middleware.IdKey).(uint)

        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for getting trips by user ID", slog.Int("placeID", int(userID)))

        if !ok </span><span class="cov8" title="1">{

                h.logger.Warn("Failed to retrieve user ID from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov8" title="1">var err error
        pageStr := r.URL.Query().Get("page")
        page := 1
        if pageStr != "" </span><span class="cov8" title="1">{
                page, err = strconv.Atoi(pageStr)
                if err != nil </span><span class="cov8" title="1">{
                        response := httpresponse.ErrorResponse{
                                Message: "Invalid page number",
                        }
                        httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                        return
                }</span>
        }
        <span class="cov8" title="1">limit := 10
        offset := limit * (page - 1)
        // trip, err := h.uc.GetTripsByUserID(context.Background(), uint(userID), limit, offset)
        trip, err := h.client.GetTripsByUserID(r.Context(), &amp;tripsGen.GetTripsByUserIDRequest{
                UserId: uint32(userID),
                Limit:  int32(limit),
                Offset: int32(offset),
        })
        if err != nil </span><span class="cov8" title="1">{
                logCtx := log.AppendCtx(context.Background(), slog.Int("userID", int(userID)))
                response, status := ErrorCheck(err, "retrieve", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov8" title="1">h.logger.DebugContext(logCtx, "Successfully got trips by user ID")
        tripArr := trip.Trips

        httpresponse.SendJSONResponse(w, tripArr, http.StatusOK, h.logger)</span>
}

// GetTripHandler godoc
// @Summary Retrieve a trip by ID
// @Description Get trip details by trip ID
// @Produce json
// @Param id path int true "Trip ID"
// @Success 200 {object} models.Trip "Trip details"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid trip ID"
// @Failure 404 {object} httpresponses.ErrorResponse "Trip not found"
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to retrieve trip"
// @Router /trips/{id} [get]
func (h *TripHandler) GetTripHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        tripIDStr := vars["id"]

        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for getting trip by ID", slog.String("tripID", tripIDStr))

        _, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{

                h.logger.Warn("Failed to retrieve user ID from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov8" title="1">tripID, err := strconv.ParseUint(tripIDStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("Failed to parse trip ID", slog.String("tripID", tripIDStr), slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid trip ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        // trip, err := h.uc.GetTrip(context.Background(), uint(tripID))
        <span class="cov8" title="1">trip, err := h.client.GetTrip(r.Context(), &amp;tripsGen.GetTripRequest{TripId: uint32(tripID)})
        if err != nil </span><span class="cov8" title="1">{
                logCtx := log.AppendCtx(context.Background(), slog.String("tripID", tripIDStr))
                response, status := ErrorCheck(err, "retrieve", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov8" title="1">h.logger.DebugContext(logCtx, "Successfully got trip by ID")
        tripResponse := trip.Trip

        httpresponse.SendJSONResponse(w, tripResponse, http.StatusOK, h.logger)</span>
}

// AddPlaceToTripHandler godoc
// @Summary Add a place to a trip
// @Description Add a place with given place_id to a trip
// @Produce json
// @Param id path int true "Trip ID"
// @Param place_id body int true "Place ID"
// @Success 201 "Place added to trip successfully"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid trip ID"
// @Failure 400 {object} httpresponses.ErrorResponse "Invalid place ID"
// @Failure 404 {object} httpresponses.ErrorResponse "Trip not found"
// @Failure 404 {object} httpresponses.ErrorResponse "Place not found"
// @Failure 500 {object} httpresponses.ErrorResponse "Failed to add place to trip"
// @Router /trips/{id} [post]
func (h *TripHandler) AddPlaceToTripHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        tripIDStr, ok := vars["id"]
        if !ok </span><span class="cov0" title="0">{
                response := httpresponse.ErrorResponse{
                        Message: "Invalid trip ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov8" title="1">_, ok = r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov8" title="1">{

                h.logger.Warn("Failed to retrieve user ID from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov8" title="1">tripID, err := strconv.ParseUint(tripIDStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                response := httpresponse.ErrorResponse{
                        Message: "Invalid trip ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>
        <span class="cov8" title="1">var req AddPlaceRequest
        err = json.NewDecoder(r.Body).Decode(&amp;req)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("Failed to parse trip ID", slog.String("tripID", tripIDStr), slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid place ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        // err = h.uc.AddPlaceToTrip(context.Background(), uint(tripID), req.PlaceID)
        <span class="cov8" title="1">_, err = h.client.AddPlaceToTrip(r.Context(), &amp;tripsGen.AddPlaceToTripRequest{
                TripId:  uint32(tripID),
                PlaceId: uint32(req.PlaceID),
        })
        if err != nil </span><span class="cov8" title="1">{
                response, status := ErrorCheck(err, "add place", h.logger, context.Background())
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov8" title="1">httpresponse.SendJSONResponse(w, "Place added to trip successfully", http.StatusCreated, h.logger)</span>
}

func (h *TripHandler) AddPhotosToTripHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        tripIDStr := vars["id"]
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for adding photos to a trip", slog.String("tripID", tripIDStr))

        _, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Warn("Failed to retrieve user ID from context")
                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov8" title="1">tripID, err := strconv.ParseUint(tripIDStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("Failed to parse trip ID", slog.String("tripID", tripIDStr), slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid trip ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov8" title="1">var photosRequest struct {
                Photos []string `json:"photos"`
        }

        err = json.NewDecoder(r.Body).Decode(&amp;photosRequest)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("Failed to decode photos request body", slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid request body",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>
        <span class="cov8" title="1">resp, err := h.client.AddPhotosToTrip(r.Context(), &amp;tripsGen.AddPhotosToTripRequest{
                TripId: uint32(tripID),
                Photos: photosRequest.Photos,
        })
        if err != nil </span><span class="cov8" title="1">{
                logCtx := log.AppendCtx(context.Background(), slog.String("tripID", tripIDStr))
                response, status := ErrorCheck(err, "add photos", h.logger, logCtx)
                httpresponse.SendJSONResponse(w, response, status, h.logger)
                return
        }</span>

        <span class="cov8" title="1">h.logger.DebugContext(logCtx, "Successfully added photos to the trip")

        httpresponse.SendJSONResponse(w, resp.Photos, http.StatusCreated, h.logger)</span>
}

func (h *TripHandler) DeletePhotoHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tripIDStr := mux.Vars(r)["id"]
        var photoPath struct {
                PhotoPath string `json:"photo_path"`
        }
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)

        h.logger.DebugContext(logCtx, "Handling request for deleting photo from a trip", slog.String("tripID", tripIDStr))
        err := json.NewDecoder(r.Body).Decode(&amp;photoPath)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("Failed to decode photos delete request body", slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid request body",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>
        <span class="cov8" title="1">tripID, err := strconv.ParseUint(tripIDStr, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                httpresponse.SendJSONResponse(w, httpresponse.ErrorResponse{Message: "Invalid trip ID"}, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov8" title="1">req := &amp;tripsGen.DeletePhotoRequest{
                TripId:    uint32(tripID),
                PhotoPath: photoPath.PhotoPath,
        }

        _, err = h.client.DeletePhotoFromTrip(r.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                httpresponse.SendJSONResponse(w, httpresponse.ErrorResponse{Message: "Failed to delete photo"}, http.StatusInternalServerError, h.logger)
                return
        }</span>

        <span class="cov8" title="1">httpresponse.SendJSONResponse(w, map[string]string{"message": "Photo deleted successfully"}, http.StatusOK, h.logger)</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/pkg/trips/delivery/grpc/gen/trips_grpc.pb.go

// Package mocks is a generated GoMock package.
package mocks

import (
        gen "2024_2_ThereWillBeName/internal/pkg/trips/delivery/grpc/gen"
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        grpc "google.golang.org/grpc"
)

// MockTripsClient is a mock of TripsClient interface.
type MockTripsClient struct {
        ctrl     *gomock.Controller
        recorder *MockTripsClientMockRecorder
}

// MockTripsClientMockRecorder is the mock recorder for MockTripsClient.
type MockTripsClientMockRecorder struct {
        mock *MockTripsClient
}

// NewMockTripsClient creates a new mock instance.
func NewMockTripsClient(ctrl *gomock.Controller) *MockTripsClient <span class="cov8" title="1">{
        mock := &amp;MockTripsClient{ctrl: ctrl}
        mock.recorder = &amp;MockTripsClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTripsClient) EXPECT() *MockTripsClientMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddPhotosToTrip mocks base method.
func (m *MockTripsClient) AddPhotosToTrip(ctx context.Context, in *gen.AddPhotosToTripRequest, opts ...grpc.CallOption) (*gen.AddPhotosToTripResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "AddPhotosToTrip", varargs...)
        ret0, _ := ret[0].(*gen.AddPhotosToTripResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// AddPhotosToTrip indicates an expected call of AddPhotosToTrip.
func (mr *MockTripsClientMockRecorder) AddPhotosToTrip(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPhotosToTrip", reflect.TypeOf((*MockTripsClient)(nil).AddPhotosToTrip), varargs...)
}</span>

// AddPlaceToTrip mocks base method.
func (m *MockTripsClient) AddPlaceToTrip(ctx context.Context, in *gen.AddPlaceToTripRequest, opts ...grpc.CallOption) (*gen.EmptyResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "AddPlaceToTrip", varargs...)
        ret0, _ := ret[0].(*gen.EmptyResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// AddPlaceToTrip indicates an expected call of AddPlaceToTrip.
func (mr *MockTripsClientMockRecorder) AddPlaceToTrip(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPlaceToTrip", reflect.TypeOf((*MockTripsClient)(nil).AddPlaceToTrip), varargs...)
}</span>

// CreateTrip mocks base method.
func (m *MockTripsClient) CreateTrip(ctx context.Context, in *gen.CreateTripRequest, opts ...grpc.CallOption) (*gen.EmptyResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "CreateTrip", varargs...)
        ret0, _ := ret[0].(*gen.EmptyResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// CreateTrip indicates an expected call of CreateTrip.
func (mr *MockTripsClientMockRecorder) CreateTrip(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTrip", reflect.TypeOf((*MockTripsClient)(nil).CreateTrip), varargs...)
}</span>

// DeletePhotoFromTrip mocks base method.
func (m *MockTripsClient) DeletePhotoFromTrip(ctx context.Context, in *gen.DeletePhotoRequest, opts ...grpc.CallOption) (*gen.EmptyResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DeletePhotoFromTrip", varargs...)
        ret0, _ := ret[0].(*gen.EmptyResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeletePhotoFromTrip indicates an expected call of DeletePhotoFromTrip.
func (mr *MockTripsClientMockRecorder) DeletePhotoFromTrip(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePhotoFromTrip", reflect.TypeOf((*MockTripsClient)(nil).DeletePhotoFromTrip), varargs...)
}</span>

// DeleteTrip mocks base method.
func (m *MockTripsClient) DeleteTrip(ctx context.Context, in *gen.DeleteTripRequest, opts ...grpc.CallOption) (*gen.EmptyResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DeleteTrip", varargs...)
        ret0, _ := ret[0].(*gen.EmptyResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteTrip indicates an expected call of DeleteTrip.
func (mr *MockTripsClientMockRecorder) DeleteTrip(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTrip", reflect.TypeOf((*MockTripsClient)(nil).DeleteTrip), varargs...)
}</span>

// GetTrip mocks base method.
func (m *MockTripsClient) GetTrip(ctx context.Context, in *gen.GetTripRequest, opts ...grpc.CallOption) (*gen.GetTripResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetTrip", varargs...)
        ret0, _ := ret[0].(*gen.GetTripResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTrip indicates an expected call of GetTrip.
func (mr *MockTripsClientMockRecorder) GetTrip(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTrip", reflect.TypeOf((*MockTripsClient)(nil).GetTrip), varargs...)
}</span>

// GetTripsByUserID mocks base method.
func (m *MockTripsClient) GetTripsByUserID(ctx context.Context, in *gen.GetTripsByUserIDRequest, opts ...grpc.CallOption) (*gen.GetTripsByUserIDResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetTripsByUserID", varargs...)
        ret0, _ := ret[0].(*gen.GetTripsByUserIDResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTripsByUserID indicates an expected call of GetTripsByUserID.
func (mr *MockTripsClientMockRecorder) GetTripsByUserID(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTripsByUserID", reflect.TypeOf((*MockTripsClient)(nil).GetTripsByUserID), varargs...)
}</span>

// UpdateTrip mocks base method.
func (m *MockTripsClient) UpdateTrip(ctx context.Context, in *gen.UpdateTripRequest, opts ...grpc.CallOption) (*gen.EmptyResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "UpdateTrip", varargs...)
        ret0, _ := ret[0].(*gen.EmptyResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// UpdateTrip indicates an expected call of UpdateTrip.
func (mr *MockTripsClientMockRecorder) UpdateTrip(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTrip", reflect.TypeOf((*MockTripsClient)(nil).UpdateTrip), varargs...)
}</span>

// MockTripsServer is a mock of TripsServer interface.
type MockTripsServer struct {
        ctrl     *gomock.Controller
        recorder *MockTripsServerMockRecorder
}

// MockTripsServerMockRecorder is the mock recorder for MockTripsServer.
type MockTripsServerMockRecorder struct {
        mock *MockTripsServer
}

// NewMockTripsServer creates a new mock instance.
func NewMockTripsServer(ctrl *gomock.Controller) *MockTripsServer <span class="cov0" title="0">{
        mock := &amp;MockTripsServer{ctrl: ctrl}
        mock.recorder = &amp;MockTripsServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTripsServer) EXPECT() *MockTripsServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddPhotosToTrip mocks base method.
func (m *MockTripsServer) AddPhotosToTrip(arg0 context.Context, arg1 *gen.AddPhotosToTripRequest) (*gen.AddPhotosToTripResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddPhotosToTrip", arg0, arg1)
        ret0, _ := ret[0].(*gen.AddPhotosToTripResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddPhotosToTrip indicates an expected call of AddPhotosToTrip.
func (mr *MockTripsServerMockRecorder) AddPhotosToTrip(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPhotosToTrip", reflect.TypeOf((*MockTripsServer)(nil).AddPhotosToTrip), arg0, arg1)
}</span>

// AddPlaceToTrip mocks base method.
func (m *MockTripsServer) AddPlaceToTrip(arg0 context.Context, arg1 *gen.AddPlaceToTripRequest) (*gen.EmptyResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddPlaceToTrip", arg0, arg1)
        ret0, _ := ret[0].(*gen.EmptyResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddPlaceToTrip indicates an expected call of AddPlaceToTrip.
func (mr *MockTripsServerMockRecorder) AddPlaceToTrip(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPlaceToTrip", reflect.TypeOf((*MockTripsServer)(nil).AddPlaceToTrip), arg0, arg1)
}</span>

// CreateTrip mocks base method.
func (m *MockTripsServer) CreateTrip(arg0 context.Context, arg1 *gen.CreateTripRequest) (*gen.EmptyResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateTrip", arg0, arg1)
        ret0, _ := ret[0].(*gen.EmptyResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateTrip indicates an expected call of CreateTrip.
func (mr *MockTripsServerMockRecorder) CreateTrip(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTrip", reflect.TypeOf((*MockTripsServer)(nil).CreateTrip), arg0, arg1)
}</span>

// DeletePhotoFromTrip mocks base method.
func (m *MockTripsServer) DeletePhotoFromTrip(arg0 context.Context, arg1 *gen.DeletePhotoRequest) (*gen.EmptyResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeletePhotoFromTrip", arg0, arg1)
        ret0, _ := ret[0].(*gen.EmptyResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeletePhotoFromTrip indicates an expected call of DeletePhotoFromTrip.
func (mr *MockTripsServerMockRecorder) DeletePhotoFromTrip(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePhotoFromTrip", reflect.TypeOf((*MockTripsServer)(nil).DeletePhotoFromTrip), arg0, arg1)
}</span>

// DeleteTrip mocks base method.
func (m *MockTripsServer) DeleteTrip(arg0 context.Context, arg1 *gen.DeleteTripRequest) (*gen.EmptyResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteTrip", arg0, arg1)
        ret0, _ := ret[0].(*gen.EmptyResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteTrip indicates an expected call of DeleteTrip.
func (mr *MockTripsServerMockRecorder) DeleteTrip(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTrip", reflect.TypeOf((*MockTripsServer)(nil).DeleteTrip), arg0, arg1)
}</span>

// GetTrip mocks base method.
func (m *MockTripsServer) GetTrip(arg0 context.Context, arg1 *gen.GetTripRequest) (*gen.GetTripResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTrip", arg0, arg1)
        ret0, _ := ret[0].(*gen.GetTripResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTrip indicates an expected call of GetTrip.
func (mr *MockTripsServerMockRecorder) GetTrip(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTrip", reflect.TypeOf((*MockTripsServer)(nil).GetTrip), arg0, arg1)
}</span>

// GetTripsByUserID mocks base method.
func (m *MockTripsServer) GetTripsByUserID(arg0 context.Context, arg1 *gen.GetTripsByUserIDRequest) (*gen.GetTripsByUserIDResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTripsByUserID", arg0, arg1)
        ret0, _ := ret[0].(*gen.GetTripsByUserIDResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTripsByUserID indicates an expected call of GetTripsByUserID.
func (mr *MockTripsServerMockRecorder) GetTripsByUserID(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTripsByUserID", reflect.TypeOf((*MockTripsServer)(nil).GetTripsByUserID), arg0, arg1)
}</span>

// UpdateTrip mocks base method.
func (m *MockTripsServer) UpdateTrip(arg0 context.Context, arg1 *gen.UpdateTripRequest) (*gen.EmptyResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateTrip", arg0, arg1)
        ret0, _ := ret[0].(*gen.EmptyResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateTrip indicates an expected call of UpdateTrip.
func (mr *MockTripsServerMockRecorder) UpdateTrip(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTrip", reflect.TypeOf((*MockTripsServer)(nil).UpdateTrip), arg0, arg1)
}</span>

// mustEmbedUnimplementedTripsServer mocks base method.
func (m *MockTripsServer) mustEmbedUnimplementedTripsServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedTripsServer")
}</span>

// mustEmbedUnimplementedTripsServer indicates an expected call of mustEmbedUnimplementedTripsServer.
func (mr *MockTripsServerMockRecorder) mustEmbedUnimplementedTripsServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedTripsServer", reflect.TypeOf((*MockTripsServer)(nil).mustEmbedUnimplementedTripsServer))
}</span>

// MockUnsafeTripsServer is a mock of UnsafeTripsServer interface.
type MockUnsafeTripsServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeTripsServerMockRecorder
}

// MockUnsafeTripsServerMockRecorder is the mock recorder for MockUnsafeTripsServer.
type MockUnsafeTripsServerMockRecorder struct {
        mock *MockUnsafeTripsServer
}

// NewMockUnsafeTripsServer creates a new mock instance.
func NewMockUnsafeTripsServer(ctrl *gomock.Controller) *MockUnsafeTripsServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeTripsServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeTripsServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeTripsServer) EXPECT() *MockUnsafeTripsServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedTripsServer mocks base method.
func (m *MockUnsafeTripsServer) mustEmbedUnimplementedTripsServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedTripsServer")
}</span>

// mustEmbedUnimplementedTripsServer indicates an expected call of mustEmbedUnimplementedTripsServer.
func (mr *MockUnsafeTripsServerMockRecorder) mustEmbedUnimplementedTripsServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedTripsServer", reflect.TypeOf((*MockUnsafeTripsServer)(nil).mustEmbedUnimplementedTripsServer))
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/pkg/trips/interfaces.go

// Package mocks is a generated GoMock package.
package mocks

import (
        models "2024_2_ThereWillBeName/internal/models"
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockTripsUsecase is a mock of TripsUsecase interface.
type MockTripsUsecase struct {
        ctrl     *gomock.Controller
        recorder *MockTripsUsecaseMockRecorder
}

// MockTripsUsecaseMockRecorder is the mock recorder for MockTripsUsecase.
type MockTripsUsecaseMockRecorder struct {
        mock *MockTripsUsecase
}

// NewMockTripsUsecase creates a new mock instance.
func NewMockTripsUsecase(ctrl *gomock.Controller) *MockTripsUsecase <span class="cov8" title="1">{
        mock := &amp;MockTripsUsecase{ctrl: ctrl}
        mock.recorder = &amp;MockTripsUsecaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTripsUsecase) EXPECT() *MockTripsUsecaseMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddPhotosToTrip mocks base method.
func (m *MockTripsUsecase) AddPhotosToTrip(ctx context.Context, tripID uint, photos []string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddPhotosToTrip", ctx, tripID, photos)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddPhotosToTrip indicates an expected call of AddPhotosToTrip.
func (mr *MockTripsUsecaseMockRecorder) AddPhotosToTrip(ctx, tripID, photos interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPhotosToTrip", reflect.TypeOf((*MockTripsUsecase)(nil).AddPhotosToTrip), ctx, tripID, photos)
}</span>

// AddPlaceToTrip mocks base method.
func (m *MockTripsUsecase) AddPlaceToTrip(ctx context.Context, tripID, placeID uint) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddPlaceToTrip", ctx, tripID, placeID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddPlaceToTrip indicates an expected call of AddPlaceToTrip.
func (mr *MockTripsUsecaseMockRecorder) AddPlaceToTrip(ctx, tripID, placeID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPlaceToTrip", reflect.TypeOf((*MockTripsUsecase)(nil).AddPlaceToTrip), ctx, tripID, placeID)
}</span>

// CreateTrip mocks base method.
func (m *MockTripsUsecase) CreateTrip(ctx context.Context, trip models.Trip) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateTrip", ctx, trip)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateTrip indicates an expected call of CreateTrip.
func (mr *MockTripsUsecaseMockRecorder) CreateTrip(ctx, trip interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTrip", reflect.TypeOf((*MockTripsUsecase)(nil).CreateTrip), ctx, trip)
}</span>

// DeletePhotoFromTrip mocks base method.
func (m *MockTripsUsecase) DeletePhotoFromTrip(ctx context.Context, tripID uint, photoPath string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeletePhotoFromTrip", ctx, tripID, photoPath)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeletePhotoFromTrip indicates an expected call of DeletePhotoFromTrip.
func (mr *MockTripsUsecaseMockRecorder) DeletePhotoFromTrip(ctx, tripID, photoPath interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePhotoFromTrip", reflect.TypeOf((*MockTripsUsecase)(nil).DeletePhotoFromTrip), ctx, tripID, photoPath)
}</span>

// DeleteTrip mocks base method.
func (m *MockTripsUsecase) DeleteTrip(ctx context.Context, id uint) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteTrip", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteTrip indicates an expected call of DeleteTrip.
func (mr *MockTripsUsecaseMockRecorder) DeleteTrip(ctx, id interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTrip", reflect.TypeOf((*MockTripsUsecase)(nil).DeleteTrip), ctx, id)
}</span>

// GetTrip mocks base method.
func (m *MockTripsUsecase) GetTrip(ctx context.Context, tripID uint) (models.Trip, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTrip", ctx, tripID)
        ret0, _ := ret[0].(models.Trip)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTrip indicates an expected call of GetTrip.
func (mr *MockTripsUsecaseMockRecorder) GetTrip(ctx, tripID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTrip", reflect.TypeOf((*MockTripsUsecase)(nil).GetTrip), ctx, tripID)
}</span>

// GetTripsByUserID mocks base method.
func (m *MockTripsUsecase) GetTripsByUserID(ctx context.Context, userID uint, limit, offset int) ([]models.Trip, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTripsByUserID", ctx, userID, limit, offset)
        ret0, _ := ret[0].([]models.Trip)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTripsByUserID indicates an expected call of GetTripsByUserID.
func (mr *MockTripsUsecaseMockRecorder) GetTripsByUserID(ctx, userID, limit, offset interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTripsByUserID", reflect.TypeOf((*MockTripsUsecase)(nil).GetTripsByUserID), ctx, userID, limit, offset)
}</span>

// UpdateTrip mocks base method.
func (m *MockTripsUsecase) UpdateTrip(ctx context.Context, user models.Trip) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateTrip", ctx, user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateTrip indicates an expected call of UpdateTrip.
func (mr *MockTripsUsecaseMockRecorder) UpdateTrip(ctx, user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTrip", reflect.TypeOf((*MockTripsUsecase)(nil).UpdateTrip), ctx, user)
}</span>

// MockTripsRepo is a mock of TripsRepo interface.
type MockTripsRepo struct {
        ctrl     *gomock.Controller
        recorder *MockTripsRepoMockRecorder
}

// MockTripsRepoMockRecorder is the mock recorder for MockTripsRepo.
type MockTripsRepoMockRecorder struct {
        mock *MockTripsRepo
}

// NewMockTripsRepo creates a new mock instance.
func NewMockTripsRepo(ctrl *gomock.Controller) *MockTripsRepo <span class="cov8" title="1">{
        mock := &amp;MockTripsRepo{ctrl: ctrl}
        mock.recorder = &amp;MockTripsRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTripsRepo) EXPECT() *MockTripsRepoMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddPhotoToTrip mocks base method.
func (m *MockTripsRepo) AddPhotoToTrip(ctx context.Context, tripID uint, photoPath string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddPhotoToTrip", ctx, tripID, photoPath)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddPhotoToTrip indicates an expected call of AddPhotoToTrip.
func (mr *MockTripsRepoMockRecorder) AddPhotoToTrip(ctx, tripID, photoPath interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPhotoToTrip", reflect.TypeOf((*MockTripsRepo)(nil).AddPhotoToTrip), ctx, tripID, photoPath)
}</span>

// AddPlaceToTrip mocks base method.
func (m *MockTripsRepo) AddPlaceToTrip(ctx context.Context, tripID, placeID uint) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddPlaceToTrip", ctx, tripID, placeID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddPlaceToTrip indicates an expected call of AddPlaceToTrip.
func (mr *MockTripsRepoMockRecorder) AddPlaceToTrip(ctx, tripID, placeID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPlaceToTrip", reflect.TypeOf((*MockTripsRepo)(nil).AddPlaceToTrip), ctx, tripID, placeID)
}</span>

// CreateTrip mocks base method.
func (m *MockTripsRepo) CreateTrip(ctx context.Context, user models.Trip) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateTrip", ctx, user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateTrip indicates an expected call of CreateTrip.
func (mr *MockTripsRepoMockRecorder) CreateTrip(ctx, user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTrip", reflect.TypeOf((*MockTripsRepo)(nil).CreateTrip), ctx, user)
}</span>

// DeletePhotoFromTrip mocks base method.
func (m *MockTripsRepo) DeletePhotoFromTrip(ctx context.Context, tripID uint, photoPath string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeletePhotoFromTrip", ctx, tripID, photoPath)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeletePhotoFromTrip indicates an expected call of DeletePhotoFromTrip.
func (mr *MockTripsRepoMockRecorder) DeletePhotoFromTrip(ctx, tripID, photoPath interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePhotoFromTrip", reflect.TypeOf((*MockTripsRepo)(nil).DeletePhotoFromTrip), ctx, tripID, photoPath)
}</span>

// DeleteTrip mocks base method.
func (m *MockTripsRepo) DeleteTrip(ctx context.Context, id uint) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteTrip", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteTrip indicates an expected call of DeleteTrip.
func (mr *MockTripsRepoMockRecorder) DeleteTrip(ctx, id interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTrip", reflect.TypeOf((*MockTripsRepo)(nil).DeleteTrip), ctx, id)
}</span>

// GetTrip mocks base method.
func (m *MockTripsRepo) GetTrip(ctx context.Context, tripID uint) (models.Trip, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTrip", ctx, tripID)
        ret0, _ := ret[0].(models.Trip)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTrip indicates an expected call of GetTrip.
func (mr *MockTripsRepoMockRecorder) GetTrip(ctx, tripID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTrip", reflect.TypeOf((*MockTripsRepo)(nil).GetTrip), ctx, tripID)
}</span>

// GetTripsByUserID mocks base method.
func (m *MockTripsRepo) GetTripsByUserID(ctx context.Context, userID uint, limit, offset int) ([]models.Trip, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTripsByUserID", ctx, userID, limit, offset)
        ret0, _ := ret[0].([]models.Trip)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTripsByUserID indicates an expected call of GetTripsByUserID.
func (mr *MockTripsRepoMockRecorder) GetTripsByUserID(ctx, userID, limit, offset interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTripsByUserID", reflect.TypeOf((*MockTripsRepo)(nil).GetTripsByUserID), ctx, userID, limit, offset)
}</span>

// UpdateTrip mocks base method.
func (m *MockTripsRepo) UpdateTrip(ctx context.Context, user models.Trip) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateTrip", ctx, user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateTrip indicates an expected call of UpdateTrip.
func (mr *MockTripsRepoMockRecorder) UpdateTrip(ctx, user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTrip", reflect.TypeOf((*MockTripsRepo)(nil).UpdateTrip), ctx, user)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package repo

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/dblogger"

        "context"
        "database/sql"
        "fmt"

        "github.com/lib/pq"
)

type TripRepository struct {
        db *dblogger.DB
}

func NewTripRepository(db *dblogger.DB) *TripRepository <span class="cov8" title="1">{
        return &amp;TripRepository{db: db}
}</span>

func (r *TripRepository) CreateTrip(ctx context.Context, trip models.Trip) error <span class="cov8" title="1">{
        query := `INSERT INTO trip (user_id, name, description, city_id, start_date, end_date, private, created_at) 
              VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())`

        result, err := r.db.ExecContext(ctx, query, trip.UserID, trip.Name, trip.Description, trip.CityID, trip.StartDate, trip.EndDate, trip.Private)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create a trip: %w", models.ErrInternal)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retrieve rows affected: %w", models.ErrInternal)
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no rows were created: %w", models.ErrNotFound)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *TripRepository) UpdateTrip(ctx context.Context, trip models.Trip) error <span class="cov8" title="1">{
        query := `UPDATE trip 
              SET name = $1, description = $2, city_id = $3, start_date = $4, end_date = $5, private = $6, updated_at = NOW() 
              WHERE id = $7`

        result, err := r.db.ExecContext(ctx, query, trip.Name, trip.Description, trip.CityID, trip.StartDate, trip.EndDate, trip.Private, trip.ID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to execute update query: %w", models.ErrInternal)
        }</span>
        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retrieve rows affected: %w", models.ErrInternal)
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no rows were updated: %w", models.ErrNotFound)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *TripRepository) DeleteTrip(ctx context.Context, id uint) error <span class="cov8" title="1">{
        query := `DELETE FROM trip WHERE id = $1`
        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete trip: %w", models.ErrInternal)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retrieve rows affected %w", models.ErrInternal)
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no rows were deleted: %w", models.ErrNotFound)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *TripRepository) GetTripsByUserID(ctx context.Context, userID uint, limit, offset int) ([]models.Trip, error) <span class="cov8" title="1">{
        query := `
                SELECT 
                        t.id, t.user_id, t.name, t.description, t.city_id, 
                        t.start_date, t.end_date, t.private, t.created_at, 
                        COALESCE(ARRAY_AGG(tp.photo_path) FILTER (WHERE tp.photo_path IS NOT NULL), '{}') AS photos
                FROM trip t
                LEFT JOIN trip_photo tp ON t.id = tp.trip_id
                WHERE t.user_id = $1
                GROUP BY t.id
                ORDER BY t.created_at DESC
                LIMIT $2 OFFSET $3`

        rows, err := r.db.QueryContext(ctx, query, userID, limit, offset)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to retrieve trips: %w", models.ErrInternal)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var trips []models.Trip
        for rows.Next() </span><span class="cov8" title="1">{
                var trip models.Trip
                if err := rows.Scan(
                        &amp;trip.ID, &amp;trip.UserID, &amp;trip.Name, &amp;trip.Description,
                        &amp;trip.CityID, &amp;trip.StartDate, &amp;trip.EndDate, &amp;trip.Private,
                        &amp;trip.CreatedAt, pq.Array(&amp;trip.Photos),
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan trip row: %w", models.ErrInternal)
                }</span>

                <span class="cov8" title="1">trips = append(trips, trip)</span>
        }

        <span class="cov8" title="1">if len(trips) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no trips found: %w", models.ErrNotFound)
        }</span>

        <span class="cov8" title="1">return trips, nil</span>
}

func (r *TripRepository) GetTrip(ctx context.Context, tripID uint) (models.Trip, error) <span class="cov0" title="0">{
        var trip models.Trip

        query := `
        SELECT 
            id, user_id, name, description, city_id, start_date, end_date, private, created_at 
        FROM 
            trip
        WHERE 
            id = $1
    `
        err := r.db.QueryRowContext(ctx, query, tripID).Scan(
                &amp;trip.ID,
                &amp;trip.UserID,
                &amp;trip.Name,
                &amp;trip.Description,
                &amp;trip.CityID,
                &amp;trip.StartDate,
                &amp;trip.EndDate,
                &amp;trip.Private,
                &amp;trip.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return trip, models.ErrNotFound
                }</span>
                <span class="cov0" title="0">return trip, fmt.Errorf("failed to get trip: %w", err)</span>
        }

        <span class="cov0" title="0">photoQuery := `
        SELECT photo_path 
        FROM trip_photo
        WHERE trip_id = $1
    `
        rows, err := r.db.QueryContext(ctx, photoQuery, tripID)
        if err != nil </span><span class="cov0" title="0">{
                return trip, fmt.Errorf("failed to get trip photos: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var photos []string
        for rows.Next() </span><span class="cov0" title="0">{
                var photoPath string
                if err := rows.Scan(&amp;photoPath); err != nil </span><span class="cov0" title="0">{
                        return trip, fmt.Errorf("failed to scan photo: %w", err)
                }</span>
                <span class="cov0" title="0">photos = append(photos, photoPath)</span>
        }

        <span class="cov0" title="0">trip.Photos = photos

        return trip, nil</span>
}

func (r *TripRepository) AddPlaceToTrip(ctx context.Context, tripID uint, placeID uint) error <span class="cov8" title="1">{
        query := `INSERT INTO trip_place (trip_id, place_id, created_at) 
              VALUES ($1, $2, NOW())`

        result, err := r.db.ExecContext(ctx, query, tripID, placeID)

        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to add place to a trip: %w", models.ErrInternal)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retrieve rows affected: %w", models.ErrInternal)
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no rows were created: %w", models.ErrNotFound)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *TripRepository) AddPhotoToTrip(ctx context.Context, tripID uint, photoPath string) error <span class="cov8" title="1">{
        query := `
        INSERT INTO trip_photo (trip_id, photo_path)
        VALUES ($1, $2)
    `
        _, err := r.db.ExecContext(ctx, query, tripID, photoPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to insert photo into database: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *TripRepository) DeletePhotoFromTrip(ctx context.Context, tripID uint, photoPath string) error <span class="cov8" title="1">{
        query := `DELETE FROM trip_photo WHERE trip_id = $1 AND photo_path = $2`
        result, err := r.db.ExecContext(ctx, query, tripID, photoPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete photo from database: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get affected rows: %w", err)
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("photo not found in trip: %w", models.ErrNotFound)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package usecase

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/trips"
        "context"
        "errors"
        "fmt"
        "path"
)

type TripsUsecaseImpl struct {
        tripRepo trips.TripsRepo
}

func NewTripsUsecase(repo trips.TripsRepo) *TripsUsecaseImpl <span class="cov8" title="1">{
        return &amp;TripsUsecaseImpl{
                tripRepo: repo,
        }
}</span>

func (u *TripsUsecaseImpl) CreateTrip(ctx context.Context, trip models.Trip) error <span class="cov8" title="1">{
        err := u.tripRepo.CreateTrip(ctx, trip)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span> else<span class="cov8" title="1"> {
                        return fmt.Errorf("internal error: %w", models.ErrInternal)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (u *TripsUsecaseImpl) UpdateTrip(ctx context.Context, trip models.Trip) error <span class="cov8" title="1">{
        err := u.tripRepo.UpdateTrip(ctx, trip)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span> else<span class="cov8" title="1"> {
                        return fmt.Errorf("internal error: %w", models.ErrInternal)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (u *TripsUsecaseImpl) DeleteTrip(ctx context.Context, id uint) error <span class="cov8" title="1">{
        err := u.tripRepo.DeleteTrip(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (u *TripsUsecaseImpl) GetTripsByUserID(ctx context.Context, userID uint, limit, offset int) ([]models.Trip, error) <span class="cov8" title="1">{
        tripsFound, err := u.tripRepo.GetTripsByUserID(ctx, userID, limit, offset)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }
        <span class="cov8" title="1">return tripsFound, nil</span>
}

func (u *TripsUsecaseImpl) GetTrip(ctx context.Context, tripID uint) (models.Trip, error) <span class="cov8" title="1">{
        trip, err := u.tripRepo.GetTrip(ctx, tripID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return models.Trip{}, fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov8" title="1">return models.Trip{}, fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }
        <span class="cov8" title="1">return trip, nil</span>
}

func (u *TripsUsecaseImpl) AddPlaceToTrip(ctx context.Context, tripID uint, placeID uint) error <span class="cov8" title="1">{
        err := u.tripRepo.AddPlaceToTrip(ctx, tripID, placeID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span> else<span class="cov8" title="1"> {
                        return fmt.Errorf("internal error: %w", models.ErrInternal)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (u *TripsUsecaseImpl) AddPhotosToTrip(ctx context.Context, tripID uint, photoPaths []string) error <span class="cov8" title="1">{
        for _, fullpath := range photoPaths </span><span class="cov8" title="1">{
                filename := path.Base(fullpath)
                err := u.tripRepo.AddPhotoToTrip(ctx, tripID, filename)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to add photo to trip: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (u *TripsUsecaseImpl) DeletePhotoFromTrip(ctx context.Context, tripID uint, photoPath string) error <span class="cov8" title="1">{
        err := u.tripRepo.DeletePhotoFromTrip(ctx, tripID, photoPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete photo from database: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v3.12.4
// source: user.proto

package gen

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SignUpRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Login    string `protobuf:"bytes,1,opt,name=login,proto3" json:"login,omitempty"`
        Email    string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *SignUpRequest) Reset() <span class="cov0" title="0">{
        *x = SignUpRequest{}
        mi := &amp;file_user_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SignUpRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SignUpRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SignUpRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SignUpRequest.ProtoReflect.Descriptor instead.
func (*SignUpRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{0}
}</span>

func (x *SignUpRequest) GetLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Login
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SignUpRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SignUpRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SignUpResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *SignUpResponse) Reset() <span class="cov0" title="0">{
        *x = SignUpResponse{}
        mi := &amp;file_user_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SignUpResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SignUpResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SignUpResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SignUpResponse.ProtoReflect.Descriptor instead.
func (*SignUpResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{1}
}</span>

func (x *SignUpResponse) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type LoginRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Email    string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        mi := &amp;file_user_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{2}
}</span>

func (x *LoginRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoginResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id         uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Login      string `protobuf:"bytes,2,opt,name=login,proto3" json:"login,omitempty"`
        Email      string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        AvatarPath string `protobuf:"bytes,4,opt,name=avatar_path,json=avatarPath,proto3" json:"avatar_path,omitempty"`
}

func (x *LoginResponse) Reset() <span class="cov0" title="0">{
        *x = LoginResponse{}
        mi := &amp;file_user_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{3}
}</span>

func (x *LoginResponse) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *LoginResponse) GetLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Login
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetAvatarPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvatarPath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UploadAvatarRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id             uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        AvatarData     []byte `protobuf:"bytes,2,opt,name=avatar_data,json=avatarData,proto3" json:"avatar_data,omitempty"`
        AvatarFileName string `protobuf:"bytes,3,opt,name=avatar_file_name,json=avatarFileName,proto3" json:"avatar_file_name,omitempty"`
}

func (x *UploadAvatarRequest) Reset() <span class="cov0" title="0">{
        *x = UploadAvatarRequest{}
        mi := &amp;file_user_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UploadAvatarRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UploadAvatarRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UploadAvatarRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UploadAvatarRequest.ProtoReflect.Descriptor instead.
func (*UploadAvatarRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{4}
}</span>

func (x *UploadAvatarRequest) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UploadAvatarRequest) GetAvatarData() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvatarData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UploadAvatarRequest) GetAvatarFileName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvatarFileName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UploadAvatarResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AvatarPath string `protobuf:"bytes,2,opt,name=avatar_path,json=avatarPath,proto3" json:"avatar_path,omitempty"`
}

func (x *UploadAvatarResponse) Reset() <span class="cov0" title="0">{
        *x = UploadAvatarResponse{}
        mi := &amp;file_user_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UploadAvatarResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UploadAvatarResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UploadAvatarResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UploadAvatarResponse.ProtoReflect.Descriptor instead.
func (*UploadAvatarResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{5}
}</span>

func (x *UploadAvatarResponse) GetAvatarPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvatarPath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetProfileRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id          uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        RequesterId uint32 `protobuf:"varint,2,opt,name=requester_id,json=requesterId,proto3" json:"requester_id,omitempty"`
}

func (x *GetProfileRequest) Reset() <span class="cov0" title="0">{
        *x = GetProfileRequest{}
        mi := &amp;file_user_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetProfileRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetProfileRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetProfileRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetProfileRequest.ProtoReflect.Descriptor instead.
func (*GetProfileRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetProfileRequest) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetProfileRequest) GetRequesterId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequesterId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetProfileResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Login      string `protobuf:"bytes,1,opt,name=login,proto3" json:"login,omitempty"`
        Email      string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        AvatarPath string `protobuf:"bytes,3,opt,name=avatar_path,json=avatarPath,proto3" json:"avatar_path,omitempty"`
}

func (x *GetProfileResponse) Reset() <span class="cov0" title="0">{
        *x = GetProfileResponse{}
        mi := &amp;file_user_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetProfileResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetProfileResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetProfileResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetProfileResponse.ProtoReflect.Descriptor instead.
func (*GetProfileResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetProfileResponse) GetLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Login
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetProfileResponse) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetProfileResponse) GetAvatarPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvatarPath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdatePasswordRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id          uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Login       string `protobuf:"bytes,2,opt,name=login,proto3" json:"login,omitempty"`
        Email       string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        OldPassword string `protobuf:"bytes,4,opt,name=old_password,json=oldPassword,proto3" json:"old_password,omitempty"`
        NewPassword string `protobuf:"bytes,5,opt,name=new_password,json=newPassword,proto3" json:"new_password,omitempty"`
}

func (x *UpdatePasswordRequest) Reset() <span class="cov0" title="0">{
        *x = UpdatePasswordRequest{}
        mi := &amp;file_user_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdatePasswordRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdatePasswordRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdatePasswordRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdatePasswordRequest.ProtoReflect.Descriptor instead.
func (*UpdatePasswordRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{8}
}</span>

func (x *UpdatePasswordRequest) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UpdatePasswordRequest) GetLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Login
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdatePasswordRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdatePasswordRequest) GetOldPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OldPassword
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdatePasswordRequest) GetNewPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NewPassword
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdateProfileRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId   uint32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        Email    string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
}

func (x *UpdateProfileRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateProfileRequest{}
        mi := &amp;file_user_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateProfileRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateProfileRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateProfileRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateProfileRequest.ProtoReflect.Descriptor instead.
func (*UpdateProfileRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{9}
}</span>

func (x *UpdateProfileRequest) GetUserId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UpdateProfileRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateProfileRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type EmptyResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *EmptyResponse) Reset() <span class="cov0" title="0">{
        *x = EmptyResponse{}
        mi := &amp;file_user_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *EmptyResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EmptyResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EmptyResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EmptyResponse.ProtoReflect.Descriptor instead.
func (*EmptyResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{10}
}</span>

var File_user_proto protoreflect.FileDescriptor

var file_user_proto_rawDesc = []byte{
        0x0a, 0x0a, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x04, 0x75, 0x73,
        0x65, 0x72, 0x22, 0x57, 0x0a, 0x0d, 0x53, 0x69, 0x67, 0x6e, 0x55, 0x70, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61,
        0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12,
        0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x20, 0x0a, 0x0e, 0x53,
        0x69, 0x67, 0x6e, 0x55, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a,
        0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x22, 0x40, 0x0a,
        0x0c, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a,
        0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d,
        0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22,
        0x6c, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64,
        0x12, 0x14, 0x0a, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1f, 0x0a, 0x0b,
        0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x0a, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x50, 0x61, 0x74, 0x68, 0x22, 0x70, 0x0a,
        0x13, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x41, 0x76, 0x61, 0x74, 0x61, 0x72, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
        0x52, 0x02, 0x69, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x5f, 0x64,
        0x61, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0a, 0x61, 0x76, 0x61, 0x74, 0x61,
        0x72, 0x44, 0x61, 0x74, 0x61, 0x12, 0x28, 0x0a, 0x10, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x5f,
        0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0e, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x46, 0x69, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x22,
        0x37, 0x0a, 0x14, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x41, 0x76, 0x61, 0x74, 0x61, 0x72, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x76, 0x61, 0x74, 0x61,
        0x72, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x61, 0x76,
        0x61, 0x74, 0x61, 0x72, 0x50, 0x61, 0x74, 0x68, 0x22, 0x46, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x50,
        0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a,
        0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x12, 0x21, 0x0a,
        0x0c, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x0d, 0x52, 0x0b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x72, 0x49, 0x64,
        0x22, 0x61, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x14, 0x0a, 0x05,
        0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61,
        0x69, 0x6c, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x5f, 0x70, 0x61, 0x74,
        0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x50,
        0x61, 0x74, 0x68, 0x22, 0x99, 0x01, 0x0a, 0x15, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61,
        0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a,
        0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64, 0x12, 0x14, 0x0a,
        0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6c, 0x6f,
        0x67, 0x69, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x21, 0x0a, 0x0c, 0x6f, 0x6c, 0x64,
        0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0b, 0x6f, 0x6c, 0x64, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x21, 0x0a, 0x0c,
        0x6e, 0x65, 0x77, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x05, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x0b, 0x6e, 0x65, 0x77, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22,
        0x61, 0x0a, 0x14, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f,
        0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64,
        0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05,
        0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61,
        0x69, 0x6c, 0x22, 0x0f, 0x0a, 0x0d, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x32, 0x8e, 0x03, 0x0a, 0x0b, 0x55, 0x73, 0x65, 0x72, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x12, 0x35, 0x0a, 0x06, 0x53, 0x69, 0x67, 0x6e, 0x55, 0x70, 0x12, 0x13, 0x2e,
        0x75, 0x73, 0x65, 0x72, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x55, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x14, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x55, 0x70,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x32, 0x0a, 0x05, 0x4c, 0x6f,
        0x67, 0x69, 0x6e, 0x12, 0x12, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x4c,
        0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x47,
        0x0a, 0x0c, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x41, 0x76, 0x61, 0x74, 0x61, 0x72, 0x12, 0x19,
        0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x41, 0x76, 0x61, 0x74,
        0x61, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x75, 0x73, 0x65, 0x72,
        0x2e, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x41, 0x76, 0x61, 0x74, 0x61, 0x72, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x41, 0x0a, 0x0a, 0x47, 0x65, 0x74, 0x50, 0x72,
        0x6f, 0x66, 0x69, 0x6c, 0x65, 0x12, 0x17, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x47, 0x65, 0x74,
        0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x18,
        0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x47, 0x65, 0x74, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x44, 0x0a, 0x0e, 0x55, 0x70,
        0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x1b, 0x2e, 0x75,
        0x73, 0x65, 0x72, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f,
        0x72, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e, 0x75, 0x73, 0x65, 0x72,
        0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
        0x12, 0x42, 0x0a, 0x0d, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c,
        0x65, 0x12, 0x1a, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50,
        0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e,
        0x75, 0x73, 0x65, 0x72, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x22, 0x00, 0x42, 0x07, 0x5a, 0x05, 0x2e, 0x3b, 0x67, 0x65, 0x6e, 0x62, 0x06, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_user_proto_rawDescOnce sync.Once
        file_user_proto_rawDescData = file_user_proto_rawDesc
)

func file_user_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_user_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_user_proto_rawDescData = protoimpl.X.CompressGZIP(file_user_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_user_proto_rawDescData</span>
}

var file_user_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_user_proto_goTypes = []any{
        (*SignUpRequest)(nil),         // 0: user.SignUpRequest
        (*SignUpResponse)(nil),        // 1: user.SignUpResponse
        (*LoginRequest)(nil),          // 2: user.LoginRequest
        (*LoginResponse)(nil),         // 3: user.LoginResponse
        (*UploadAvatarRequest)(nil),   // 4: user.UploadAvatarRequest
        (*UploadAvatarResponse)(nil),  // 5: user.UploadAvatarResponse
        (*GetProfileRequest)(nil),     // 6: user.GetProfileRequest
        (*GetProfileResponse)(nil),    // 7: user.GetProfileResponse
        (*UpdatePasswordRequest)(nil), // 8: user.UpdatePasswordRequest
        (*UpdateProfileRequest)(nil),  // 9: user.UpdateProfileRequest
        (*EmptyResponse)(nil),         // 10: user.EmptyResponse
}
var file_user_proto_depIdxs = []int32{
        0,  // 0: user.UserService.SignUp:input_type -&gt; user.SignUpRequest
        2,  // 1: user.UserService.Login:input_type -&gt; user.LoginRequest
        4,  // 2: user.UserService.UploadAvatar:input_type -&gt; user.UploadAvatarRequest
        6,  // 3: user.UserService.GetProfile:input_type -&gt; user.GetProfileRequest
        8,  // 4: user.UserService.UpdatePassword:input_type -&gt; user.UpdatePasswordRequest
        9,  // 5: user.UserService.UpdateProfile:input_type -&gt; user.UpdateProfileRequest
        1,  // 6: user.UserService.SignUp:output_type -&gt; user.SignUpResponse
        3,  // 7: user.UserService.Login:output_type -&gt; user.LoginResponse
        5,  // 8: user.UserService.UploadAvatar:output_type -&gt; user.UploadAvatarResponse
        7,  // 9: user.UserService.GetProfile:output_type -&gt; user.GetProfileResponse
        10, // 10: user.UserService.UpdatePassword:output_type -&gt; user.EmptyResponse
        10, // 11: user.UserService.UpdateProfile:output_type -&gt; user.EmptyResponse
        6,  // [6:12] is the sub-list for method output_type
        0,  // [0:6] is the sub-list for method input_type
        0,  // [0:0] is the sub-list for extension type_name
        0,  // [0:0] is the sub-list for extension extendee
        0,  // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_user_proto_init() }</span>
func file_user_proto_init() <span class="cov8" title="1">{
        if File_user_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_user_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   11,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_user_proto_goTypes,
                DependencyIndexes: file_user_proto_depIdxs,
                MessageInfos:      file_user_proto_msgTypes,
        }.Build()
        File_user_proto = out.File
        file_user_proto_rawDesc = nil
        file_user_proto_goTypes = nil
        file_user_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: user.proto

package gen

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        UserService_SignUp_FullMethodName         = "/user.UserService/SignUp"
        UserService_Login_FullMethodName          = "/user.UserService/Login"
        UserService_UploadAvatar_FullMethodName   = "/user.UserService/UploadAvatar"
        UserService_GetProfile_FullMethodName     = "/user.UserService/GetProfile"
        UserService_UpdatePassword_FullMethodName = "/user.UserService/UpdatePassword"
        UserService_UpdateProfile_FullMethodName  = "/user.UserService/UpdateProfile"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
        SignUp(ctx context.Context, in *SignUpRequest, opts ...grpc.CallOption) (*SignUpResponse, error)
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
        UploadAvatar(ctx context.Context, in *UploadAvatarRequest, opts ...grpc.CallOption) (*UploadAvatarResponse, error)
        GetProfile(ctx context.Context, in *GetProfileRequest, opts ...grpc.CallOption) (*GetProfileResponse, error)
        UpdatePassword(ctx context.Context, in *UpdatePasswordRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
        UpdateProfile(ctx context.Context, in *UpdateProfileRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
}

type userServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient <span class="cov0" title="0">{
        return &amp;userServiceClient{cc}
}</span>

func (c *userServiceClient) SignUp(ctx context.Context, in *SignUpRequest, opts ...grpc.CallOption) (*SignUpResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SignUpResponse)
        err := c.cc.Invoke(ctx, UserService_SignUp_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LoginResponse)
        err := c.cc.Invoke(ctx, UserService_Login_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) UploadAvatar(ctx context.Context, in *UploadAvatarRequest, opts ...grpc.CallOption) (*UploadAvatarResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UploadAvatarResponse)
        err := c.cc.Invoke(ctx, UserService_UploadAvatar_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) GetProfile(ctx context.Context, in *GetProfileRequest, opts ...grpc.CallOption) (*GetProfileResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetProfileResponse)
        err := c.cc.Invoke(ctx, UserService_GetProfile_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) UpdatePassword(ctx context.Context, in *UpdatePasswordRequest, opts ...grpc.CallOption) (*EmptyResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EmptyResponse)
        err := c.cc.Invoke(ctx, UserService_UpdatePassword_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) UpdateProfile(ctx context.Context, in *UpdateProfileRequest, opts ...grpc.CallOption) (*EmptyResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EmptyResponse)
        err := c.cc.Invoke(ctx, UserService_UpdateProfile_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
        SignUp(context.Context, *SignUpRequest) (*SignUpResponse, error)
        Login(context.Context, *LoginRequest) (*LoginResponse, error)
        UploadAvatar(context.Context, *UploadAvatarRequest) (*UploadAvatarResponse, error)
        GetProfile(context.Context, *GetProfileRequest) (*GetProfileResponse, error)
        UpdatePassword(context.Context, *UpdatePasswordRequest) (*EmptyResponse, error)
        UpdateProfile(context.Context, *UpdateProfileRequest) (*EmptyResponse, error)
        mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) SignUp(context.Context, *SignUpRequest) (*SignUpResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SignUp not implemented")
}</span>
func (UnimplementedUserServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedUserServiceServer) UploadAvatar(context.Context, *UploadAvatarRequest) (*UploadAvatarResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UploadAvatar not implemented")
}</span>
func (UnimplementedUserServiceServer) GetProfile(context.Context, *GetProfileRequest) (*GetProfileResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetProfile not implemented")
}</span>
func (UnimplementedUserServiceServer) UpdatePassword(context.Context, *UpdatePasswordRequest) (*EmptyResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdatePassword not implemented")
}</span>
func (UnimplementedUserServiceServer) UpdateProfile(context.Context, *UpdateProfileRequest) (*EmptyResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateProfile not implemented")
}</span>
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
        mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedUserServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;UserService_ServiceDesc, srv)</span>
}

func _UserService_SignUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SignUpRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).SignUp(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_SignUp_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).SignUp(ctx, req.(*SignUpRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_Login_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_UploadAvatar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UploadAvatarRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UploadAvatar(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_UploadAvatar_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UploadAvatar(ctx, req.(*UploadAvatarRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_GetProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetProfileRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetProfile(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_GetProfile_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetProfile(ctx, req.(*GetProfileRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_UpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdatePasswordRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdatePassword(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_UpdatePassword_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdatePassword(ctx, req.(*UpdatePasswordRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_UpdateProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateProfileRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdateProfile(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_UpdateProfile_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdateProfile(ctx, req.(*UpdateProfileRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "user.UserService",
        HandlerType: (*UserServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "SignUp",
                        Handler:    _UserService_SignUp_Handler,
                },
                {
                        MethodName: "Login",
                        Handler:    _UserService_Login_Handler,
                },
                {
                        MethodName: "UploadAvatar",
                        Handler:    _UserService_UploadAvatar_Handler,
                },
                {
                        MethodName: "GetProfile",
                        Handler:    _UserService_GetProfile_Handler,
                },
                {
                        MethodName: "UpdatePassword",
                        Handler:    _UserService_UpdatePassword_Handler,
                },
                {
                        MethodName: "UpdateProfile",
                        Handler:    _UserService_UpdateProfile_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "user.proto",
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package grpc

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/user"
        "2024_2_ThereWillBeName/internal/pkg/user/delivery/grpc/gen"
        "context"
        "log/slog"
)

type GrpcUserHandler struct {
        gen.UserServiceServer
        usecase user.UserUsecase
        logger  *slog.Logger
}

func NewGrpcUserHandler(usecase user.UserUsecase, logger *slog.Logger) *GrpcUserHandler <span class="cov0" title="0">{
        return &amp;GrpcUserHandler{usecase: usecase, logger: logger}
}</span>

func (h *GrpcUserHandler) SignUp(ctx context.Context, in *gen.SignUpRequest) (*gen.SignUpResponse, error) <span class="cov0" title="0">{
        user := models.User{
                Login:    in.Login,
                Email:    in.Email,
                Password: in.Password,
        }

        userID, err := h.usecase.SignUp(context.Background(), user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;gen.SignUpResponse{
                Id: uint32(userID),
        }, nil</span>
}

func (h *GrpcUserHandler) Login(ctx context.Context, in *gen.LoginRequest) (*gen.LoginResponse, error) <span class="cov0" title="0">{
        user, err := h.usecase.Login(context.Background(), in.Email, in.Password)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;gen.LoginResponse{
                Id:         uint32(user.ID),
                Login:      user.Login,
                Email:      user.Email,
                AvatarPath: user.AvatarPath,
        }, nil</span>
}

func (h *GrpcUserHandler) UploadAvatar(ctx context.Context, in *gen.UploadAvatarRequest) (*gen.UploadAvatarResponse, error) <span class="cov0" title="0">{
        avatarPath, err := h.usecase.UploadAvatar(context.Background(), uint(in.Id), in.AvatarData, in.AvatarFileName)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;gen.UploadAvatarResponse{
                AvatarPath: avatarPath,
        }, nil</span>
}

func (h *GrpcUserHandler) GetProfile(ctx context.Context, in *gen.GetProfileRequest) (*gen.GetProfileResponse, error) <span class="cov0" title="0">{
        profile, err := h.usecase.GetProfile(ctx, uint(in.Id), uint(in.RequesterId))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;gen.GetProfileResponse{
                Login:      profile.Login,
                Email:      profile.Email,
                AvatarPath: profile.AvatarPath,
        }, nil</span>
}

func (h *GrpcUserHandler) UpdatePassword(ctx context.Context, in *gen.UpdatePasswordRequest) (*gen.EmptyResponse, error) <span class="cov0" title="0">{
        user := models.User{
                ID:       uint(in.Id),
                Login:    in.Login,
                Email:    in.Email,
                Password: in.OldPassword,
        }

        err := h.usecase.UpdatePassword(ctx, user, in.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;gen.EmptyResponse{}, nil</span>
}

func (h *GrpcUserHandler) UpdateProfile(ctx context.Context, in *gen.UpdateProfileRequest) (*gen.EmptyResponse, error) <span class="cov0" title="0">{

        err := h.usecase.UpdateProfile(ctx, uint(in.UserId), in.Username, in.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;gen.EmptyResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package http

import (
        "2024_2_ThereWillBeName/internal/models"
        httpresponse "2024_2_ThereWillBeName/internal/pkg/httpresponses"
        "2024_2_ThereWillBeName/internal/pkg/jwt"
        log "2024_2_ThereWillBeName/internal/pkg/logger"
        "2024_2_ThereWillBeName/internal/pkg/middleware"
        "2024_2_ThereWillBeName/internal/pkg/user/delivery/grpc/gen"
        "2024_2_ThereWillBeName/internal/validator"

        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "html/template"
        "log/slog"
        "mime"
        "net/http"
        "strconv"
        "strings"

        "github.com/gorilla/mux"
)

type Credentials struct {
        Login    string `json:"login"`
        Email    string `json:"email"`
        Password string `json:"password"`
}

type Handler struct {
        client gen.UserServiceClient
        jwt    jwt.JWTInterface
        logger *slog.Logger
}

type UserResponseWithToken struct {
        User  models.User `json:"user"`
        Token string      `json:"token"`
}

func NewUserHandler(client gen.UserServiceClient, jwt jwt.JWTInterface, logger *slog.Logger) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                client: client,
                jwt:    jwt,
                logger: logger,
        }
}</span>

// SignUp godoc
// @Summary Sign up a new user
// @Description Create a new user with login and password
// @Accept json
// @Produce json
// @Param credentials body Credentials true "User credentials"
// @Success 201 {object} models.User "User created successfully"
// @Failure 400 {object} httpresponses.ErrorResponse "Bad Request"
// @Failure 500 {object} httpresponses.ErrorResponse "Internal Server Error"
// @Router /signup [post]
func (h *Handler) SignUp(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'; style-src 'self';")
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for sign up")

        var credentials Credentials

        if err := json.NewDecoder(r.Body).Decode(&amp;credentials); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Failed to decode credentials", slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid request",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">credentials.Login = template.HTMLEscapeString(credentials.Login)
        credentials.Email = template.HTMLEscapeString(credentials.Email)
        credentials.Password = template.HTMLEscapeString(credentials.Password)

        user := models.User{
                Login:    credentials.Login,
                Email:    credentials.Email,
                Password: credentials.Password,
        }

        v := validator.New()
        if models.ValidateUser(v, &amp;user); !v.Valid() </span><span class="cov0" title="0">{
                httpresponse.SendJSONResponse(w, nil, http.StatusUnprocessableEntity, h.logger)
                return
        }</span>

        <span class="cov0" title="0">signUpRequest := &amp;gen.SignUpRequest{
                Login:    user.Login,
                Email:    user.Email,
                Password: user.Password,
        }

        var err error
        signupResponse, err := h.client.SignUp(r.Context(), signUpRequest)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrAlreadyExists) </span><span class="cov0" title="0">{
                        h.logger.Warn("User already exists", slog.String("login", user.Login), slog.String("email", user.Email))
                        response := httpresponse.ErrorResponse{
                                Message: "user already exists",
                        }
                        httpresponse.SendJSONResponse(w, response, http.StatusConflict, h.logger)
                        return
                }</span>

                <span class="cov0" title="0">h.logger.Error("Failed to sign up user", slog.String("error", err.Error()))

                response := httpresponse.ErrorResponse{
                        Message: "Registration failed",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusInternalServerError, h.logger)
                return</span>
        }

        <span class="cov0" title="0">user.ID = uint(signupResponse.Id)

        h.logger.Debug("User signed up successfully", slog.Int("userID", int(user.ID)), slog.String("login", user.Login))

        token, err := h.jwt.GenerateToken(user.ID, user.Email, user.Login)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Token generation failed", slog.String("userID", strconv.Itoa(int(user.ID))), slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Token generation failed",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusInternalServerError, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug("Token generated", slog.String("userID", strconv.Itoa(int(user.ID))), slog.String("login", user.Login), slog.String("email", user.Email))

        response := UserResponseWithToken{
                User: models.User{
                        ID:    user.ID,
                        Login: user.Login,
                        Email: user.Email,
                },
                Token: token,
        }
        h.logger.DebugContext(logCtx, "Sign-up request completed successfully")

        httpresponse.SendJSONResponse(w, response, http.StatusOK, h.logger)</span>
}

// Login godoc
// @Summary Login a user
// @Description Authenticate a user and return a token
// @Accept json
// @Produce json
// @Param credentials body Credentials true "User credentials"
// @Success 200 {string} string "Token"
// @Failure 400 {object} httpresponses.ErrorResponse "Bad Request"
// @Failure 401 {object} httpresponses.ErrorResponse "Unauthorized"
// @Router /login [post]
func (h *Handler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'; style-src 'self';")
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling request for log in")

        var credentials struct {
                Email    string `json:"email"`
                Password string `json:"password"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;credentials); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Failed to decode credentials", slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Invalid request",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">credentials.Email = template.HTMLEscapeString(credentials.Email)
        credentials.Password = template.HTMLEscapeString(credentials.Password)

        loginRequest := &amp;gen.LoginRequest{
                Email:    credentials.Email,
                Password: credentials.Password,
        }

        loginResponse, err := h.client.Login(r.Context(), loginRequest)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Login failed: invalid email or password", slog.String("email", credentials.Email))

                response := httpresponse.ErrorResponse{
                        Message: "Invalid email or password",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">user := models.User{
                ID:         uint(loginResponse.Id),
                Login:      loginResponse.Login,
                Email:      loginResponse.Email,
                AvatarPath: loginResponse.AvatarPath,
        }

        // v := validator.New()
        // if models.ValidateUser(v, &amp;user); !v.Valid() {
        //         httpresponse.SendJSONResponse(w, nil, http.StatusUnprocessableEntity, h.logger)
        //         return
        // }
        h.logger.Debug("User logged in successfully", slog.Int("userID", int(user.ID)), slog.String("email", user.Email))

        token, err := h.jwt.GenerateToken(user.ID, user.Email, user.Login)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Token generation failed", slog.String("userID", strconv.Itoa(int(user.ID))), slog.String("error", err.Error()))
                response := httpresponse.ErrorResponse{
                        Message: "Token generation failed",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusInternalServerError, h.logger)
                return
        }</span>
        <span class="cov0" title="0">h.logger.Debug("Token generated", slog.String("userID", strconv.Itoa(int(user.ID))), slog.String("login", user.Login), slog.String("email", user.Email))

        response := UserResponseWithToken{
                User:  user,
                Token: token,
        }

        h.logger.DebugContext(logCtx, "Login request completed successfully")

        httpresponse.SendJSONResponse(w, response, http.StatusOK, h.logger)</span>

}

// Logout godoc
// @Summary Logout a user
// @Description Log out the user by clearing the authentication token
// @Produce json
// @Success 200 {string} string "Logged out successfully"
// @Router /logout [post]
func (h *Handler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Handling logout request")

        _, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{

                h.logger.Warn("Failed to retrieve user ID from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.DebugContext(logCtx, "User logged out successfully")

        w.WriteHeader(http.StatusOK)</span>
}

// CurrentUser godoc
// @Summary Get the current user
// @Description Retrieve the current authenticated user information
// @Produce json
// @Success 200 {object} models.User "Current user"
// @Failure 401 {object} httpresponses.ErrorResponse "Unauthorized"
// @Failure 500 {object} httpresponses.ErrorResponse "Internal Server Error"
// @Router /users/me [get]
func (h *Handler) CurrentUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Fetching current user information")

        userID, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{

                h.logger.Warn("Failed to retrieve user ID from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">login, ok := r.Context().Value(middleware.LoginKey).(string)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Warn("Failed to retrieve user login from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">email, ok := r.Context().Value(middleware.EmailKey).(string)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Warn("Failed to retrieve user email from context")

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">response := models.User{
                ID:    userID,
                Login: login,
                Email: email,
        }
        h.logger.DebugContext(logCtx, "Successfully retrieved current user information", "userID", userID)

        httpresponse.SendJSONResponse(w, response, http.StatusOK, h.logger)</span>
}

// UploadAvatar godoc
// @Summary Upload user avatar
// @Description Upload an avatar image for the user
// @Accept multipart/form-data
// @Produce json
// @Param avatar formData file true "Avatar file"
// @Success 200 {string} string "Avatar uploaded successfully"
// @Failure 400 {object} httpresponses.ErrorResponse "Bad Request"
// @Failure 401 {object} httpresponses.ErrorResponse "Unauthorized"
// @Failure 500 {object} httpresponses.ErrorResponse "Internal Server Error"
// @Router /users/{userID}/avatar [put]
func (h *Handler) UploadAvatar(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Starting avatar upload process")

        userIDStr := mux.Vars(r)["userID"]
        userID, err := strconv.ParseUint(userIDStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid user ID format", "userID", userIDStr, "error", err)
                response := httpresponse.ErrorResponse{
                        Message: "Invalid user ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return

        }</span>

        <span class="cov0" title="0">authUserID, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok || authUserID != uint(userID) </span><span class="cov0" title="0">{
                h.logger.Warn("Unauthorized access attempt", "authUserID", authUserID, "targetUserID", userID)

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized to upload avatar for this ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">var requestData struct {
                Avatar string `json:"avatar"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;requestData); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid JSON format", "error", err)
                response := httpresponse.ErrorResponse{
                        Message: "Invalid request format",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(requestData.Avatar, "data:image/") </span><span class="cov0" title="0">{
                index := strings.Index(requestData.Avatar, ",")
                if index != -1 </span><span class="cov0" title="0">{
                        requestData.Avatar = requestData.Avatar[index+1:]
                }</span> else<span class="cov0" title="0"> {
                        h.logger.Error("Invalid base64 image format", "error", "missing ',' separator")
                        response := httpresponse.ErrorResponse{
                                Message: "Invalid base64 image format",
                        }
                        httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                        return
                }</span>
        }

        <span class="cov0" title="0">avatarData, err := base64.StdEncoding.DecodeString(requestData.Avatar)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode base64 image", "error", err)
                response := httpresponse.ErrorResponse{
                        Message: "Invalid base64 image data",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">fileType := http.DetectContentType(avatarData)
        h.logger.Debug("Detected file type", "fileType", fileType)

        if !strings.HasPrefix(fileType, "image/") </span><span class="cov0" title="0">{
                h.logger.Error("Invalid file type", "fileType", fileType)
                response := httpresponse.ErrorResponse{
                        Message: "Only image files are allowed",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">ext, err := mime.ExtensionsByType(fileType)
        if err != nil || len(ext) == 0 </span><span class="cov0" title="0">{
                h.logger.Error("Unable to determine file extension", "mimeType", fileType)
                response := httpresponse.ErrorResponse{
                        Message: "Unable to determine file extension",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">avatarFileName := fmt.Sprintf("user_%d_avatar%s", userID, ext[0])

        h.logger.Debug("Uploading avatar", "userID", userID, "avatarFileName", avatarFileName)

        uploadAvatarRequest := &amp;gen.UploadAvatarRequest{
                Id:             uint32(userID),
                AvatarData:     avatarData,
                AvatarFileName: avatarFileName,
        }

        uploadAvatarResponse, err := h.client.UploadAvatar(r.Context(), uploadAvatarRequest)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to upload avatar", "userID", userID, "error", err)
                response := httpresponse.ErrorResponse{
                        Message: "Failed to upload avatar",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusInternalServerError, h.logger)
                return
        }</span>

        <span class="cov0" title="0">response := map[string]string{
                "message":    "Avatar uploaded successfully",
                "avatarPath": uploadAvatarResponse.AvatarPath,
        }

        h.logger.DebugContext(logCtx, "Avatar uploaded successfully", "userID", userID, "avatarPath", uploadAvatarResponse.AvatarPath)

        httpresponse.SendJSONResponse(w, response, http.StatusOK, h.logger)</span>
}

// GetProfile godoc
// @Summary Get user profile
// @Description Retrieve the user profile information
// @Produce json
// @Param userID path int true "User ID"
// @Success 200 {object} models.UserProfile "User profile"
// @Failure 401 {object} httpresponses.ErrorResponse "Unauthorized"
// @Failure 404 {object} httpresponses.ErrorResponse "Not Found"
// @Failure 500 {object} httpresponses.ErrorResponse "Internal Server Error"
// @Router /users/{userID}/profile [get]
func (h *Handler) GetProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Starting user profile retrieval")

        userIDStr := mux.Vars(r)["userID"]
        userID, err := strconv.ParseUint(userIDStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid user ID format", "userID", userIDStr, "error", err)

                response := httpresponse.ErrorResponse{
                        Message: "Invalid user ID",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">requesterID, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Warn("Unauthorized access attempt", "userID", userID)

                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug("Fetching profile", "userID", userID, "requesterID", requesterID)

        getProfileRequest := &amp;gen.GetProfileRequest{
                Id:          uint32(userID),
                RequesterId: uint32(requesterID),
        }

        GetProfileResponse, err := h.client.GetProfile(r.Context(), getProfileRequest)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        h.logger.Warn("User not found", "userID", userID)

                        response := httpresponse.ErrorResponse{
                                Message: "User not found",
                        }
                        httpresponse.SendJSONResponse(w, response, http.StatusNotFound, h.logger)
                        return
                }</span>

                <span class="cov0" title="0">h.logger.Error("Error retrieving profile", "userID", userID, "error", err)

                response := httpresponse.ErrorResponse{
                        Message: "Failed to retrieve user profile",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusInternalServerError, h.logger)
                return</span>
        }
        <span class="cov0" title="0">h.logger.Debug("User profile retrieved successfully", "userID", userID)

        httpresponse.SendJSONResponse(w, GetProfileResponse, http.StatusOK, h.logger)</span>
}

func (h *Handler) UpdatePassword(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Starting user password updating")
        userID, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{
                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">login, ok := r.Context().Value(middleware.LoginKey).(string)
        if !ok </span><span class="cov0" title="0">{
                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">email, ok := r.Context().Value(middleware.EmailKey).(string)
        if !ok </span><span class="cov0" title="0">{
                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">var credentials struct {
                OldPassword string `json:"old_password"`
                NewPassword string `json:"new_password"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;credentials); err != nil </span><span class="cov0" title="0">{
                response := httpresponse.ErrorResponse{
                        Message: "Invalid request",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug("updating password", "userID", userID, "oldPassword", credentials.OldPassword, "newPassword", credentials.NewPassword)

        updatePasswordRequest := &amp;gen.UpdatePasswordRequest{
                Id:          uint32(userID),
                Login:       login,
                Email:       email,
                OldPassword: credentials.OldPassword,
                NewPassword: credentials.NewPassword,
        }

        _, err := h.client.UpdatePassword(r.Context(), updatePasswordRequest)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        response := httpresponse.ErrorResponse{
                                Message: "User not found",
                        }
                        httpresponse.SendJSONResponse(w, response, http.StatusNotFound, h.logger)
                        return
                }</span> else<span class="cov0" title="0"> if errors.Is(err, models.ErrMismatch) </span><span class="cov0" title="0">{
                        response := httpresponse.ErrorResponse{
                                Message: "Invalid old password",
                        }
                        httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                        return
                }</span>

                <span class="cov0" title="0">response := httpresponse.ErrorResponse{
                        Message: "Failed to update password",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusInternalServerError, h.logger)
                return</span>
        }

        <span class="cov0" title="0">response := struct {
                ID      uint   `json:"id"`
                Message string `json:"message"`
        }{
                ID:      userID,
                Message: "User's password updated successfully",
        }

        h.logger.Debug("User password updated successfully")

        httpresponse.SendJSONResponse(w, response, http.StatusOK, h.logger)</span>
}

func (h *Handler) UpdateProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logCtx := log.LogRequestStart(r.Context(), r.Method, r.RequestURI)
        h.logger.DebugContext(logCtx, "Starting user profile updating")

        userID, ok := r.Context().Value(middleware.IdKey).(uint)
        if !ok </span><span class="cov0" title="0">{
                response := httpresponse.ErrorResponse{
                        Message: "User is not authorized",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusUnauthorized, h.logger)
                return
        }</span>

        <span class="cov0" title="0">var userData struct {
                Login string `json:"username"`
                Email string `json:"email"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;userData); err != nil </span><span class="cov0" title="0">{
                response := httpresponse.ErrorResponse{
                        Message: "Invalid request",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusBadRequest, h.logger)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug("updating profile", "userID", userID, "username", userData.Login, "email", userData.Email)

        updateProfileRequest := &amp;gen.UpdateProfileRequest{
                UserId:   uint32(userID),
                Username: userData.Login,
                Email:    userData.Email,
        }

        _, err := h.client.UpdateProfile(r.Context(), updateProfileRequest)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        response := httpresponse.ErrorResponse{
                                Message: "User not found",
                        }
                        httpresponse.SendJSONResponse(w, response, http.StatusNotFound, h.logger)
                        return
                }</span>
                <span class="cov0" title="0">response := httpresponse.ErrorResponse{
                        Message: "Failed to update profile",
                }
                httpresponse.SendJSONResponse(w, response, http.StatusInternalServerError, h.logger)
                return</span>
        }

        <span class="cov0" title="0">h.logger.Debug("User profile updated successfully")

        response := struct {
                Username string `json:"username"`
                Email    string `json:"email"`
        }{
                Username: userData.Login,
                Email:    userData.Email,
        }
        httpresponse.SendJSONResponse(w, response, http.StatusOK, h.logger)</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package repo

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/dblogger"
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/Masterminds/squirrel"
        "github.com/lib/pq"
        _ "github.com/lib/pq"
)

type UserRepositoryImpl struct {
        db *dblogger.DB
}

func NewAuthRepository(db *dblogger.DB) *UserRepositoryImpl <span class="cov8" title="1">{
        return &amp;UserRepositoryImpl{db: db}
}</span>

func (r *UserRepositoryImpl) CreateUser(ctx context.Context, user models.User) (uint, error) <span class="cov8" title="1">{
        var userID uint
        query := `INSERT INTO "user" (login, email, password_hash, created_at) VALUES ($1, $2, $3, NOW()) RETURNING id`
        err := r.db.QueryRowContext(ctx, query, user.Login, user.Email, user.Password).Scan(&amp;userID)
        if err != nil </span><span class="cov8" title="1">{
                var pqErr *pq.Error
                if errors.As(err, &amp;pqErr) &amp;&amp; pqErr.Code == "23505" </span><span class="cov8" title="1">{
                        return 0, models.ErrAlreadyExists
                }</span>
                <span class="cov8" title="1">return 0, err</span>
        }

        <span class="cov8" title="1">return userID, nil</span>
}

func (r *UserRepositoryImpl) GetUserByEmail(ctx context.Context, email string) (models.User, error) <span class="cov8" title="1">{
        var user models.User
        query := `SELECT id, login, email, password_hash FROM "user" WHERE email = $1`
        row := r.db.QueryRowContext(ctx, query, email)
        err := row.Scan(&amp;user.ID, &amp;user.Login, &amp;user.Email, &amp;user.Password)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return models.User{}, fmt.Errorf("user not found with email: %s, %s", email, models.ErrNotFound)
                }</span>

                <span class="cov8" title="1">return models.User{}, err</span>
        }
        <span class="cov8" title="1">return user, nil</span>
}

func (r *UserRepositoryImpl) UpdateUser(ctx context.Context, user models.User) error <span class="cov8" title="1">{
        query := `UPDATE "user" SET login = $1, email=$2, password_hash = $3, updated_at = NOW() WHERE id = $4`
        _, err := r.db.ExecContext(ctx, query, user.Login, user.Email, user.Password, user.ID)
        return err
}</span>

func (r *UserRepositoryImpl) DeleteUser(ctx context.Context, id string) error <span class="cov8" title="1">{
        query := `DELETE FROM "user" WHERE id = $1`
        _, err := r.db.ExecContext(ctx, query, id)
        return err
}</span>

func (r *UserRepositoryImpl) GetAvatarPathByUserId(ctx context.Context, userID uint) (string, error) <span class="cov8" title="1">{
        query := `SELECT avatar_path FROM "user" WHERE id=$1`

        row := r.db.QueryRowContext(ctx, query, userID)

        var avatarPath string
        err := row.Scan(&amp;avatarPath)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("user not found: %w", models.ErrNotFound)
                }</span>
                <span class="cov8" title="1">return "", fmt.Errorf("failed to retrieve avatar path: %w", models.ErrInternal)</span>
        }

        <span class="cov8" title="1">return avatarPath, nil</span>
}

func (r *UserRepositoryImpl) UpdateAvatarPathByUserId(ctx context.Context, userID uint, avatarPath string) error <span class="cov8" title="1">{
        query := `UPDATE "user" SET avatar_path = $1 WHERE id = $2`

        result, err := r.db.ExecContext(ctx, query, avatarPath, userID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to execute update query: %w", models.ErrInternal)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retrieve rows affected: %w", models.ErrInternal)
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no rows were updated: %w", models.ErrNotFound)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *UserRepositoryImpl) GetUserByID(ctx context.Context, userID uint) (models.UserProfile, error) <span class="cov8" title="1">{
        queryBuilder := squirrel.Select("login, email, avatar_path").
                From(`"user"`).
                Where(squirrel.Eq{"id": userID}).
                PlaceholderFormat(squirrel.Dollar)

        query, args, err := queryBuilder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return models.UserProfile{}, fmt.Errorf("failed to build query: %w", models.ErrInternal)
        }</span>

        <span class="cov8" title="1">row := r.db.QueryRowContext(ctx, query, args...)

        var userProfile models.UserProfile

        if err := row.Scan(&amp;userProfile.Login, &amp;userProfile.Email, &amp;userProfile.AvatarPath); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return models.UserProfile{}, models.ErrNotFound
                }</span>
                <span class="cov8" title="1">return models.UserProfile{}, fmt.Errorf("failed to scan user profile: %w", models.ErrInternal)</span>
        }

        <span class="cov8" title="1">return userProfile, nil</span>
}

func (r *UserRepositoryImpl) UpdatePassword(ctx context.Context, userId uint, newPassword string) error <span class="cov8" title="1">{
        query := "UPDATE user SET password = $1 WHERE id = $2"

        result, err := r.db.ExecContext(ctx, query, newPassword, userId)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to execute update query: %w", models.ErrInternal)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retrieve rows affected: %w", models.ErrInternal)
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return models.ErrNotFound
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r UserRepositoryImpl) UpdateProfile(ctx context.Context, userID uint, login, email string) error <span class="cov8" title="1">{
        query := "UPDATE user SET email = $1, login = $2 WHERE id = $3"

        result, err := r.db.ExecContext(ctx, query, email, login, userID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to execute update query: %w", models.ErrInternal)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retrieve rows affected: %w", models.ErrInternal)
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return models.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package usecase

import (
        "2024_2_ThereWillBeName/internal/models"
        "2024_2_ThereWillBeName/internal/pkg/user"
        "context"
        "errors"
        "fmt"
        "log"
        "os"
        "path/filepath"

        "golang.org/x/crypto/bcrypt"
)

type UserUsecaseImpl struct {
        repo        user.UserRepo
        storagePath string
}

func NewUserUsecase(repo user.UserRepo, storagePath string) *UserUsecaseImpl <span class="cov8" title="1">{
        return &amp;UserUsecaseImpl{
                repo:        repo,
                storagePath: storagePath,
        }
}</span>

func saveAvatarData(avatarData []byte, path string) error <span class="cov0" title="0">{
        outFile, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create avatar file: %w", models.ErrInternal)
        }</span>
        <span class="cov0" title="0">defer outFile.Close()

        if _, err := outFile.Write(avatarData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write avatar content: %w", models.ErrInternal)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *UserUsecaseImpl) SignUp(ctx context.Context, user models.User) (uint, error) <span class="cov8" title="1">{
        hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
        user.Password = string(hashedPassword)
        return a.repo.CreateUser(ctx, user)
}</span>

func (a *UserUsecaseImpl) Login(ctx context.Context, email, password string) (models.User, error) <span class="cov8" title="1">{
        user, err := a.repo.GetUserByEmail(ctx, email)

        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error retrieving user: %v\n", err)
                return models.User{}, err
        }</span>

        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil </span><span class="cov8" title="1">{
                log.Printf("Password mismatch: %v\n", err)
                return models.User{}, err
        }</span> else<span class="cov8" title="1"> {
                log.Println("Password match!")
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (a *UserUsecaseImpl) UploadAvatar(ctx context.Context, userID uint, avatarData []byte, avatarFileName string) (string, error) <span class="cov0" title="0">{
        avatarPath, err := a.repo.GetAvatarPathByUserId(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to fetch avatar path: %w", models.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }

        <span class="cov0" title="0">realAvatarPath := filepath.Join(a.storagePath, avatarFileName)

        if avatarPath != "" &amp;&amp; avatarPath != avatarFileName </span><span class="cov0" title="0">{
                oldAvatarPath := filepath.Join(a.storagePath, avatarPath)
                if err := os.Remove(oldAvatarPath); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to delete old avatar file: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if err := saveAvatarData(avatarData, realAvatarPath); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to save avatar file: %w", err)
        }</span>

        <span class="cov0" title="0">if avatarPath == "" || avatarPath != avatarFileName </span><span class="cov0" title="0">{
                if err := a.repo.UpdateAvatarPathByUserId(ctx, userID, avatarFileName); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to update avatar path in database: %w", models.ErrInternal)
                }</span>
        }

        <span class="cov0" title="0">return avatarFileName, nil</span>
}

func (a *UserUsecaseImpl) GetProfile(ctx context.Context, userID, requesterID uint) (models.UserProfile, error) <span class="cov0" title="0">{
        user, err := a.repo.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        return models.UserProfile{}, fmt.Errorf("invalid request: %w", models.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return models.UserProfile{}, fmt.Errorf("internal error: %w", models.ErrInternal)</span>
        }

        <span class="cov0" title="0">if requesterID != userID </span><span class="cov0" title="0">{
                user.Email = ""
        }</span>

        <span class="cov0" title="0">return models.UserProfile{
                Login:      user.Login,
                AvatarPath: user.AvatarPath,
                Email:      user.Email,
        }, nil</span>
}

func (a *UserUsecaseImpl) UpdatePassword(ctx context.Context, userData models.User, newPassword string) error <span class="cov0" title="0">{
        user, err := a.repo.GetUserByEmail(ctx, userData.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("UpdatePassword: Error retrieving user: %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(userData.Password)); err != nil </span><span class="cov0" title="0">{
                log.Printf("UpdatePassword: Password mismatch: %v\n", err)
                return models.ErrMismatch
        }</span>

        <span class="cov0" title="0">hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)

        return a.repo.UpdatePassword(ctx, user.ID, string(hashedPassword))</span>
}

func (a *UserUsecaseImpl) UpdateProfile(ctx context.Context, userID uint, login, email string) error <span class="cov0" title="0">{
        return a.repo.UpdateProfile(ctx, userID, login, email)
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package validator

import "regexp"

var EmailRX = regexp.MustCompile("^[a-zA-Z0-9.!#$%&amp;'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")

type Validator struct {
        Errors map[string]string
}

func New() *Validator <span class="cov8" title="1">{
        return &amp;Validator{Errors: make(map[string]string)}
}</span>

func (v *Validator) Valid() bool <span class="cov8" title="1">{
        return len(v.Errors) == 0
}</span>

func (v *Validator) AddError(key, message string) <span class="cov0" title="0">{
        if _, exists := v.Errors[key]; !exists </span><span class="cov0" title="0">{
                v.Errors[key] = message
        }</span>
}

func (v *Validator) Check(ok bool, key, message string) <span class="cov8" title="1">{
        if !ok </span><span class="cov0" title="0">{
                v.AddError(key, message)
        }</span>
}

func (v *Validator) Matches(value string, rx *regexp.Regexp) bool <span class="cov0" title="0">{
        return rx.MatchString(value)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
